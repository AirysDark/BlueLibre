{
  "timestamp": "2025-09-05T09:09:22.830682Z",
  "target": "android",
  "detector_log": "",
  "detector_json": {
    "timestamp": "2025-09-05T08:36:38.742830Z",
    "types": [
      "android",
      "linux",
      "cmake"
    ],
    "hits": {
      "android_gradle": [
        "android/settings.gradle.kts",
        "android/build.gradle.kts",
        "android/app/build.gradle.kts",
        "folder-hint:android"
      ],
      "cmakelists": [
        "CMakeLists.txt",
        "linux/CMakeLists.txt",
        "android/app/src/main/cpp/CMakeLists.txt"
      ],
      "make_like": [
        "folder-hint:linux"
      ],
      "node": [],
      "python": [],
      "rust": [],
      "dotnet": [],
      "maven": [],
      "flutter": [],
      "go": [],
      "bazel": [],
      "scons": [],
      "ninja": []
    },
    "cmake_flavors": [
      {
        "path": "CMakeLists.txt",
        "flavor": "desktop"
      },
      {
        "path": "linux/CMakeLists.txt",
        "flavor": "desktop"
      },
      {
        "path": "android/app/src/main/cpp/CMakeLists.txt",
        "flavor": "desktop"
      }
    ],
    "folder_hints": [
      ".github",
      "airpods",
      "android",
      "app",
      "assets",
      "ble",
      "com",
      "composables",
      "constants",
      "cpp",
      "docs",
      "drawable",
      "drawable-nodpi",
      "drawable-v21",
      "drawable-v24",
      "font",
      "fonts",
      "gradle",
      "head-tracking",
      "imgs",
      "include",
      "java",
      "kavishdevar",
      "layout",
      "librepods",
      "libs",
      "linux",
      "main",
      "me",
      "media",
      "meta-inf",
      "mipmap-anydpi-v26",
      "mipmap-hdpi",
      "mipmap-mdpi",
      "mipmap-xhdpi",
      "mipmap-xxhdpi",
      "mipmap-xxxhdpi",
      "models",
      "packaging",
      "qr-code-generator",
      "raw",
      "raw-night",
      "receivers",
      "res",
      "resources",
      "screens",
      "services",
      "src",
      "theme",
      "thirdparty",
      "tools",
      "ui",
      "utils",
      "values",
      "values-night",
      "values-night-v31",
      "values-v21",
      "values-v31",
      "widgets",
      "workflows",
      "wrapper",
      "xml",
      "xposed",
      "yourco"
    ]
  },
  "structure": [
    {
      "dir": ".",
      "files": [
        {
          "name": "CMakePresets.json",
          "ext": ".json",
          "size": 467,
          "preview": "{\n  \"version\": 6,\n  \"configurePresets\": [\n    {\n      \"name\": \"win64-release\",\n      \"displayName\": \"Windows 10 x64 (Release)\",\n      \"generator\": \"Ninja\",\n      \"binaryDir\": \"${sourceDir}/build\",\n      \"cacheVariables\": {\n        \"CMAKE_BUILD_TYPE\": \"Release\",\n        \"CMAKE_TOOLCHAIN_FILE\": \"${sourceDir}/.vcpkg/scripts/buildsystems/vcpkg.cmake\"\n      }\n    }\n  ],\n  \"buildPresets\": [\n    { \"name\": \"win64-release-build\", \"configurePreset\": \"win64-release\" }\n  ]\n}"
        },
        {
          "name": "STOCK_BUILD.md",
          "ext": ".md",
          "size": 1712,
          "preview": "\n# LibrePods \u2014 Stock (Non\u2011root) Build\n\nThis build removes the L2CAP FCR native hook and Magisk/Xposed artifacts so the app runs on unmodified Android.\n\n## Changes\n- Removed `root-module/` and all Magisk packaging scripts.\n- Disabled `System.loadLibrary(\"l2c_fcr_hook\")` and any runtime offset checks.\n- Start destination goes directly to the app (no root/onboarding gate).\n- JNI kept only for `airpods_core` payload parsing (safe).\n\n## Bluetooth Path (Public APIs Only)\n- BLE GATT for discovery/control.\n- Optionally add BLE L2CAP CoC for API 29+ (client/server) with GATT fallback.\n\nBuild & behavior\n\nOpen android/ in Android Studio \u2192 build/run app.\n\nOn Android 10+:\n\nIf your pods (or your accessory firmware) expose a PSM characteristic at 0000FF01-0000-1000-8000-00805F9B34FB, the app will try L2CAP CoC.\n\nIf not, or if connect fails, it falls back to GATT seamlessly.\n\n\nToggle is ON by default; users can switch it off anytime in App Settings.\n\n## Optional: High-throughput BLE L2CAP CoC (API 29+)\n- Added `com.yourco.airpods.L2capCocManager` and integrated into `BleClient`.\n- If the accessory exposes a **PSM characteristic** at UUID `0000FF01-0000-1000-8000-00805F9B34FB` (little-endian 16-bit PSM),\n  the app will attempt a **CoC** client connection automatically and fall back to GATT on failure.\n- You can flip the in-code flag `useCocPreferred` to force GATT if needed.\n\n> Note: AirPods may not expose CoC; this logic auto-falls back to GATT if CoC isn\u2019t available.\n\nAdded a **Settings toggle** under CocSettingsScreen: lets the user enable/disable L2CAP CoC preference at runtime.\n\n- Added Settings toggle: **Prefer high-throughput (L2CAP)** in App Settings. Persisted via SharedPreferences.\n"
        },
        {
          "name": "README.md",
          "ext": ".md",
          "size": 2438,
          "preview": "# Bluelibre\n\nA cross-platform AirPods desktop & Android client.  \nSupports model detection and battery status display for **AirPods 1, 2, 3, 4, 4 ANC, Pro, Pro 2, and Max**.\n\n---\n\n=======\n>>>>>>> b9ad7d31f761902b107364aa10d1d236867ab441\n## \ud83d\udda5\ufe0f Windows 10/11 (x64)\n\n```powershell\ngit clone https://github.com/AirysDark/librepods\ncd librepods\n\n# Bootstrap vcpkg\ngit clone https://github.com/microsoft/vcpkg .vcpkg\n.\\.vcpkg\\bootstrap-vcpkg.bat\n\n# Configure & build (uses CMakePresets.json)\ncmake --preset win64-release\ncmake --build --preset win64-release-build --parallel\ncmake --install build --prefix build\\out\n```\n\n---\n\n## \ud83d\udc27 Linux (Ubuntu/Debian)\n\n```bash\nsudo apt update\nsudo apt install -y build-essential cmake ninja-build pkg-config libdbus-1-dev libbluetooth-dev\n\ngit clone https://github.com/AirysDark/librepods\ncd librepods\n\ngit rm airpods_models.cpp && git commit -m \"fix: remove duplicate root airpods_models.cpp\"  # if present\n\ncmake -S . -B build -G Ninja -DCMAKE_BUILD_TYPE=Release\ncmake --build build --parallel\nsudo cmake --install build --prefix /usr/local\n```\n\n---\n\n## \ud83e\udd16 Android\n\n```bash\ncd android\nchmod +x gradlew\n./gradlew :app:assembleDebug\n```\n\nOr open `android/` in **Android Studio** (Java 17 + NDK + CMake required).\n\n---\n\n## \u2699\ufe0f GitHub Actions (CI)\n\n### Windows workflow\nEnsure the job:\n- Runs on `windows-latest`\n- Installs **Ninja**\n- Bootstraps **vcpkg**\n- Calls `cmake --preset win64-release` and builds\n\nExample steps:\n\n```yaml\n- uses: actions/checkout@v4\n- name: Install Ninja\n  run: choco install ninja -y\n- name: Bootstrap vcpkg\n  run: |\n    git clone https://github.com/microsoft/vcpkg .vcpkg\n    .\\.vcpkg\\bootstrap-vcpkg.bat\n- name: Configure\n  run: cmake --preset win64-release\n- name: Build\n  run: cmake --build --preset win64-release-build --parallel\n```\n\n### Android workflow\n- Use **Java 17 (Temurin)**\n- Install **NDK + CMake** in runner\n- Make `gradlew` executable\n- Build with `:app:assembleDebug`\n\nExample steps:\n\n```yaml\n- uses: actions/checkout@v4\n- uses: actions/setup-java@v4\n  with:\n    distribution: temurin\n    java-version: \"17\"\n- name: Grant execute to gradlew\n  run: chmod +x android/gradlew\n- name: Build debug APK\n  working-directory: android\n  run: ./gradlew :app:assembleDebug --no-daemon\n```\n\n---\n\n## \ud83d\udce6 Features\n- WinRT backend for Windows\n- BlueZ/DBus backend for Linux\n- Kotlin BLE + JNI bridge for Android\n- All AirPods models supported with fallback display\n"
        },
        {
          "name": ".editorconfig",
          "ext": "",
          "size": 424
        },
        {
          "name": "fix-android-apk.patch",
          "ext": ".patch",
          "size": 4197
        },
        {
          "name": "README-ANDROID-CI.md",
          "ext": ".md",
          "size": 909,
          "preview": "# Librepods Android CI Quick Drop-in\n\nThis bundle gives you:\n- `.github/workflows/android.yml` \u2014 minimal, stable CI using JDK 21 + Gradle cache.\n- `android/gradle.properties` \u2014 safe defaults for CI speed.\n- `android/app/build.gradle.kts` \u2014 cleaned app module config (no androidComponents/APK hooks).\n\n## How to apply\n\n1. Copy **.github/workflows/android.yml** into your repo.\n2. Copy **android/gradle.properties** (merge with yours if you already have one).\n3. Replace **android/app/build.gradle.kts** (or adapt the changes into your current file).\n\n> Important: Remove any `androidComponents { ... }` code that references `MultipleArtifact.APK`.\n> That API doesn't exist; it prevents variants from being created, which is why no APKs are produced.\n\n## Run locally\nFrom the `android` folder:\n```\n./gradlew assembleDebug\n```\nThe APK will be at:\n```\nandroid/app/build/outputs/apk/debug/app-debug.apk\n```'\n"
        },
        {
          "name": "airpods_models.cpp",
          "ext": ".cpp",
          "size": 811,
          "preview": "#include \"models/airpods_models.h\"\n#include <cstdio>\n\nnamespace airpods {\n\nstd::string_view ModelName(Model m) {\n  switch (m) {\n    case Model::AirPods1:    return \"AirPods (1st gen)\";\n    case Model::AirPods2:    return \"AirPods (2nd gen)\";\n    case Model::AirPods3:    return \"AirPods (3rd gen)\";\n    case Model::AirPods4:    return \"AirPods 4\";\n    case Model::AirPods4ANC: return \"AirPods 4 (ANC)\";\n    case Model::AirPodsPro:  return \"AirPods Pro\";\n    case Model::AirPodsPro2: return \"AirPods Pro (2nd gen)\";\n    case Model::AirPodsMax:  return \"AirPods Max\";\n    default:                 return \"AirPods (Unknown model)\";\n  }\n}\n\nstd::string FallbackName(uint16_t raw_id) {\n  char buf[64];\n  std::snprintf(buf, sizeof(buf), \"AirPods (0x%04X)\", raw_id);\n  return std::string(buf);\n}\n\n} // namespace airpods"
        },
        {
          "name": "WORKFLOWS_README.md",
          "ext": ".md",
          "size": 531,
          "preview": "# CI Workflows for librepods\n\nDrop this `.github/workflows/` folder into the root of your repository.\n\n## Windows x64 Build\n- Installs Ninja\n- Bootstraps vcpkg\n- Configures with CMake preset `win64-release`\n- Builds, installs to `build/out`, and uploads an artifact\n\n## Android Debug APK\n- Uses Java 17 (Temurin)\n- Makes Gradle wrapper executable\n- Builds `:app:assembleDebug` and uploads the APK\n\nIf the Android job cannot find NDK/CMake automatically,\nuncomment the SDK manager steps to install a specific NDK and CMake version.\n"
        },
        {
          "name": "LICENSE",
          "ext": "",
          "size": 34522
        },
        {
          "name": "CMakeLists.txt",
          "ext": ".txt",
          "size": 1796,
          "preview": "cmake_minimum_required(VERSION 3.24)\nproject(AirPodsDesktop VERSION 0.4.0 LANGUAGES CXX)\n\n# Optional in-tree vcpkg for Windows users\nif (WIN32 AND NOT DEFINED CMAKE_TOOLCHAIN_FILE AND EXISTS \"${CMAKE_SOURCE_DIR}/.vcpkg/scripts/buildsystems/vcpkg.cmake\")\n  set(CMAKE_TOOLCHAIN_FILE \"${CMAKE_SOURCE_DIR}/.vcpkg/scripts/buildsystems/vcpkg.cmake\" CACHE STRING \"\" FORCE)\nendif()\n\nset(CMAKE_CXX_STANDARD 20)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\nif (MSVC)\n  add_compile_options(/permissive- /Zc:preprocessor /utf-8 /W4 /EHsc)\n  add_definitions(-D_WIN32_WINNT=0x0A00) # Windows 10\nelse()\n  add_compile_options(-Wall -Wextra -Wpedantic)\nendif()\n\nfind_package(Threads REQUIRED)\n\n# Platform BLE backends\nif (WIN32)\n  add_definitions(-DPLATFORM_WINRT)\n  set(BLE_BACKEND_SRC src/ble/winrt_ble.cpp)\n  set(BLE_BACKEND_INC include/ble/winrt_ble.h)\n  set(PLATFORM_LIBS windowsapp)\nelseif (UNIX)\n  add_definitions(-DPLATFORM_BLUEZ)\n  find_package(PkgConfig REQUIRED)\n  pkg_check_modules(DBUS REQUIRED dbus-1)\n  pkg_check_modules(BLUEZ REQUIRED bluez)\n  set(BLE_BACKEND_SRC src/ble/bluez_ble.cpp)\n  set(BLE_BACKEND_INC include/ble/bluez_ble.h)\n  set(PLATFORM_LIBS ${DBUS_LIBRARIES} ${BLUEZ_LIBRARIES})\n  include_directories(${DBUS_INCLUDE_DIRS} ${BLUEZ_INCLUDE_DIRS})\nendif()\n\nfile(GLOB_RECURSE APP_SOURCES CONFIGURE_DEPENDS\n     src/*.cpp src/*.cc src/*.c\n     include/*.h include/*.hpp)\n\nadd_executable(AirPodsDesktop\n  ${APP_SOURCES}\n  ${BLE_BACKEND_SRC}\n  include/ble/ble_backend.h\n  include/models/airpods_models.h\n  src/models/airpods_models.cpp\n  ${BLE_BACKEND_INC}\n)\n\ntarget_include_directories(AirPodsDesktop PRIVATE include)\ntarget_link_libraries(AirPodsDesktop PRIVATE ${PLATFORM_LIBS} Threads::Threads)\n\ninclude(GNUInstallDirs)\ninstall(TARGETS AirPodsDesktop RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})"
        },
        {
          "name": "AAP Definitions.md",
          "ext": ".md",
          "size": 17662,
          "preview": "# AAP Definitions (As per AirPods Pro 2 (USB-C) Firmware 7A305)\n\nAAP runs on top of L2CAP, with a PSM of 0x1001 or 4097.\n\n# Handshake\nThis packet is necessary to establish a connection with the AirPods. Or else, the AirPods will not respond to any packets.\n\n```plaintext\n00 00 04 00 01 00 02 00 00 00 00 00 00 00 00 00\n```\n\n# Setting specific features for AirPods Pro 2\n\n> *may work for airpods 4 anc also, not tested*\n\nSince apple likes to wall off some features behind specific OS versions, and apple silicon devices, some packets are necessary to enable these features.\n\nI captured the following packet only accidentally, because Apple being Apple decided to hide *this* and *the handshake* from packetlogger, but sometimes it shows up.\n\n*Captured using PacketLogger on an Intel Mac running macOS Sequoia 15.0.1*\n```plaintext\n04 00 04 00 4d 00 ff 00 00 00 00 00 00 00\n```\n\nThis packet enables conversational awareness when playing audio. (CA works without this packet only when no audio is playing)\n\nIt also enables the Adaptive Transparency feature. (We can set Adaptive Transparency, but it doesn't respond with the same packet See [Noise Cancellation](#changing-noise-control))\n\n# Requesting notifications\n\nThis packet is necessary to receive notifications from the AirPods like ear detection, noise control mode, conversational awareness, battery status, etc.\n\n*Captured using PacketLogger on an Intel Mac running macOS Sequoia 15.0.1*\n```plaintext\n04 00 04 00 0F 00 FF FF FE FF\n```\n\nThis packet also works.\n\n```plaintext\n04 00 04 00 0F 00 FF FF FF FF\n```\n\n# Notifications\n\n## Battery\n\nAirPods occasionally send battery status packets. The packet format is as follows:\n\n```plaintext\n04 00 04 00 04 00 [battery count] ([component] 01 [level] [status] 01) times the battery count\n```\n\n| Components | Byte value |\n|------------|------------|\n| Case       | 08         |\n| Left       | 04         |\n| Right      | 02         |\n\n| Status       | Byte value |\n|------------- |------------|\n| Unknown      | 00         |\n| Charging     | 01         |\n| Discharging  | 02         |\n| Disconnected | 04         |\n\n\nExample packet from AirPods Pro 2\n\n```plaintext\n04 00 04 00 04 00 03 02 01 64 02 01 04 01 63 01 01 08 01 11 02 01\n```\n\n| Byte      | Interpretation                     |\n|-----------|------------------------------------|\n| 7th byte  | Battery Count - 3                  |\n| 8th byte  | Battery type - Left                |\n| 9th byte  | Spacer, value = 0x01               |\n| 10th byte | Battery level 100%                 |\n| 11th byte | Battery status - Discharging       |\n| 12th byte | Battery component end value = 0x01 |\n| 13th byte | Battery type - Right               |\n| 14th byte | Spacer, value = 0x01               |\n| 15th byte | Battery level 99%                  |\n| 16th byte | Battery status - Charging          |\n| 17th byte | Battery component end value = 0x01 |\n| 18th byte | Battery type - Case                |\n| 19th byte | Spacer, value = 0x01               |\n| 20th byte | Battery level 17%                  |\n| 21st byte | Battery status - Discharging       |\n| 22nd byte | Battery component end value = 0x01 |\n\n## Noise Control\n\nThe AirPods Pro 2 send noise control packets when the noise control mode is changed (either by a stem long press or by the connected device, see [Changing noise control](#changing-noise-control)). The packet format is as follows:\n\n```plaintext\n04 00 04 00 09 00 0D [mode] 00 00 00\n```\n\n| Noise Control Mode    | Byte value |\n|-----------------------|------------|\n| Off                   | 01         |\n| Noise Cancellation    | 02         |\n| Transparency          | 03         |\n| Adaptive Transparency | 04         |\n\n## Ear Detection\n\nAirPods send ear detection packets when the ear detection status changes. The packet format is as follows:\n```plaintext\n04 00 04 00 06 00 [primary pod] [secondary pod]\n```\n\nIf primary is removed, mic will be changed and the secondary will be the new primary, so the primary will be the one in the ear, and the packet will be sent again.\n\n| Pod Status | Byte value |\n|------------|------------|\n| In Ear     | 00         |\n| Out of Ear | 01         |\n| In Case    | 02         |\n\n## Conversational Awareness\n\nAirPods send conversational awareness packets when the person wearing them start speaking. The packet format is as follows:\n\n```plaintext\n04 00 04 00 4B 00 02 00 01 [level]\n```\n\n| Level Byte Value    | Meaning                                                 |\n|---------------------|---------------------------------------------------------|\n| 01/02               | Person Started Speaking; greatly reduce volume          |\n| 03                  | Person Stopped Speaking; increase volume back to normal |\n| Intermediate values | Intermediate volume levels                              |\n| 08/09               | Normal Volume                                           |\n### Reading Conversational Awareness State\n\nAfter requesting notifications, the AirPods send a packet indicating the current state of Conversational Awareness (CA). This packet is only sent once after notifications are requested, not when the CA state is changed.\n\nThe packet format is:\n\n```plaintext\n04 00 04 00 09 00 28 [status] 00 00 00\n```\n\n- `[status]` is a single byte at offset 7 (zero-based), immediately after the header.\n    - `0x01` \u2014 Conversational Awareness is **enabled**\n    - `0x02` \u2014 Conversational Awareness is **disabled**\n    - Any other value \u2014 Unknown/undetermined state\n\n**Example:**\n```plaintext\n04 00 04 00 09 00 28 01 00 00 00\n```\nHere, `01` at the 8th byte (offset 7) means CA is enabled.\n\n## Metadata\n\nThis packet contains device information like name, model number, etc. The packet format is:\n\n```plaintext\n04 00 04 00 1d [strings...]\n```\n\nThe strings are null-terminated UTF-8 strings in the following order:\n\n1. Bluetooth advertising name (varies in length)\n2. Model number \n3. Manufacturer\n4. Serial number\n5. Firmware version\n6. Firmware version 2 (the exact same as before??)\n7. Software version   (1.0.0 why would we need it?)\n8. App identifier     (com.apple.accessory.updater.app.71 what?)\n9. Serial number 1\n10. Serial number 2\n11. Unknown numeric value\n12. Encrypted data\n13. Additional encrypted data\n\nExample packet:\n```plaintext\n040004001d0002d5000400416972506f64732050726f004133303438004170706c6520496e632e0051584e524848595850360036312e313836383034303030323030303030302e323731330036312e313836383034303030323030303030302e3237313300312e302e3000636f6d2e6170706c652e6163636573736f72792e757064617465722e6170702e3731004859394c5432454632364a59004833504c5748444a32364b3000363335373533360089312a6567a5400f84a3ca234947efd40b90d78436ae5946748d70273e66066a2589300035333935303630363400```\n\nThe packet contains device identification and version information followed by some encrypted data whose format is not known.\n```\n\n# Writing to the AirPods\n\n## Changing Noise Control\n\nWe can send a packet to change the noise control mode. The packet format is as follows:\n\n```plaintext\n04 00 04 00 09 00 0D [mode] 00 00 00\n```\n\n| Noise Control Mode    | Byte value |\n|-----------------------|------------|\n| Off                   | 01         |\n| Noise Cancellation    | 02         |\n| Transparency          | 03         |\n| Adaptive Transparency | 04         |\n\nThe airpods will respond with the same packet after the mode has been changed.\n\n> But if your airpods support Adaptive Transparency, and you haven't sent that [special packet](#setting-specific-features-for-airpods-pro-2) to enable it, the airpods will respond with the same packet but with a different mode (like 0x02).\n\n## Renaming AirPods\n\nWe can send a packet to rename the AirPods. The packet format is as follows:\n\n```plaintext\n04 00 04 00 1A 00 01 [size] 00 [name]\n```\n\n## Toggle case charging sounds\n\n> *This feature is only for cases with a speaker, i.e. the AirPods Pro 2 and the new AirPods 4. Tested only on AirPods Pro 2*\n\nWe can send a packet to toggle if sounds should be played when the case is connected to a charger. The packet format is as follows:\n\n```plaintext\n12 3A 00 01 00 08 [setting]\n```\n\n| Byte Value | Sound |\n|------------|-------|\n| 00         | On    |\n| 01         | Off   |\n\n## Toggle Conversational Awareness\n\n> *This feature is only for AirPods Pro 2 and the new AirPods 4 with ANC. Tested only on AirPods Pro 2*\n\nWe can send a packet to toggle Conversational Awareness. If enabled, the AirPods will switch to Transparency mode when the person wearing them starts speaking (and sends packet for notifying the device to reduce volume). The packet format is as follows:\n\n```plaintext\n04 00 04 00 09 00 28 [setting] 00 00 00\n```\n\n| Byte Value | C.A. |\n|------------|------|\n| 01         | On   |\n| 02         | Off  |\n\n## Adaptive Audio Noise\n\n> *This feature is only for AirPods Pro 2 and the new AirPods 4 with ANC. Tested only on AirPods Pro 2*\n\nThe new firmware `7A305` for app2 has a new feature called Adaptive Audio Noise. This allows us to control how much noise is passed through the AirPods when the noise control mode is set to Adaptive. The packet format is as follows:\n\n```plaintext\n04 00 04 00 09 00 2E [level] 00 00 00\n```\n\nThe level can be any value between 0 and 100, 0 to allow maximum noise (i.e. minimum noise filtering), and 100 to filter out more noise.\n\n> This feature is only effective when the noise control mode is set to Adaptive.\n\n*I find it quite funny how I have greater control over the noise control on the AirPods on non-Apple devices than on Apple devices, becuase on Apple Devices, there are just 3 options More Noise (0), Midway through (50), and Less Noise (100), but here I can set any value between 0 and 100.*\n\n## Accessiblity Settings\n\n## Headphone Accomodation\n```\n04 00 04 00 53 00 84 00 02 02 [Phone] [Media]\n[EQ1][EQ2][EQ3][EQ4][EQ5][EQ6][EQ7][EQ8]\nduplicated thrice for some reason\n```\n\n| Data                | Type          | Value range                 |\n|---------------------|---------------|-----------------------------|\n| Phone               | Decimal       | 1 (Enabled) or 2 (Disabled) |\n| Media               | Decimal       | 1 (Enabled) or 2 (Disabled) |\n| EQ                  | Little Endian | 0 to 100                    |\n\n## Customize Transparency mode\n\n```\n52 18 00\nFor left bud\n[Enabled]\n[EQ1][EQ2][EQ3][EQ4][EQ5][EQ6][EQ7][EQ8]\n[Amplification]\n[Tone]\n[Conversation Boost]\n[Ambient Noise Reduction]\n00 0080 3F\n<same for the right bud>\n```\n\n<!-- demo packet\n52 18 00 00 00 00 00 62 10 DA 41 62 10 DA 41 62 10 DA 41 62 10 DA 41 62 10 DA 41 62 10 DA 41 62 10 DA 41 62 10 DA 41 62 10 DA 41 00 00 80 3f 00 00 80 3f 00 00 80 3f 62 10 DA 41 62 10 DA 41 62 10 DA 41 62 10 DA 41 62 10 DA 41 62 10 DA 41 62 10 DA 41 62 10 DA 41 62 10 DA 41 00 00 80 3f 00 00 80 3f 00 00 80 3f\n\n-->\n<!-- \n5218 0000 0080 3F62 10DA 413D 0AF0 4160\nE50C 42AC 9C1E 421B 2F29 429E 6F33 4293\n1846 4293 1846 4206 9476 BF00 576E BB00\n0080 3F00 0080 3F62 10DA 413D 0AF0 4160\nE50C 42AC 9C1E 421B 2F29 429E 6F33 4293\n1846 4293 1846 4200 0080 BF00 576E BB00\n0080 3F00 0080 3F\n-->\n\n<!-- \n5218 0000 0000 0062 10DA 413D 0AF0 4160\nE50C 42AC 9C1E 421B 2F29 429E 6F33 4293\n1846 4293 1846 4206 9476 BF00 576E BB00\n0080 3F00 0080 3F62 10DA 413D 0AF0 4160\nE50C 42AC 9C1E 421B 2F29 429E 6F33 4293\n1846 4293 1846 4200 0080 BF00 576E BB00\n0080 3F00 0080 3F\n -->\n\nAll values are formatted as Little Endian from float values.\n| Data                | Type          | Value range |\n|---------------------|---------------|-------------|\n| Enabled             | Little Endian | 0 or 1      |\n| EQ                  | Little Endian | 0 to 100    |\n| Amplification       | Little Endian | -1 to 1     |\n| Tone                | Little Endian | -1 to 1     |\n| Conversation Boost  | Little Endian | 0 or 1      |\n\n> [!IMPORTANT]\n> Also send the [Headphone Accomodation](#headphone-accomodation) after this.\n\n\n## Configure Stem Long Press\n\nI have noted all the packets sent to configure what the press and hold of the steam should do. The packets sent are specific to the current state. And are probably overwritten everytime the AirPods are connected to a new (apple) device that is not synced with icloud (i think)... So, for non-Apple device too, the configuration needs to be stored and overwritten everytime the AirPods are connected to the device. That is the only way to keep the configuration.\n\nThis is also the only way to control the configuration as the previous state needs to be known, and then the new state can be set. \n\nThe packets sent (based on the previous states) are as follows:\n\n<details>\n<summary>Toggling Adaptive</summary>\n\n<code>04 00 04 00 09 00 1A 0B 00 00 00</code> - Turns on Adaptive from O and ANC  \n<code>04 00 04 00 09 00 1A 0D 00 00 00</code> - Turns on Adaptive from O and T  \n<code>04 00 04 00 09 00 1A 0E 00 00 00</code> - Turns on Adaptive from T and ANC  \n<code>04 00 04 00 09 00 1A 0F 00 00 00</code> - Turns on Adaptive from O, T, ANC  \n\n<code>04 00 04 00 09 00 1A 03 00 00 00</code> - Turns off Adaptive from O and ANC (and Adaptive)  \n<code>04 00 04 00 09 00 1A 05 00 00 00</code> - Turns off Adaptive from O and T (and Adaptive)  \n<code>04 00 04 00 09 00 1A 06 00 00 00</code> - Turns off Adaptive from T and ANC (and Adaptive)  \n<code>04 00 04 00 09 00 1A 07 00 00 00</code> - Turns off Adaptive from O, T, ANC (and Adaptive)  \n\n</details>\n\n<details>\n<summary>Toggling Transparency</summary>\n\n<code>04 00 04 00 09 00 1A 07 00 00 00</code> - Turns on Transparency from O and ANC  \n<code>04 00 04 00 09 00 1A 0D 00 00 00</code> - Turns on Transparency from O and Adaptive  \n<code>04 00 04 00 09 00 1A 0E 00 00 00</code> - Turns on Transparency from Adaptive, and ANC  \n<code>04 00 04 00 09 00 1A 0F 00 00 00</code> - Turns on Transparency from O and Adaptive and ANC  \n\n<code>04 00 04 00 09 00 1A 03 00 00 00</code> - Turns off Transparency from O and ANC (and Transparency)  \n<code>04 00 04 00 09 00 1A 09 00 00 00</code> - Turns off Transparency from O and Adaptive (and Transparency)  \n<code>04 00 04 00 09 00 1A 0A 00 00 00</code> - Turns off Transparency from Adaptive, and ANC (and Transparency)  \n<code>04 00 04 00 09 00 1A 0B 00 00 00</code> - Turns off Transparency from O and Adaptive and ANC (and Transparency)  \n\n</details>\n\n<details>\n<summary>Toggling ANC</summary>\n\n<code>04 00 04 00 09 00 1A 07 00 00 00</code> - Turns on ANC from O, and Transparency  \n<code>04 00 04 00 09 00 1A 0B 00 00 00</code> - Turns on ANC from O, and Adaptive  \n<code>04 00 04 00 09 00 1A 0E 00 00 00</code> - Turns on ANC from Adaptive, and Transparency  \n<code>04 00 04 00 09 00 1A 0F 00 00 00</code> - Turns on ANC from O and Adaptive and Transparency  \n\n<code>04 00 04 00 09 00 1A 05 00 00 00</code> - Turns off ANC from O and Transparency (and ANC)  \n<code>04 00 04 00 09 00 1A 09 00 00 00</code> - Turns off ANC from O and Adaptive (and ANC)  \n<code>04 00 04 00 09 00 1A 0C 00 00 00</code> - Turns off ANC from Adaptive, and Transparency (and ANC)  \n<code>04 00 04 00 09 00 1A 0D 00 00 00</code> - Turns off ANC from O and Adaptive and Transparency (and ANC)  \n\n</details>\n\n<details>\n<summary>Toggling O</summary>\n\n<code>04 00 04 00 09 00 1A 07 00 00 00</code> - Turns on O from Transparency, and ANC  \n<code>04 00 04 00 09 00 1A 0B 00 00 00</code> - Turns on O from Adaptive, and ANC  \n<code>04 00 04 00 09 00 1A 0D 00 00 00</code> - Turns on O from Transparency, and Adaptive  \n<code>04 00 04 00 09 00 1A 0F 00 00 00</code> - Turns on O from Transparency, and Adaptive, and ANC  \n\n<code>04 00 04 00 09 00 1A 06 00 00 00</code> - Turns off O from Transparency, and ANC (and O)  \n<code>04 00 04 00 09 00 1A 0A 00 00 00</code> - Turns off O from Adaptive, and ANC (and O)  \n<code>04 00 04 00 09 00 1A 0C 00 00 00</code> - Turns off O from Transparency, and Adaptive (and O)  \n<code>04 00 04 00 09 00 1A 0E 00 00 00</code> - Turns off O from Transparency, and Adaptive, and ANC (and O)  \n\n</details>\n\n> *i do hate apple for not hardcoding these, like there are literally only 4^2 - ${\\binom{4}{1}}$ - $\\binom{4}{2}$*\n\n# Head Tracking\n\n## Start Tracking\n\nThis packet initiates head tracking. When sent, the AirPods begin streaming head tracking data (e.g. orientation and acceleration) for live plotting and analysis.\n\n```plaintext\n04 00 04 00 17 00 00 00 10 00 10 00 08 A1 02 42 0B 08 0E 10 02 1A 05 01 40 9C 00 00\n```\n\n## Stop Tracking\n\nThis packet stops the head tracking data stream.\n\n```plaintext\n04 00 04 00 17 00 00 00 10 00 11 00 08 7E 10 02 42 0B 08 4E 10 02 1A 05 01 00 00 00 00\n```\n## Received Head Tracking Sensor Data\n\nOnce tracking is active, the AirPods stream sensor packets with the following common structure:\n  \n| Field                    | Offset | Length (bytes) |\n|--------------------------|--------|----------------|\n| orientation 1            | 43     | 2              |\n| orientation 2            | 45     | 2              |\n| orientation 3            | 47     | 2              |\n| Horizontal Acceleration  | 51     | 2              |\n| Vertical Acceleration    | 53     | 2              |\n\n# LICENSE\n\nLibrePods - AirPods liberated from Apple\u2019s ecosystem\nCopyright (C) 2025 LibrePods contributors\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU Affero General Public License as published\nby the Free Software Foundation, either version 3 of the License.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Affero General Public License for more details.\n\nYou should have received a copy of the GNU Affero General Public License\nalong with this program. If not, see <https://www.gnu.org/licenses/>.\n"
        },
        {
          "name": "README.txt",
          "ext": ".txt",
          "size": 1040,
          "preview": "\nlibrepods \u2014 settings fix\n\nWhat this zip contains\n----------------------\n- android/settings.gradle.kts   (Kotlin DSL \u2014 single version-catalog 'from' call)\n- README.txt\n\nWhat you need to do\n-------------------\n1) Ensure you **remove android/settings.gradle** (the Groovy DSL one).\n   Gradle must see only ONE settings file, otherwise the version catalog\n   will be imported twice and you'll get the: \n     \"you can only call the 'from' method a single time\" error.\n\n2) Place settings.gradle.kts from this zip at: android/settings.gradle.kts\n   (replace the existing file if present).\n\n3) Clean caches and rebuild:\n     On local:\n       - Delete: .gradle/ and android/.gradle/ folders (optional but helpful)\n       - Run:     ./gradlew --no-build-cache clean :app:assembleDebug\n     On GitHub Actions:\n       - Caches will refresh automatically; no extra changes needed.\n\nNotes\n-----\n- Your libs.versions.toml should remain at: android/gradle/libs.versions.toml\n- If you keep only the Kotlin DSL settings file, this error should be gone.\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "ext": ".md",
          "size": 3431,
          "preview": "# Welcome to LibrePods contributing guide <!-- omit in toc -->\n\nThank you for considering a contribution to LibrePods! Your support helps bring Apple-exclusive AirPods features to Linux and Android.\n\nRead our [Code of Conduct](./CODE_OF_CONDUCT.md) to keep our community approachable and respectful.\n\nThis guide provides an overview of the contribution workflow, from opening an issue to creating and reviewing a pull request (PR).\n\n## New contributor guide\n\nTo get an overview of the project, read the [README](./README.md). Here are some resources to help you get started with open-source contributions:\n\n- [Finding ways to contribute to open source on GitHub](https://docs.github.com/en/get-started/exploring-projects-on-github/finding-ways-to-contribute-to-open-source-on-github)\n- [Set up Git](https://docs.github.com/en/get-started/getting-started-with-git/set-up-git)\n- [GitHub flow](https://docs.github.com/en/get-started/using-github/github-flow)\n- [Collaborating with pull requests](https://docs.github.com/en/github/collaborating-with-pull-requests)\n\n## Getting started\n\nTo navigate our codebase with confidence, see the [README](./README.md) for setup instructions and usage details. We accept various types of contributions, which don\u2019t always require writing code (like translations).\n\nTo develop for the Android App, Android Studio is the preferred IDE. And you can use any IDE for the linux program, it is just python!\n\n### Issues\n\n#### Create a new issue\n\nIf you find a bug or want to suggest a feature, check if an issue already exists by searching through our [existing issues](https://github.com/kavishdevar/librepods/issues). If no relevant issue exists, open a new one and fill in the details.\n\n#### Solve an issue\n\nBrowse our [issues list](https://github.com/kavishdevar/librepods/issues) to find an interesting issue to work on. Use labels to filter issues and pick one that matches your expertise. If you\u2019d like to work on an issue, open a PR with your solution.\n\n### Make Changes\n\n#### Make changes locally\n\n1. Fork the repository and clone it to your local environment.\n```\ngit clone https://github.com/kavishdevar/librepods.git\ncd AirPods-Like-Normal\n```\n2. Create a working branch to start your changes.\n```\ngit checkout -b your-feature-branch\n```\n3. Make your changes, following the existing style and structure.\n\n4. Test your changes to ensure they work as expected and do not introduce new issues.\n\n### Commit your changes\n\nCommit your changes with a descriptive message.\n\n### Pull Request\n\nWhen your changes are ready, create a pull request (PR):\n- Fill out the PR template to help reviewers understand your changes.\n- If your PR is related to an issue, don\u2019t forget to [link your PR to it](https://docs.github.com/en/issues/tracking-your-work-with-issues/linking-a-pull-request-to-an-issue).\n- Enable the checkbox to allow maintainers to edit your PR, so any required changes can be merged easily.\n\nOnce your PR is open, a team member will review it. They may ask questions or request additional information.\n\n- If changes are requested, apply them in your fork and commit them to the PR branch.\n- Mark conversations as resolved as you apply feedback.\n- For merge conflicts, follow this [git tutorial](https://github.com/skills/resolve-merge-conflicts) to resolve them.\n\n### Your PR is merged!\n\nCongratulations! :tada: Once merged, your contributions will be publicly available in LibrePods."
        },
        {
          "name": "linux.txt.txt",
          "ext": ".txt",
          "size": 572,
          "preview": "sudo apt update\nsudo apt install -y build-essential cmake ninja-build pkg-config libdbus-1-dev libbluetooth-dev\ncmake -S . -B build -G Ninja -DCMAKE_BUILD_TYPE=Release\ncmake --build build --parallel\nsudo cmake --install build --prefix /usr/local\n\n\n\n---\n\n\u2705 With these files in place, you can build on **Windows** or **Linux**, and your app will show **all current AirPods models** correctly and gracefully handle future ones.\n\nDo you want me to also draft a **main.cpp sample** that shows how to call `ble_read_characteristic` + `ModelName` together (to test end-to-end)?"
        },
        {
          "name": "tools - Shortcut.lnk",
          "ext": ".lnk",
          "size": 1127
        },
        {
          "name": "intall.txt",
          "ext": ".txt",
          "size": 478,
          "preview": "Windows (VS2022):\n\ngit clone https://github.com/microsoft/vcpkg .vcpkg\n.\\.vcpkg\\bootstrap-vcpkg.bat\ncmake --preset win64-release\ncmake --build --preset win64-release-build --parallel\ncmake --install build --prefix build\\out\n\nLinux:\n\nsudo apt update\nsudo apt install -y build-essential cmake ninja-build pkg-config libdbus-1-dev libbluetooth-dev\ncmake -S . -B build -G Ninja -DCMAKE_BUILD_TYPE=Release\ncmake --build build --parallel\nsudo cmake --install build --prefix /usr/local"
        },
        {
          "name": "FUNDING.yml",
          "ext": ".yml",
          "size": 20,
          "preview": "github: kavishdevar\n"
        },
        {
          "name": "update.json",
          "ext": ".json",
          "size": 241,
          "preview": "{\n  \"version\": \"v0.0.3\",\n  \"versionCode\": 3,\n  \"zipUrl\": \"https://github.com/kavishdevar/librepods/releases/download/v0.0.3/btl2capfix-v0.0.3.zip\",\n  \"changelog\": \"https://raw.githubusercontent.com/kavishdevar/librepods/main/CHANGELOG.md\"\n}\n"
        },
        {
          "name": ".gitattributes",
          "ext": "",
          "size": 66
        },
        {
          "name": "pr_body.md",
          "ext": ".md",
          "size": 317,
          "preview": "### AirysDark-AI: detector results\n\n**Detected build types:**\n- android\n- linux\n- cmake\n\n**Next steps:**\n1. Edit `.github/workflows/AirysDark-AI_prob.yml` and set **env.TARGET** (e.g. `android`, `linux`, `cmake`).\n2. Merge this PR.\n3. Manually run **AirysDark-AI - Probe (LLM builds workflow)** from the Actions tab.\n"
        },
        {
          "name": ".gitignore",
          "ext": "",
          "size": 11871
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "ext": ".md",
          "size": 5223,
          "preview": "# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nWe as members, contributors, and leaders pledge to make participation in our\ncommunity a harassment-free experience for everyone, regardless of age, body\nsize, visible or invisible disability, ethnicity, sex characteristics, gender\nidentity and expression, level of experience, education, socio-economic status,\nnationality, personal appearance, race, religion, or sexual identity\nand orientation.\n\nWe pledge to act and interact in ways that contribute to an open, welcoming,\ndiverse, inclusive, and healthy community.\n\n## Our Standards\n\nExamples of behavior that contributes to a positive environment for our\ncommunity include:\n\n* Demonstrating empathy and kindness toward other people\n* Being respectful of differing opinions, viewpoints, and experiences\n* Giving and gracefully accepting constructive feedback\n* Accepting responsibility and apologizing to those affected by our mistakes,\n  and learning from the experience\n* Focusing on what is best not just for us as individuals, but for the\n  overall community\n\nExamples of unacceptable behavior include:\n\n* The use of sexualized language or imagery, and sexual attention or\n  advances of any kind\n* Trolling, insulting or derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or email\n  address, without their explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n  professional setting\n\n## Enforcement Responsibilities\n\nCommunity leaders are responsible for clarifying and enforcing our standards of\nacceptable behavior and will take appropriate and fair corrective action in\nresponse to any behavior that they deem inappropriate, threatening, offensive,\nor harmful.\n\nCommunity leaders have the right and responsibility to remove, edit, or reject\ncomments, commits, code, wiki edits, issues, and other contributions that are\nnot aligned to this Code of Conduct, and will communicate reasons for moderation\ndecisions when appropriate.\n\n## Scope\n\nThis Code of Conduct applies within all community spaces, and also applies when\nan individual is officially representing the community in public spaces.\nExamples of representing our community include using an official e-mail address,\nposting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported to the community leaders responsible for enforcement at\nreport@kavishdevar.me.\nAll complaints will be reviewed and investigated promptly and fairly.\n\nAll community leaders are obligated to respect the privacy and security of the\nreporter of any incident.\n\n## Enforcement Guidelines\n\nCommunity leaders will follow these Community Impact Guidelines in determining\nthe consequences for any action they deem in violation of this Code of Conduct:\n\n### 1. Correction\n\n**Community Impact**: Use of inappropriate language or other behavior deemed\nunprofessional or unwelcome in the community.\n\n**Consequence**: A private, written warning from community leaders, providing\nclarity around the nature of the violation and an explanation of why the\nbehavior was inappropriate. A public apology may be requested.\n\n### 2. Warning\n\n**Community Impact**: A violation through a single incident or series\nof actions.\n\n**Consequence**: A warning with consequences for continued behavior. No\ninteraction with the people involved, including unsolicited interaction with\nthose enforcing the Code of Conduct, for a specified period of time. This\nincludes avoiding interactions in community spaces as well as external channels\nlike social media. Violating these terms may lead to a temporary or\npermanent ban.\n\n### 3. Temporary Ban\n\n**Community Impact**: A serious violation of community standards, including\nsustained inappropriate behavior.\n\n**Consequence**: A temporary ban from any sort of interaction or public\ncommunication with the community for a specified period of time. No public or\nprivate interaction with the people involved, including unsolicited interaction\nwith those enforcing the Code of Conduct, is allowed during this period.\nViolating these terms may lead to a permanent ban.\n\n### 4. Permanent Ban\n\n**Community Impact**: Demonstrating a pattern of violation of community\nstandards, including sustained inappropriate behavior,  harassment of an\nindividual, or aggression toward or disparagement of classes of individuals.\n\n**Consequence**: A permanent ban from any sort of public interaction within\nthe community.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage],\nversion 2.0, available at\nhttps://www.contributor-covenant.org/version/2/0/code_of_conduct.html.\n\nCommunity Impact Guidelines were inspired by [Mozilla's code of conduct\nenforcement ladder](https://github.com/mozilla/diversity).\n\n[homepage]: https://www.contributor-covenant.org\n\nFor answers to common questions about this code of conduct, see the FAQ at\nhttps://www.contributor-covenant.org/faq. Translations are available at\nhttps://www.contributor-covenant.org/translations.\n"
        },
        {
          "name": "clean_gradle_duplicates.sh",
          "ext": ".sh",
          "size": 1070
        },
        {
          "name": "update_nonpatch.json",
          "ext": ".json",
          "size": 255,
          "preview": "{\n  \"version\": \"v0.1.0-rc.4\",\n  \"versionCode\": 3,\n  \"zipUrl\": \"https://github.com/kavishdevar/librepods/releases/download/v0.1.0-rc.4/LibrePods-v0.1.0-rc.4.zip\",\n  \"changelog\": \"https://raw.githubusercontent.com/kavishdevar/librepods/main/CHANGELOG.md\"\n}\n"
        },
        {
          "name": "CHANGELOG.md",
          "ext": ".md",
          "size": 99,
          "preview": "## LibrePods root module changelog\n_[See here](https://github.com/kavishdevar/librepods/releases)_\n"
        },
        {
          "name": "Proximity Pairing Message.md",
          "ext": ".md",
          "size": 6537,
          "preview": "# Bluetooth Low Energy (BLE) - Apple Proximity Pairing Message\n\nThis document describes how the AirPods BLE \"Proximity Pairing Message\" is parsed and interpreted in the application. This message is broadcast by Apple devices (such as AirPods) and contains key information about the device's state, battery, and other properties.\n\n## Overview\n\nWhen scanning for BLE devices, the application looks for manufacturer data with Apple's ID (`0x004C`). If the data starts with `0x07`, it is identified as a Proximity Pairing Message. The message contains various fields, each representing a specific property of the AirPods.\n\n## Proximity Pairing Message Structure\n\n| Byte Index | Field Name              | Description                                             | Example Value(s)         |\n|------------|-------------------------|---------------------------------------------------------|--------------------------|\n| 0          | Prefix                  | Message type (should be `0x07` for proximity pairing)   | `0x07`                   |\n| 1          | Length                  | Length of the message                                   | `0x12`                   |\n| 2          | Pairing Mode            | `0x01` = Paired, `0x00` = Pairing mode                 | `0x01`, `0x00`           |\n| 3-4        | Device Model            | Big-endian: [3]=high, [4]=low                          | `0x0E20` (AirPods Pro)   |\n| 5          | Status                  | Bitfield, see below                                    | `0x62`                   |\n| 6          | Pods Battery Byte       | Nibbles for left/right pod battery                     | `0xA7`                   |\n| 7          | Flags & Case Battery    | Upper nibble: case battery, lower: flags               | `0xB3`                   |\n| 8          | Lid Indicator           | Bits for lid state and open counter                    | `0x09`                   |\n| 9          | Device Color            | Color code                                             | `0x02`                   |\n| 10         | Connection State        | Enum, see below                                        | `0x04`                   |\n| 11-26      | Encrypted Payload       | 16 bytes, not parsed                                   |                          |\n\n## Field Details\n\n### Device Model\n\n| Value (hex) | Model Name                |\n|-------------|--------------------------|\n| 0x0220      | AirPods 1st Gen          |\n| 0x0F20      | AirPods 2nd Gen          |\n| 0x1320      | AirPods 3rd Gen          |\n| 0x1920      | AirPods 4th Gen          |\n| 0x1B20      | AirPods 4th Gen (ANC)    |\n| 0x0A20      | AirPods Max              |\n| 0x1F20      | AirPods Max (USB-C)      |\n| 0x0E20      | AirPods Pro              |\n| 0x1420      | AirPods Pro 2nd Gen      |\n| 0x2420      | AirPods Pro 2nd Gen (USB-C) |\n\n### Status Byte (Bitfield)\n\n| Bit | Meaning                        | Value if Set |\n|-----|--------------------------------|-------------|\n| 0   | Right Pod In Ear (XOR logic)   | true        |\n| 1   | Right Pod In Ear (XOR logic)   | true        |\n| 2   | Both Pods In Case              | true        |\n| 3   | Left Pod In Ear (XOR logic)    | true        |\n| 4   | One Pod In Case                | true        |\n| 5   | Primary Pod (1=Left, 0=Right)  | true/false  |\n| 6   | This Pod In Case               | true        |\n\n### Ear Detection Logic\n\nThe in-ear detection uses XOR logic based on:\n- Whether the right pod is primary (`areValuesFlipped`)\n- Whether this pod is in the case (`isThisPodInTheCase`)\n\n```cpp\nbool xorFactor = areValuesFlipped ^ deviceInfo.isThisPodInTheCase;\ndeviceInfo.isLeftPodInEar = xorFactor ? (status & 0x08) != 0 : (status & 0x02) != 0;  // Bit 3 or 1\ndeviceInfo.isRightPodInEar = xorFactor ? (status & 0x02) != 0 : (status & 0x08) != 0; // Bit 1 or 3\n```\n\n### Primary Pod\n\nDetermined by bit 5 of the status byte:\n- `1` = Left pod is primary\n- `0` = Right pod is primary\n\nThis affects:\n1. Battery level interpretation (which nibble corresponds to which pod)\n2. Microphone assignment\n3. Ear detection logic\n\n### Microphone Status\n\nThe active microphone is determined by:\n```cpp\ndeviceInfo.isLeftPodMicrophone = primaryLeft ^ deviceInfo.isThisPodInTheCase;\ndeviceInfo.isRightPodMicrophone = !primaryLeft ^ deviceInfo.isThisPodInTheCase;\n```\n\n### Pods Battery Byte\n\n- Upper nibble: one pod battery (depends on primary)\n- Lower nibble: other pod battery\n\n| Value | Meaning         |\n|-------|----------------|\n| 0x0-0x9 | 0-90% (x10)  |\n| 0xA-0xE | 100%         |\n| 0xF     | Not available|\n\n### Flags & Case Battery Byte\n\n- Upper nibble: case battery (same encoding as pods)\n- Lower nibble: flags\n\n#### Flags (Lower Nibble)\n\n| Bit | Meaning                  |\n|-----|--------------------------|\n| 0   | Right Pod Charging (XOR) |\n| 1   | Left Pod Charging (XOR)  |\n| 2   | Case Charging            |\n\n### Lid Indicator\n\n| Bits | Meaning                |\n|------|------------------------|\n| 0-2  | Lid Open Counter       |\n| 3    | Lid State (0=Open, 1=Closed) |\n\n### Device Color\n\n| Value | Color        |\n|-------|-------------|\n| 0x00  | White       |\n| 0x01  | Black       |\n| 0x02  | Red         |\n| 0x03  | Blue        |\n| 0x04  | Pink        |\n| 0x05  | Gray        |\n| 0x06  | Silver      |\n| 0x07  | Gold        |\n| 0x08  | Rose Gold   |\n| 0x09  | Space Gray  |\n| 0x0A  | Dark Blue   |\n| 0x0B  | Light Blue  |\n| 0x0C  | Yellow      |\n| 0x0D+ | Unknown     |\n\n### Connection State\n\n| Value | State         |\n|-------|--------------|\n| 0x00  | Disconnected |\n| 0x04  | Idle         |\n| 0x05  | Music        |\n| 0x06  | Call         |\n| 0x07  | Ringing      |\n| 0x09  | Hanging Up   |\n| 0xFF  | Unknown      |\n\n## Example Message\n\n| Byte Index | Example Value | Description                |\n|------------|--------------|----------------------------|\n| 0          | 0x07         | Proximity Pairing Message  |\n| 1          | 0x12         | Length                     |\n| 2          | 0x01         | Paired                     |\n| 3-4        | 0x0E 0x20    | AirPods Pro                |\n| 5          | 0x62         | Status                     |\n| 6          | 0xA7         | Pods Battery               |\n| 7          | 0xB3         | Flags & Case Battery       |\n| 8          | 0x09         | Lid Indicator              |\n| 9          | 0x02         | Device Color               |\n| 10         | 0x04         | Connection State (Idle)    |\n\n---\n\nFor further details, see [`BleManager`](linux/ble/blemanager.cpp) and [`BleScanner`](linux/ble/blescanner.cpp)."
        }
      ]
    },
    {
      "dir": "imgs",
      "files": [
        {
          "name": "banner.png",
          "ext": ".png",
          "size": 203886
        }
      ]
    },
    {
      "dir": "linux",
      "files": [
        {
          "name": "README.md",
          "ext": ".md",
          "size": 1887,
          "preview": "# LibrePods Linux\n\nA native Linux application to control your AirPods, with support for:\n\n- Noise Control modes (Off, Transparency, Adaptive, Noise Cancellation)\n- Conversational Awareness\n- Battery monitoring\n- Auto play/pause on ear detection\n- Seamless handoff between phone and PC\n\n## Prerequisites\n\n1. Your phone's Bluetooth MAC address (can be found in Settings > About Device)\n2. Qt6 packages\n\n   ```bash\n   # For Arch Linux / EndeavourOS\n   sudo pacman -S qt6-base qt6-connectivity qt6-multimedia-ffmpeg qt6-multimedia\n\n   # For Debian\n   sudo apt-get install qt6-base-dev qt6-declarative-dev qt6-connectivity-dev qt6-multimedia-dev \\\n        qml6-module-qtquick-controls qml6-module-qtqml-workerscript qml6-module-qtquick-templates \\\n        qml6-module-qtquick-window qml6-module-qtquick-layouts\n\n    # For Fedora\n    sudo dnf install qt6-qtbase-devel qt6-qtconnectivity-devel \\\n        qt6-qtmultimedia-devel qt6-qtdeclarative-devel\n   ```\n3. OpenSSL development headers\n\n    ```bash\n    # On Arch Linux / EndevaourOS, these are included in the OpenSSL package, so you might already have them installed.\n    sudo pacman -S openssl\n    \n    # For Debian / Ubuntu\n    sudo apt-get install libssl-dev\n    \n    # For Fedora\n    sudo dnf install openssl-devel\n    ```\n## Setup\n\n1. Set the `PHONE_MAC_ADDRESS` environment variable to your phone's Bluetooth MAC address by running the following:\n\n   ```bash\n   export PHONE_MAC_ADDRESS=\"XX:XX:XX:XX:XX:XX\"  # Replace with your phone's MAC\n   ```\n\n2. Build the application:\n\n   ```bash\n   mkdir build\n   cd build\n   cmake ..\n   make -j $(nproc)\n   ```\n\n3. Run the application:\n\n   ```bash\n   ./librepods\n   ```\n\n## Usage\n\n- Left-click the tray icon to view battery status\n- Right-click to access the control menu:\n  - Toggle Conversational Awareness\n  - Switch between noise control modes\n  - View battery levels\n  - Control playback\n"
        },
        {
          "name": "BasicControlCommand.hpp",
          "ext": ".hpp",
          "size": 2221,
          "preview": "#include <QByteArray>\n\n// Control Command Header\nnamespace ControlCommand\n{\n    static const QByteArray HEADER = QByteArray::fromHex(\"040004000900\");\n\n    // Helper function to create control command packets\n    static QByteArray createCommand(quint8 identifier, quint8 data1 = 0x00, quint8 data2 = 0x00,\n                                    quint8 data3 = 0x00, quint8 data4 = 0x00)\n    {\n        QByteArray packet = HEADER;\n        packet.append(static_cast<char>(identifier));\n        packet.append(static_cast<char>(data1));\n        packet.append(static_cast<char>(data2));\n        packet.append(static_cast<char>(data3));\n        packet.append(static_cast<char>(data4));\n        return packet;\n    }\n\n    inline std::optional<char> parseActive(const QByteArray &data)\n    {\n        if (!data.startsWith(ControlCommand::HEADER))\n            return std::nullopt;\n\n        return static_cast<quint8>(data.at(7));\n    }\n}\n\ntemplate <quint8 CommandId>\nstruct BasicControlCommand\n{\n    static constexpr quint8 ID = CommandId;\n    static const QByteArray HEADER;\n\n    static const QByteArray ENABLED;\n    static const QByteArray DISABLED;\n\n    static QByteArray create(quint8 data1 = 0x00, quint8 data2 = 0x00,\n                             quint8 data3 = 0x00, quint8 data4 = 0x00)\n    {\n        return ControlCommand::createCommand(ID, data1, data2, data3, data4);\n    }\n\n    // Basically returns the byte at the index 7\n    static std::optional<bool> parseState(const QByteArray &data)\n    {\n        switch (ControlCommand::parseActive(data).value_or(0x00))\n        {\n        case 0x01: // Enabled\n            return true;\n        case 0x02: // Disabled\n            return false;\n        default:\n            return std::nullopt;\n        }\n    }\n\n    static std::optional<char> getValue(const QByteArray &data)\n    {\n        return ControlCommand::parseActive(data);\n    }\n};\n\ntemplate <quint8 CommandId>\nconst QByteArray BasicControlCommand<CommandId>::HEADER = ControlCommand::HEADER + static_cast<char>(CommandId);\n\ntemplate <quint8 CommandId>\nconst QByteArray BasicControlCommand<CommandId>::ENABLED = create(0x01);\n\ntemplate <quint8 CommandId>\nconst QByteArray BasicControlCommand<CommandId>::DISABLED = create(0x02);"
        },
        {
          "name": "KeysQRDialog.qml",
          "ext": ".qml",
          "size": 2060
        },
        {
          "name": "logger.h",
          "ext": ".h",
          "size": 406,
          "preview": "#pragma once\n\n#include <QDebug>\n#include <QLoggingCategory>\n\nQ_DECLARE_LOGGING_CATEGORY(Librepods)\n\n#define LOG_INFO(msg) qCInfo(Librepods) << \"\\033[32m\" << msg << \"\\033[0m\"\n#define LOG_WARN(msg) qCWarning(Librepods) << \"\\033[33m\" << msg << \"\\033[0m\"\n#define LOG_ERROR(msg) qCCritical(Librepods) << \"\\033[31m\" << msg << \"\\033[0m\"\n#define LOG_DEBUG(msg) qCDebug(Librepods) << \"\\033[34m\" << msg << \"\\033[0m\"\n"
        },
        {
          "name": "BatteryIndicator.qml",
          "ext": ".qml",
          "size": 5452
        },
        {
          "name": "eardetection.hpp",
          "ext": ".hpp",
          "size": 2893,
          "preview": "#pragma once\n\n#include <QObject>\n#include <QByteArray>\n#include <QPair>\n#include \"logger.h\"\n\nclass EarDetection : public QObject\n{\n    Q_OBJECT\n\npublic:\n    enum class EarDetectionStatus\n    {\n        InEar,\n        NotInEar,\n        InCase,\n        Disconnected,\n    };\n    Q_ENUM(EarDetectionStatus)\n\n    explicit EarDetection(QObject *parent = nullptr) : QObject(parent)\n    {\n        reset();\n    }\n\n    void reset()\n    {\n        primaryStatus = EarDetectionStatus::Disconnected;\n        secondaryStatus = EarDetectionStatus::Disconnected;\n        emit statusChanged();\n    }\n\n    bool parseData(const QByteArray &data)\n    {\n        if (data.size() < 2)\n        {\n            return false;\n        }\n\n        auto [newprimaryStatus, newsecondaryStatus] = parseStatusBytes(data);\n\n        primaryStatus = newprimaryStatus;\n        secondaryStatus = newsecondaryStatus;\n        LOG_DEBUG(\"Parsed Ear Detection Status: Primary - \" << primaryStatus\n                  << \", Secondary - \" << secondaryStatus);\n        emit statusChanged();\n\n        return true;\n    }\n    void overrideEarDetectionStatus(bool primaryInEar, bool secondaryInEar)\n    {\n        primaryStatus = primaryInEar ? EarDetectionStatus::InEar : EarDetectionStatus::NotInEar;\n        secondaryStatus = secondaryInEar ? EarDetectionStatus::InEar : EarDetectionStatus::NotInEar;\n        emit statusChanged();\n    }\n\n    bool isPrimaryInEar() const { return primaryStatus == EarDetectionStatus::InEar; }\n    bool isSecondaryInEar() const { return secondaryStatus == EarDetectionStatus::InEar; }\n    bool oneOrMorePodsInCase() const { return primaryStatus == EarDetectionStatus::InCase || secondaryStatus == EarDetectionStatus::InCase; }\n    bool oneOrMorePodsInEar() const { return isPrimaryInEar() || isSecondaryInEar(); }\n\n    EarDetectionStatus getprimaryStatus() const { return primaryStatus; }\n    EarDetectionStatus getsecondaryStatus() const { return secondaryStatus; }\n\nsignals:\n    void statusChanged();\n\nprivate:\n    QPair<EarDetectionStatus, EarDetectionStatus> parseStatusBytes(const QByteArray &data) const\n    {\n        quint8 primaryByte = static_cast<quint8>(data[6]);\n        quint8 secondaryByte = static_cast<quint8>(data[7]);\n\n        auto primaryStatus = parseStatusByte(primaryByte);\n        auto secondaryStatus = parseStatusByte(secondaryByte);\n\n        return qMakePair(primaryStatus, secondaryStatus);\n    }\n\n    EarDetectionStatus parseStatusByte(quint8 byte) const\n    {\n        if (byte == 0x00)\n            return EarDetectionStatus::InEar;\n        if (byte == 0x01)\n            return EarDetectionStatus::NotInEar;\n        if (byte == 0x02)\n            return EarDetectionStatus::InCase;\n        return EarDetectionStatus::Disconnected;\n    }\n\n    EarDetectionStatus primaryStatus = EarDetectionStatus::Disconnected;\n    EarDetectionStatus secondaryStatus = EarDetectionStatus::Disconnected;\n};"
        },
        {
          "name": "playerstatuswatcher.cpp",
          "ext": ".cpp",
          "size": 2935,
          "preview": "#include \"media/playerstatuswatcher.h\"\n#include <QDBusConnection>\n#include <QDBusPendingReply>\n#include <QVariantMap>\n#include <QDBusReply>\n\nPlayerStatusWatcher::PlayerStatusWatcher(const QString &playerService, QObject *parent)\n    : QObject(parent),\n      m_playerService(playerService),\n      m_iface(new QDBusInterface(playerService, \"/org/mpris/MediaPlayer2\",\n                                 \"org.mpris.MediaPlayer2.Player\", QDBusConnection::sessionBus(), this)),\n      m_serviceWatcher(new QDBusServiceWatcher(playerService, QDBusConnection::sessionBus(),\n                                               QDBusServiceWatcher::WatchForOwnerChange, this))\n{\n    // Register this object on the session bus to receive D-Bus messages\n    QDBusConnection::sessionBus().registerObject(\"/PlayerStatusWatcher\", this,\n                                               QDBusConnection::ExportAllSlots);\n\n    QDBusConnection::sessionBus().connect(\n        playerService, \"/org/mpris/MediaPlayer2\", \"org.freedesktop.DBus.Properties\",\n        \"PropertiesChanged\", this, SLOT(onPropertiesChanged(QString,QVariantMap,QStringList))\n    );\n    connect(m_serviceWatcher, &QDBusServiceWatcher::serviceOwnerChanged,\n            this, &PlayerStatusWatcher::onServiceOwnerChanged);\n    updateStatus();\n}\n\nvoid PlayerStatusWatcher::onPropertiesChanged(const QString &interface,\n                                              const QVariantMap &changed,\n                                              const QStringList &)\n{\n    // Get the service name of the sender\n    QString sender = message().service();\n    \n    // Skip if it's a KDE Connect player\n    if (sender.contains(\"kdeconnect\", Qt::CaseInsensitive)) {\n        return;\n    }\n\n    if (interface == \"org.mpris.MediaPlayer2.Player\" && changed.contains(\"PlaybackStatus\")) {\n        emit playbackStatusChanged(changed.value(\"PlaybackStatus\").toString());\n    }\n}\n\nvoid PlayerStatusWatcher::updateStatus() {\n    QVariant reply = m_iface->property(\"PlaybackStatus\");\n    if (reply.isValid()) {\n        emit playbackStatusChanged(reply.toString());\n    }\n}\n\nvoid PlayerStatusWatcher::onServiceOwnerChanged(const QString &name, const QString &, const QString &newOwner)\n{\n    if (name == m_playerService && newOwner.isEmpty()) {\n        emit playbackStatusChanged(\"\"); // player disappeared\n    } else if (name == m_playerService && !newOwner.isEmpty()) {\n        updateStatus(); // player appeared/reappeared\n    }\n}\n\nQString PlayerStatusWatcher::getCurrentPlaybackStatus(const QString &playerService)\n{\n    QDBusInterface iface(\n        playerService,\n        \"/org/mpris/MediaPlayer2\",\n        \"org.mpris.MediaPlayer2.Player\",\n        QDBusConnection::sessionBus());\n    QVariant reply = iface.property(\"PlaybackStatus\");\n    if (reply.isValid())\n    {\n        return reply.toString(); // \"Playing\", \"Paused\", \"Stopped\"\n    }\n    else\n    {\n        return QString(); // or handle error as needed\n    }\n}"
        },
        {
          "name": "CMakeLists.txt",
          "ext": ".txt",
          "size": 1801,
          "preview": "cmake_minimum_required(VERSION 3.16)\n\nproject(linux VERSION 0.1 LANGUAGES CXX)\n\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\nfind_package(Qt6 6.4 REQUIRED COMPONENTS Quick Widgets Bluetooth DBus)\nfind_package(OpenSSL REQUIRED)\n\nqt_standard_project_setup(REQUIRES 6.4)\n\nqt_add_executable(librepods\n    main.cpp\n    logger.h\n    media/mediacontroller.cpp\n    media/mediacontroller.h\n    airpods_packets.h\n    trayiconmanager.cpp\n    trayiconmanager.h\n    enums.h\n    battery.hpp\n    BluetoothMonitor.cpp\n    BluetoothMonitor.h\n    autostartmanager.hpp\n    BasicControlCommand.hpp\n    deviceinfo.hpp\n    ble/bleutils.cpp\n    ble/bleutils.h\n    ble/blemanager.cpp\n    ble/blemanager.h\n    thirdparty/QR-Code-generator/qrcodegen.cpp\n    thirdparty/QR-Code-generator/qrcodegen.hpp\n    QRCodeImageProvider.hpp\n    eardetection.hpp\n    media/playerstatuswatcher.cpp\n    media/playerstatuswatcher.h\n    systemsleepmonitor.hpp\n)\n\nqt_add_qml_module(librepods\n    URI linux\n    VERSION 1.0\n    QML_FILES\n        Main.qml\n        BatteryIndicator.qml\n        SegmentedControl.qml\n        PodColumn.qml\n        Icon.qml\n        KeysQRDialog.qml\n)\n\n# Add the resource file\nqt_add_resources(librepods \"resources\"\n    PREFIX \"/icons\"\n    FILES\n        assets/airpods.png\n        assets/pod.png\n        assets/pod_case.png\n        assets/pod3.png\n        assets/pod3_case.png\n        assets/pod4_case.png\n        assets/podpro.png\n        assets/podpro_case.png\n        assets/podmax.png\n        assets/fonts/SF-Symbols-6.ttf\n)\n\ntarget_link_libraries(librepods\n    PRIVATE Qt6::Quick Qt6::Widgets Qt6::Bluetooth Qt6::DBus OpenSSL::SSL OpenSSL::Crypto\n)\n\ninclude(GNUInstallDirs)\ninstall(TARGETS librepods\n    BUNDLE DESTINATION .\n    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}\n    RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}\n)\n"
        },
        {
          "name": "trayiconmanager.cpp",
          "ext": ".cpp",
          "size": 4458,
          "preview": "#include \"trayiconmanager.h\"\n\n#include <QSystemTrayIcon>\n#include <QMenu>\n#include <QAction>\n#include <QApplication>\n#include <QPainter>\n#include <QFont>\n#include <QColor>\n#include <QActionGroup>\n\nusing namespace AirpodsTrayApp::Enums;\n\nTrayIconManager::TrayIconManager(QObject *parent) : QObject(parent)\n{\n    // Initialize tray icon\n    trayIcon = new QSystemTrayIcon(QIcon(\":/icons/assets/airpods.png\"), this);\n    trayMenu = new QMenu();\n\n    // Setup basic menu actions\n    setupMenuActions();\n\n    // Connect signals\n    trayIcon->setContextMenu(trayMenu);\n    connect(trayIcon, &QSystemTrayIcon::activated, this, &TrayIconManager::onTrayIconActivated);\n\n    trayIcon->show();\n}\n\nvoid TrayIconManager::showNotification(const QString &title, const QString &message)\n{\n    if (!m_notificationsEnabled)\n        return;\n    trayIcon->showMessage(title, message, QSystemTrayIcon::Information, 3000);\n}\n\nvoid TrayIconManager::TrayIconManager::updateBatteryStatus(const QString &status)\n{\n    trayIcon->setToolTip(\"Battery Status: \" + status);\n    updateIconFromBattery(status);\n}\n\nvoid TrayIconManager::updateNoiseControlState(NoiseControlMode mode)\n{\n    QList<QAction *> actions = noiseControlGroup->actions();\n    for (QAction *action : actions)\n    {\n        action->setChecked(action->data().toInt() == (int)mode);\n    }\n}\n\nvoid TrayIconManager::updateConversationalAwareness(bool enabled)\n{\n    caToggleAction->setChecked(enabled);\n}\n\nvoid TrayIconManager::setupMenuActions()\n{\n    // Open action\n    QAction *openAction = new QAction(\"Open\", trayMenu);\n    trayMenu->addAction(openAction);\n    connect(openAction, &QAction::triggered, qApp, [this](){emit openApp();});\n\n    // Settings Menu\n\n    QAction *settingsMenu = new QAction(\"Settings\", trayMenu);\n    trayMenu->addAction(settingsMenu);\n    connect(settingsMenu, &QAction::triggered, qApp, [this](){emit openSettings();});\n\n    trayMenu->addSeparator();\n\n    // Conversational Awareness Toggle\n    caToggleAction = new QAction(\"Toggle Conversational Awareness\", trayMenu);\n    caToggleAction->setCheckable(true);\n    trayMenu->addAction(caToggleAction);\n    connect(caToggleAction, &QAction::triggered, this, [this](bool checked)\n            { emit conversationalAwarenessToggled(checked); });\n\n    trayMenu->addSeparator();\n\n    // Noise Control Options\n    noiseControlGroup = new QActionGroup(trayMenu);\n    const QPair<QString, NoiseControlMode> noiseOptions[] = {\n        {\"Adaptive\", NoiseControlMode::Adaptive},\n        {\"Transparency\", NoiseControlMode::Transparency},\n        {\"Noise Cancellation\", NoiseControlMode::NoiseCancellation},\n        {\"Off\", NoiseControlMode::Off}};\n\n    for (auto option : noiseOptions)\n    {\n        QAction *action = new QAction(option.first, trayMenu);\n        action->setCheckable(true);\n        action->setData((int)option.second);\n        noiseControlGroup->addAction(action);\n        trayMenu->addAction(action);\n        connect(action, &QAction::triggered, this, [this, mode = option.second]()\n                { emit noiseControlChanged(mode); });\n    }\n\n    trayMenu->addSeparator();\n\n    // Quit action\n    QAction *quitAction = new QAction(\"Quit\", trayMenu);\n    trayMenu->addAction(quitAction);\n    connect(quitAction, &QAction::triggered, qApp, &QApplication::quit);\n}\n\nvoid TrayIconManager::updateIconFromBattery(const QString &status)\n{\n    int leftLevel = 0;\n    int rightLevel = 0;\n\n    if (!status.isEmpty())\n    {\n        // Parse the battery status string\n        QStringList parts = status.split(\", \");\n        if (parts.size() >= 2)\n        {\n            leftLevel = parts[0].split(\": \")[1].replace(\"%\", \"\").toInt();\n            rightLevel = parts[1].split(\": \")[1].replace(\"%\", \"\").toInt();\n        }\n    }\n    \n    int minLevel = (leftLevel == 0) ? rightLevel : (rightLevel == 0) ? leftLevel\n                                                                     : qMin(leftLevel, rightLevel);\n\n    QPixmap pixmap(32, 32);\n    pixmap.fill(Qt::transparent);\n    QPainter painter(&pixmap);\n    painter.setPen(QApplication::palette().color(QPalette::WindowText));\n    painter.setFont(QFont(\"Arial\", 12, QFont::Bold));\n    painter.drawText(pixmap.rect(), Qt::AlignCenter, QString::number(minLevel) + \"%\");\n    painter.end();\n\n    trayIcon->setIcon(QIcon(pixmap));\n}\n\nvoid TrayIconManager::onTrayIconActivated(QSystemTrayIcon::ActivationReason reason)\n{\n    if (reason == QSystemTrayIcon::Trigger)\n    {\n        emit trayClicked();\n    }\n}"
        },
        {
          "name": "trayiconmanager.h",
          "ext": ".h",
          "size": 1676,
          "preview": "#include <QObject>\n#include <QSystemTrayIcon>\n\n#include \"enums.h\"\n\nclass QMenu;\nclass QAction;\nclass QActionGroup;\n\nclass TrayIconManager : public QObject\n{\n    Q_OBJECT\n    Q_PROPERTY(bool notificationsEnabled READ notificationsEnabled WRITE setNotificationsEnabled NOTIFY notificationsEnabledChanged)\n\npublic:\n    explicit TrayIconManager(QObject *parent = nullptr);\n\n    void updateBatteryStatus(const QString &status);\n\n    void updateNoiseControlState(AirpodsTrayApp::Enums::NoiseControlMode);\n\n    void updateConversationalAwareness(bool enabled);\n\n    void showNotification(const QString &title, const QString &message);\n\n    bool notificationsEnabled() const { return m_notificationsEnabled; }\n    void setNotificationsEnabled(bool enabled)\n    {\n        if (m_notificationsEnabled != enabled)\n        {\n            m_notificationsEnabled = enabled;\n            emit notificationsEnabledChanged(enabled);\n        }\n    }\n\n    void resetTrayIcon()\n    {\n        trayIcon->setIcon(QIcon(\":/icons/assets/airpods.png\"));\n        trayIcon->setToolTip(\"\");\n    }\n\nsignals:\n    void notificationsEnabledChanged(bool enabled);\n\nprivate slots:\n    void onTrayIconActivated(QSystemTrayIcon::ActivationReason reason);\n\nprivate:\n    QSystemTrayIcon *trayIcon;\n    QMenu *trayMenu;\n    QAction *caToggleAction;\n    QActionGroup *noiseControlGroup;\n    bool m_notificationsEnabled = true;\n\n    void setupMenuActions();\n\n    void updateIconFromBattery(const QString &status);\n\nsignals:\n    void trayClicked();\n    void noiseControlChanged(AirpodsTrayApp::Enums::NoiseControlMode);\n    void conversationalAwarenessToggled(bool enabled);\n    void openApp();\n    void openSettings();\n};"
        },
        {
          "name": "enums.h",
          "ext": ".h",
          "size": 3407,
          "preview": "#pragma once\n\n#include <QMetaType>\n#include <QHash>\n\nnamespace AirpodsTrayApp\n{\n    namespace Enums\n    {\n        Q_NAMESPACE\n\n        enum class NoiseControlMode : quint8\n        {\n            Off = 0,\n            NoiseCancellation = 1,\n            Transparency = 2,\n            Adaptive = 3,\n\n            MinValue = Off,\n            MaxValue = Adaptive,\n        };\n        Q_ENUM_NS(NoiseControlMode)\n\n        enum class AirPodsModel\n        {\n            Unknown,\n            AirPods1,\n            AirPods2,\n            AirPods3,\n            AirPodsPro,\n            AirPodsPro2Lightning,\n            AirPodsPro2USBC,\n            AirPodsMaxLightning,\n            AirPodsMaxUSBC,\n            AirPods4,\n            AirPods4ANC\n        };\n        Q_ENUM_NS(AirPodsModel)\n\n        // Get model enum from model number\n        inline AirPodsModel parseModelNumber(const QString &modelNumber)\n        {\n            // Model numbers taken from https://support.apple.com/en-us/109525\n            QHash<QString, AirPodsModel> modelNumberMap = {\n                {\"A1523\", AirPodsModel::AirPods1},\n                {\"A1722\", AirPodsModel::AirPods1},\n                {\"A2032\", AirPodsModel::AirPods2},\n                {\"A2031\", AirPodsModel::AirPods2},\n                {\"A2084\", AirPodsModel::AirPodsPro},\n                {\"A2083\", AirPodsModel::AirPodsPro},\n                {\"A2096\", AirPodsModel::AirPodsMaxLightning},\n                {\"A3184\", AirPodsModel::AirPodsMaxUSBC},\n                {\"A2565\", AirPodsModel::AirPods3},\n                {\"A2564\", AirPodsModel::AirPods3},\n                {\"A3047\", AirPodsModel::AirPodsPro2USBC},\n                {\"A3048\", AirPodsModel::AirPodsPro2USBC},\n                {\"A3049\", AirPodsModel::AirPodsPro2USBC},\n                {\"A2931\", AirPodsModel::AirPodsPro2Lightning},\n                {\"A2699\", AirPodsModel::AirPodsPro2Lightning},\n                {\"A2698\", AirPodsModel::AirPodsPro2Lightning},\n                {\"A3053\", AirPodsModel::AirPods4},\n                {\"A3050\", AirPodsModel::AirPods4},\n                {\"A3054\", AirPodsModel::AirPods4},\n                {\"A3056\", AirPodsModel::AirPods4ANC},\n                {\"A3055\", AirPodsModel::AirPods4ANC},\n                {\"A3057\", AirPodsModel::AirPods4ANC}};\n\n            return modelNumberMap.value(modelNumber, AirPodsModel::Unknown);\n        }\n\n        // Return icons based on model\n        inline QPair<QString, QString> getModelIcon(AirPodsModel model) {\n            switch (model) {\n                case AirPodsModel::AirPods1:\n                case AirPodsModel::AirPods2:\n                    return {\"pod.png\", \"pod_case.png\"};\n                case AirPodsModel::AirPods3:\n                    return {\"pod3.png\", \"pod3_case.png\"};\n                case AirPodsModel::AirPods4:\n                case AirPodsModel::AirPods4ANC:\n                    return {\"pod3.png\", \"pod4_case.png\"};\n                case AirPodsModel::AirPodsPro:\n                case AirPodsModel::AirPodsPro2Lightning:\n                case AirPodsModel::AirPodsPro2USBC:\n                    return {\"podpro.png\", \"podpro_case.png\"};\n                case AirPodsModel::AirPodsMaxLightning:\n                case AirPodsModel::AirPodsMaxUSBC:\n                    return {\"max.png\", \"max_case.png\"};\n                default:\n                    return {\"pod.png\", \"pod_case.png\"}; // Default icon for unknown models\n            }\n        }\n\n    }\n}"
        },
        {
          "name": "QRCodeImageProvider.hpp",
          "ext": ".hpp",
          "size": 1505,
          "preview": "#include <QQuickImageProvider>\n#include <QPainter>\n#include \"thirdparty/QR-Code-generator/qrcodegen.hpp\"\n\nclass QRCodeImageProvider : public QQuickImageProvider\n{\npublic:\n    QRCodeImageProvider() : QQuickImageProvider(QQuickImageProvider::Image) {}\n\n    QImage requestImage(const QString &id, QSize *size, const QSize &requestedSize) override\n    {\n        // Parse the keys from id (format: \"encKey;irk\")\n        QStringList keys = id.split(';');\n        if (keys.size() != 2)\n            return QImage();\n\n        // Create URL format: librepods://add-magic-keys?enc_key=...&irk=...\n        QString data = QString(\"librepods://add-magic-keys?enc_key=%1&irk=%2\").arg(keys[0], keys[1]);\n\n        // Generate QR code using the existing qrcodegen library\n        qrcodegen::QrCode qr = qrcodegen::QrCode::encodeText(data.toUtf8().constData(), qrcodegen::QrCode::Ecc::MEDIUM);\n\n        int scale = 8;\n        QImage image(qr.getSize() * scale, qr.getSize() * scale, QImage::Format_RGB32);\n        image.fill(Qt::white);\n\n        QPainter painter(&image);\n        painter.setPen(Qt::NoPen);\n        painter.setBrush(Qt::black);\n\n        for (int y = 0; y < qr.getSize(); y++)\n        {\n            for (int x = 0; x < qr.getSize(); x++)\n            {\n                if (qr.getModule(x, y))\n                {\n                    painter.drawRect(x * scale, y * scale, scale, scale);\n                }\n            }\n        }\n\n        if (size)\n            *size = image.size();\n        return image;\n    }\n};"
        },
        {
          "name": "autostartmanager.hpp",
          "ext": ".hpp",
          "size": 2786,
          "preview": "#ifndef AUTOSTARTMANAGER_HPP\n#define AUTOSTARTMANAGER_HPP\n\n#include <QObject>\n#include <QSettings>\n#include <QStandardPaths>\n#include <QFile>\n#include <QDir>\n#include <QCoreApplication>\n\nclass AutoStartManager : public QObject\n{\n    Q_OBJECT\n    Q_PROPERTY(bool autoStartEnabled READ autoStartEnabled WRITE setAutoStartEnabled NOTIFY autoStartEnabledChanged)\n\npublic:\n    explicit AutoStartManager(QObject *parent = nullptr) : QObject(parent)\n    {\n        QString autostartDir = QStandardPaths::writableLocation(QStandardPaths::ConfigLocation) + \"/autostart\";\n        QDir().mkpath(autostartDir);\n        m_autostartFilePath = autostartDir + \"/\" + QCoreApplication::applicationName() + \".desktop\";\n    }\n\n    bool autoStartEnabled() const\n    {\n        return QFile::exists(m_autostartFilePath);\n    }\n\n    void setAutoStartEnabled(bool enabled)\n    {\n        if (autoStartEnabled() == enabled)\n        {\n            return;\n        }\n\n        if (enabled)\n        {\n            createAutoStartEntry();\n        }\n        else\n        {\n            removeAutoStartEntry();\n        }\n\n        emit autoStartEnabledChanged(enabled);\n    }\n\nprivate:\n    void createAutoStartEntry()\n    {\n        QFile desktopFile(m_autostartFilePath);\n        if (!desktopFile.open(QIODevice::WriteOnly | QIODevice::Text))\n        {\n            qWarning() << \"Failed to create autostart file:\" << desktopFile.errorString();\n            return;\n        }\n\n        QString appPath = QCoreApplication::applicationFilePath();\n        // Handle cases where the path might contain spaces\n        if (appPath.contains(' '))\n        {\n            appPath = \"\\\"\" + appPath + \"\\\"\";\n        }\n\n        QString content = QStringLiteral(\n                              \"[Desktop Entry]\\n\"\n                              \"Type=Application\\n\"\n                              \"Name=%1\\n\"\n                              \"Exec=%2 --hide\\n\"\n                              \"Icon=%3\\n\"\n                              \"Comment=%4\\n\"\n                              \"X-GNOME-Autostart-enabled=true\\n\"\n                              \"Terminal=false\\n\")\n                              .arg(\n                                  QCoreApplication::applicationName(),\n                                  appPath,\n                                  QCoreApplication::applicationName().toLower(),\n                                  QCoreApplication::applicationName() + \" autostart\");\n\n        desktopFile.write(content.toUtf8());\n        desktopFile.close();\n    }\n\n    void removeAutoStartEntry()\n    {\n        if (QFile::exists(m_autostartFilePath))\n        {\n            QFile::remove(m_autostartFilePath);\n        }\n    }\n\n    QString m_autostartFilePath;\n\nsignals:\n    void autoStartEnabledChanged(bool enabled);\n};\n\n#endif // AUTOSTARTMANAGER_HPP"
        },
        {
          "name": "PodColumn.qml",
          "ext": ".qml",
          "size": 882
        },
        {
          "name": "systemsleepmonitor.hpp",
          "ext": ".hpp",
          "size": 1226,
          "preview": "#ifndef SYSTEMSLEEPMONITOR_HPP\n#define SYSTEMSLEEPMONITOR_HPP\n\n#include <QObject>\n#include <QDBusConnection>\n#include <QDBusInterface>\n#include <QDBusMessage>\n#include <QDebug>\n\nclass SystemSleepMonitor : public QObject {\n    Q_OBJECT\n\npublic:\n    explicit SystemSleepMonitor(QObject *parent = nullptr) : QObject(parent) {\n        // Connect to the system D-Bus\n        QDBusConnection systemBus = QDBusConnection::systemBus();\n        if (!systemBus.isConnected()) {\n            qWarning() << \"Cannot connect to system D-Bus\";\n            return;\n        }\n\n        // Subscribe to PrepareForSleep signal from logind\n        systemBus.connect(\n            \"org.freedesktop.login1\",\n            \"/org/freedesktop/login1\",\n            \"org.freedesktop.login1.Manager\",\n            \"PrepareForSleep\",\n            this,\n            SLOT(handlePrepareForSleep(bool))\n        );\n    }\n\n    ~SystemSleepMonitor() override = default;\n\nsignals:\n    void systemGoingToSleep();\n    void systemWakingUp();\n\nprivate slots:\n    void handlePrepareForSleep(bool sleeping) {\n        if (sleeping) {\n            emit systemGoingToSleep();\n        } else {\n            emit systemWakingUp();\n        }\n    }\n};\n\n#endif // SYSTEMSLEEPMONITOR_HPP"
        },
        {
          "name": "deviceinfo.hpp",
          "ext": ".hpp",
          "size": 8440,
          "preview": "#pragma once\n\n#include <QObject>\n#include <QByteArray>\n#include <QSettings>\n#include \"battery.hpp\"\n#include \"enums.h\"\n#include \"eardetection.hpp\"\n\nusing namespace AirpodsTrayApp::Enums;\n\nclass DeviceInfo : public QObject\n{\n    Q_OBJECT\n    Q_PROPERTY(QString batteryStatus READ batteryStatus WRITE setBatteryStatus NOTIFY batteryStatusChanged)\n    Q_PROPERTY(int noiseControlMode READ noiseControlModeInt WRITE setNoiseControlModeInt NOTIFY noiseControlModeChangedInt)\n    Q_PROPERTY(bool conversationalAwareness READ conversationalAwareness WRITE setConversationalAwareness NOTIFY conversationalAwarenessChanged)\n    Q_PROPERTY(int adaptiveNoiseLevel READ adaptiveNoiseLevel WRITE setAdaptiveNoiseLevel NOTIFY adaptiveNoiseLevelChanged)\n    Q_PROPERTY(QString deviceName READ deviceName WRITE setDeviceName NOTIFY deviceNameChanged)\n    Q_PROPERTY(Battery *battery READ getBattery CONSTANT)\n    Q_PROPERTY(bool oneBudANCMode READ oneBudANCMode WRITE setOneBudANCMode NOTIFY oneBudANCModeChanged)\n    Q_PROPERTY(AirPodsModel model READ model WRITE setModel NOTIFY modelChanged)\n    Q_PROPERTY(bool adaptiveModeActive READ adaptiveModeActive NOTIFY noiseControlModeChangedInt)\n    Q_PROPERTY(QString podIcon READ podIcon NOTIFY modelChanged)\n    Q_PROPERTY(QString caseIcon READ caseIcon NOTIFY modelChanged)\n    Q_PROPERTY(bool leftPodInEar READ isLeftPodInEar NOTIFY primaryChanged)\n    Q_PROPERTY(bool rightPodInEar READ isRightPodInEar NOTIFY primaryChanged)\n    Q_PROPERTY(QString bluetoothAddress READ bluetoothAddress WRITE setBluetoothAddress NOTIFY bluetoothAddressChanged)\n    Q_PROPERTY(QString magicAccIRK READ magicAccIRKHex CONSTANT)\n    Q_PROPERTY(QString magicAccEncKey READ magicAccEncKeyHex CONSTANT)\n\npublic:\n    explicit DeviceInfo(QObject *parent = nullptr) : QObject(parent), m_battery(new Battery(this)), m_earDetection(new EarDetection(this)) {\n        connect(getEarDetection(), &EarDetection::statusChanged, this, &DeviceInfo::primaryChanged);\n    }\n\n    QString batteryStatus() const { return m_batteryStatus; }\n    void setBatteryStatus(const QString &status)\n    {\n        if (m_batteryStatus != status)\n        {\n            m_batteryStatus = status;\n            emit batteryStatusChanged(status);\n        }\n    }\n\n    NoiseControlMode noiseControlMode() const { return m_noiseControlMode; }\n    void setNoiseControlMode(NoiseControlMode mode)\n    {\n        if (m_noiseControlMode != mode)\n        {\n            m_noiseControlMode = mode;\n            emit noiseControlModeChanged(mode);\n            emit noiseControlModeChangedInt(static_cast<int>(mode));\n        }\n    }\n    int noiseControlModeInt() const { return static_cast<int>(noiseControlMode()); }\n    void setNoiseControlModeInt(int mode) { setNoiseControlMode(static_cast<NoiseControlMode>(mode)); }\n\n    bool conversationalAwareness() const { return m_conversationalAwareness; }\n    void setConversationalAwareness(bool enabled)\n    {\n        if (m_conversationalAwareness != enabled)\n        {\n            m_conversationalAwareness = enabled;\n            emit conversationalAwarenessChanged(enabled);\n        }\n    }\n\n    int adaptiveNoiseLevel() const { return m_adaptiveNoiseLevel; }\n    void setAdaptiveNoiseLevel(int level)\n    {\n        if (m_adaptiveNoiseLevel != level)\n        {\n            m_adaptiveNoiseLevel = level;\n            emit adaptiveNoiseLevelChanged(level);\n        }\n    }\n\n    QString deviceName() const { return m_deviceName; }\n    void setDeviceName(const QString &name)\n    {\n        if (m_deviceName != name)\n        {\n            m_deviceName = name;\n            emit deviceNameChanged(name);\n        }\n    }\n\n    Battery *getBattery() const { return m_battery; }\n\n    bool oneBudANCMode() const { return m_oneBudANCMode; }\n    void setOneBudANCMode(bool enabled)\n    {\n        if (m_oneBudANCMode != enabled)\n        {\n            m_oneBudANCMode = enabled;\n            emit oneBudANCModeChanged(enabled);\n        }\n    }\n\n    AirPodsModel model() const { return m_model; }\n    void setModel(AirPodsModel model)\n    {\n        if (m_model != model)\n        {\n            m_model = model;\n            emit modelChanged();\n        }\n    }\n\n    QByteArray magicAccIRK() const { return m_magicAccIRK; }\n    void setMagicAccIRK(const QByteArray &irk) { m_magicAccIRK = irk; }\n    QString magicAccIRKHex() const { return QString::fromUtf8(m_magicAccIRK.toHex()); }\n\n    QByteArray magicAccEncKey() const { return m_magicAccEncKey; }\n    void setMagicAccEncKey(const QByteArray &key) { m_magicAccEncKey = key; }\n    QString magicAccEncKeyHex() const { return QString::fromUtf8(m_magicAccEncKey.toHex()); }\n\n    QString modelNumber() const { return m_modelNumber; }\n    void setModelNumber(const QString &modelNumber) { m_modelNumber = modelNumber; }\n\n    QString manufacturer() const { return m_manufacturer; }\n    void setManufacturer(const QString &manufacturer) { m_manufacturer = manufacturer; }\n\n    QString bluetoothAddress() const { return m_bluetoothAddress; }\n    void setBluetoothAddress(const QString &address)\n    {\n        if (m_bluetoothAddress != address)\n        {\n            m_bluetoothAddress = address;\n            emit bluetoothAddressChanged(address);\n        }\n    }\n\n    QString podIcon() const { return getModelIcon(model()).first; }\n    QString caseIcon() const { return getModelIcon(model()).second; }\n    bool isLeftPodInEar() const\n    {\n        if (getBattery()->getPrimaryPod() == Battery::Component::Left) return getEarDetection()->isPrimaryInEar();\n        else return getEarDetection()->isSecondaryInEar();\n    }\n    bool isRightPodInEar() const\n    {\n        if (getBattery()->getPrimaryPod() == Battery::Component::Right) return getEarDetection()->isPrimaryInEar();\n        else return getEarDetection()->isSecondaryInEar();\n    }\n\n    bool adaptiveModeActive() const { return noiseControlMode() == NoiseControlMode::Adaptive; }\n\n    EarDetection *getEarDetection() const { return m_earDetection; }\n\n    void reset()\n    {\n        setDeviceName(\"\");\n        setModel(AirPodsModel::Unknown);\n        m_battery->reset();\n        setBatteryStatus(\"\");\n        setNoiseControlMode(NoiseControlMode::Off);\n        setBluetoothAddress(\"\");\n        getEarDetection()->reset();\n    }\n\n    void saveToSettings(QSettings &settings)\n    {\n        settings.beginGroup(\"DeviceInfo\");\n        settings.setValue(\"deviceName\", deviceName());\n        settings.setValue(\"model\", static_cast<int>(model()));\n        settings.setValue(\"magicAccIRK\", magicAccIRK());\n        settings.setValue(\"magicAccEncKey\", magicAccEncKey());\n        settings.endGroup();\n    }\n    void loadFromSettings(const QSettings &settings)\n    {\n        setDeviceName(settings.value(\"DeviceInfo/deviceName\", \"\").toString());\n        setModel(static_cast<AirPodsModel>(settings.value(\"DeviceInfo/model\", (int)(AirPodsModel::Unknown)).toInt()));\n        setMagicAccIRK(settings.value(\"DeviceInfo/magicAccIRK\", QByteArray()).toByteArray());\n        setMagicAccEncKey(settings.value(\"DeviceInfo/magicAccEncKey\", QByteArray()).toByteArray());\n    }\n\n    void updateBatteryStatus()\n    {\n        int leftLevel = getBattery()->getState(Battery::Component::Left).level;\n        int rightLevel = getBattery()->getState(Battery::Component::Right).level;\n        int caseLevel = getBattery()->getState(Battery::Component::Case).level;\n        setBatteryStatus(QString(\"Left: %1%, Right: %2%, Case: %3%\").arg(leftLevel).arg(rightLevel).arg(caseLevel));\n    }\n\nsignals:\n    void batteryStatusChanged(const QString &status);\n    void noiseControlModeChanged(NoiseControlMode mode);\n    void noiseControlModeChangedInt(int mode);\n    void conversationalAwarenessChanged(bool enabled);\n    void adaptiveNoiseLevelChanged(int level);\n    void deviceNameChanged(const QString &name);\n    void primaryChanged();\n    void oneBudANCModeChanged(bool enabled);\n    void modelChanged();\n    void bluetoothAddressChanged(const QString &address);\n\nprivate:\n    QString m_batteryStatus;\n    NoiseControlMode m_noiseControlMode = NoiseControlMode::Transparency;\n    bool m_conversationalAwareness = false;\n    int m_adaptiveNoiseLevel = 50;\n    QString m_deviceName;\n    Battery *m_battery;\n    QByteArray m_magicAccIRK;\n    QByteArray m_magicAccEncKey;\n    bool m_oneBudANCMode = false;\n    AirPodsModel m_model = AirPodsModel::Unknown;\n    QString m_modelNumber;\n    QString m_manufacturer;\n    QString m_bluetoothAddress;\n    EarDetection *m_earDetection;\n};"
        },
        {
          "name": "BluetoothMonitor.h",
          "ext": ".h",
          "size": 992,
          "preview": "#ifndef BLUETOOTHMONITOR_H\n#define BLUETOOTHMONITOR_H\n\n#include <QObject>\n#include <QtDBus/QtDBus>\n\n// Forward declarations for D-Bus types\ntypedef QMap<QDBusObjectPath, QMap<QString, QVariantMap>> ManagedObjectList;\nQ_DECLARE_METATYPE(ManagedObjectList)\n\nclass BluetoothMonitor : public QObject, protected QDBusContext\n{\n    Q_OBJECT\npublic:\n    explicit BluetoothMonitor(QObject *parent = nullptr);\n    ~BluetoothMonitor();\n\n    bool checkAlreadyConnectedDevices();\n\nsignals:\n    void deviceConnected(const QString &macAddress, const QString &deviceName);\n    void deviceDisconnected(const QString &macAddress, const QString &deviceName);\n\nprivate slots:\n    void onPropertiesChanged(const QString &interface, const QVariantMap &changedProps, const QStringList &invalidatedProps);\n\nprivate:\n    QDBusConnection m_dbus;\n    void registerDBusService();\n    bool isAirPodsDevice(const QString &devicePath);\n    QString getDeviceName(const QString &devicePath);\n};\n\n#endif // BLUETOOTHMONITOR_H"
        },
        {
          "name": "BluetoothMonitor.cpp",
          "ext": ".cpp",
          "size": 5283,
          "preview": "#include \"BluetoothMonitor.h\"\n#include \"logger.h\"\n\n#include <QDebug>\n#include <QDBusObjectPath>\n#include <QDBusMetaType>\n\nBluetoothMonitor::BluetoothMonitor(QObject *parent)\n    : QObject(parent), m_dbus(QDBusConnection::systemBus())\n{\n    // Register meta-types for D-Bus interaction\n    qDBusRegisterMetaType<QDBusObjectPath>();\n    qDBusRegisterMetaType<ManagedObjectList>();\n\n    if (!m_dbus.isConnected())\n    {\n        LOG_WARN(\"Failed to connect to system D-Bus\");\n        return;\n    }\n\n    registerDBusService();\n    checkAlreadyConnectedDevices(); // Check for already connected devices on startup\n}\n\nBluetoothMonitor::~BluetoothMonitor()\n{\n    m_dbus.disconnectFromBus(m_dbus.name());\n}\n\nvoid BluetoothMonitor::registerDBusService()\n{\n    // Match signals for PropertiesChanged on any BlueZ Device interface\n    if (!m_dbus.connect(\"\", \"\", \"org.freedesktop.DBus.Properties\", \"PropertiesChanged\",\n                        this, SLOT(onPropertiesChanged(QString, QVariantMap, QStringList))))\n    {\n        LOG_WARN(\"Failed to connect to D-Bus PropertiesChanged signal\");\n    }\n}\n\nbool BluetoothMonitor::isAirPodsDevice(const QString &devicePath)\n{\n    QDBusInterface deviceInterface(\"org.bluez\", devicePath, \"org.freedesktop.DBus.Properties\", m_dbus);\n\n    // Get UUIDs to check if it's an AirPods device\n    QDBusReply<QVariant> uuidsReply = deviceInterface.call(\"Get\", \"org.bluez.Device1\", \"UUIDs\");\n    if (!uuidsReply.isValid())\n    {\n        return false;\n    }\n\n    QStringList uuids = uuidsReply.value().toStringList();\n    return uuids.contains(\"74ec2172-0bad-4d01-8f77-997b2be0722a\");\n}\n\nQString BluetoothMonitor::getDeviceName(const QString &devicePath)\n{\n    QDBusInterface deviceInterface(\"org.bluez\", devicePath, \"org.freedesktop.DBus.Properties\", m_dbus);\n    QDBusReply<QVariant> nameReply = deviceInterface.call(\"Get\", \"org.bluez.Device1\", \"Name\");\n    if (nameReply.isValid())\n    {\n        return nameReply.value().toString();\n    }\n    return \"Unknown\";\n}\n\nbool BluetoothMonitor::checkAlreadyConnectedDevices()\n{\n    QDBusInterface objectManager(\"org.bluez\", \"/\", \"org.freedesktop.DBus.ObjectManager\", m_dbus);\n    QDBusMessage reply = objectManager.call(\"GetManagedObjects\");\n\n    if (reply.type() == QDBusMessage::ErrorMessage)\n    {\n        LOG_WARN(\"Failed to get managed objects: \" << reply.errorMessage());\n        return false;\n    }\n\n    QVariant firstArg = reply.arguments().constFirst();\n    QDBusArgument arg = firstArg.value<QDBusArgument>();\n    ManagedObjectList managedObjects;\n    arg >> managedObjects;\n\n    bool deviceFound = false;\n\n    for (auto it = managedObjects.constBegin(); it != managedObjects.constEnd(); ++it)\n    {\n        const QDBusObjectPath &objPath = it.key();\n        const QMap<QString, QVariantMap> &interfaces = it.value();\n\n        if (interfaces.contains(\"org.bluez.Device1\"))\n        {\n            const QVariantMap &deviceProps = interfaces.value(\"org.bluez.Device1\");\n\n            // Check if the device has the necessary properties\n            if (!deviceProps.contains(\"UUIDs\") || !deviceProps.contains(\"Connected\") ||\n                !deviceProps.contains(\"Address\") || !deviceProps.contains(\"Name\"))\n            {\n                continue;\n            }\n\n            QStringList uuids = deviceProps[\"UUIDs\"].toStringList();\n            bool isAirPods = uuids.contains(\"74ec2172-0bad-4d01-8f77-997b2be0722a\");\n\n            if (isAirPods)\n            {\n                bool connected = deviceProps[\"Connected\"].toBool();\n                if (connected)\n                {\n                    QString macAddress = deviceProps[\"Address\"].toString();\n                    QString deviceName = deviceProps[\"Name\"].toString();\n                    emit deviceConnected(macAddress, deviceName);\n                    LOG_DEBUG(\"Found already connected AirPods: \" << macAddress << \" Name: \" << deviceName);\n                    deviceFound = true;\n                }\n            }\n        }\n    }\n    return deviceFound;\n}\n\nvoid BluetoothMonitor::onPropertiesChanged(const QString &interface, const QVariantMap &changedProps, const QStringList &invalidatedProps)\n{\n    Q_UNUSED(invalidatedProps);\n\n    if (interface != \"org.bluez.Device1\")\n    {\n        return;\n    }\n\n    if (changedProps.contains(\"Connected\"))\n    {\n        bool connected = changedProps[\"Connected\"].toBool();\n        QString path = QDBusContext::message().path();\n\n        if (!isAirPodsDevice(path))\n        {\n            return;\n        }\n\n        QDBusInterface deviceInterface(\"org.bluez\", path, \"org.freedesktop.DBus.Properties\", m_dbus);\n\n        // Get the device address\n        QDBusReply<QVariant> addrReply = deviceInterface.call(\"Get\", \"org.bluez.Device1\", \"Address\");\n        if (!addrReply.isValid())\n        {\n            return;\n        }\n        QString macAddress = addrReply.value().toString();\n        QString deviceName = getDeviceName(path);\n\n        if (connected)\n        {\n            emit deviceConnected(macAddress, deviceName);\n            LOG_DEBUG(\"AirPods device connected:\" << macAddress << \" Name:\" << deviceName);\n        }\n        else\n        {\n            emit deviceDisconnected(macAddress, deviceName);\n            LOG_DEBUG(\"AirPods device disconnected:\" << macAddress << \" Name:\" << deviceName);\n        }\n    }\n}"
        },
        {
          "name": "Icon.qml",
          "ext": ".qml",
          "size": 220
        },
        {
          "name": "SegmentedControl.qml",
          "ext": ".qml",
          "size": 3740
        },
        {
          "name": "airpods_packets.h",
          "ext": ".h",
          "size": 8631,
          "preview": "// airpods_packets.h\n#ifndef AIRPODS_PACKETS_H\n#define AIRPODS_PACKETS_H\n\n#include <QByteArray>\n#include <optional>\n#include <climits>\n\n#include \"enums.h\"\n#include \"BasicControlCommand.hpp\"\n\nnamespace AirPodsPackets\n{\n    // Noise Control Mode Packets\n    namespace NoiseControl\n    {\n        using NoiseControlMode = AirpodsTrayApp::Enums::NoiseControlMode;\n        static const QByteArray HEADER = ControlCommand::HEADER + 0x0D;\n        static const QByteArray OFF = ControlCommand::createCommand(0x0D, 0x01);\n        static const QByteArray NOISE_CANCELLATION = ControlCommand::createCommand(0x0D, 0x02);\n        static const QByteArray TRANSPARENCY = ControlCommand::createCommand(0x0D, 0x03);\n        static const QByteArray ADAPTIVE = ControlCommand::createCommand(0x0D, 0x04);\n\n        static const QByteArray getPacketForMode(AirpodsTrayApp::Enums::NoiseControlMode mode)\n        {\n            switch (mode)\n            {\n            case NoiseControlMode::Off:\n                return OFF;\n            case NoiseControlMode::NoiseCancellation:\n                return NOISE_CANCELLATION;\n            case NoiseControlMode::Transparency:\n                return TRANSPARENCY;\n            case NoiseControlMode::Adaptive:\n                return ADAPTIVE;\n            default:\n                return QByteArray();\n            }\n        }\n\n        inline std::optional<NoiseControlMode> parseMode(const QByteArray &data)\n        {\n            char mode = ControlCommand::parseActive(data).value_or(CHAR_MAX) - 1;\n            if (mode < static_cast<quint8>(NoiseControlMode::MinValue) ||\n                mode > static_cast<quint8>(NoiseControlMode::MaxValue))\n            {\n                return std::nullopt;\n            }\n            return static_cast<NoiseControlMode>(mode);\n        }\n    }\n\n    // One Bud ANC Mode\n    namespace OneBudANCMode\n    {\n        using Type = BasicControlCommand<0x1B>;\n        static const QByteArray ENABLED = Type::ENABLED;\n        static const QByteArray DISABLED = Type::DISABLED;\n        static const QByteArray HEADER = Type::HEADER;\n        inline std::optional<bool> parseState(const QByteArray &data) { return Type::parseState(data); }\n    }\n\n    // Volume Swipe (partial - still needs custom interval function)\n    namespace VolumeSwipe\n    {\n        using Type = BasicControlCommand<0x25>;\n        static const QByteArray ENABLED = Type::ENABLED;\n        static const QByteArray DISABLED = Type::DISABLED;\n        static const QByteArray HEADER = Type::HEADER;\n        inline std::optional<bool> parseState(const QByteArray &data) { return Type::parseState(data); }\n\n        // Keep custom interval function\n        static QByteArray getIntervalPacket(quint8 interval)\n        {\n            return ControlCommand::createCommand(0x23, interval);\n        }\n    }\n\n    // Adaptive Volume Config\n    namespace AdaptiveVolume\n    {\n        using Type = BasicControlCommand<0x26>;\n        static const QByteArray ENABLED = Type::ENABLED;\n        static const QByteArray DISABLED = Type::DISABLED;\n        static const QByteArray HEADER = Type::HEADER;\n        inline std::optional<bool> parseState(const QByteArray &data) { return Type::parseState(data); }\n    }\n\n    // Conversational Awareness\n    namespace ConversationalAwareness\n    {\n        using Type = BasicControlCommand<0x28>;\n        static const QByteArray ENABLED = Type::ENABLED;\n        static const QByteArray DISABLED = Type::DISABLED;\n        static const QByteArray HEADER = Type::HEADER;\n        static const QByteArray DATA_HEADER = QByteArray::fromHex(\"040004004B00020001\");\n        inline std::optional<bool> parseState(const QByteArray &data) { return Type::parseState(data); }\n    }\n\n    // Hearing Assist\n    namespace HearingAssist\n    {\n        using Type = BasicControlCommand<0x33>;\n        static const QByteArray ENABLED = Type::ENABLED;\n        static const QByteArray DISABLED = Type::DISABLED;\n        static const QByteArray HEADER = Type::HEADER;\n        inline std::optional<bool> parseState(const QByteArray &data) { return Type::parseState(data); }\n    }\n\n    // Allow Off Option\n    namespace AllowOffOption\n    {\n        using Type = BasicControlCommand<0x34>;\n        static const QByteArray ENABLED = Type::ENABLED;\n        static const QByteArray DISABLED = Type::DISABLED;\n        static const QByteArray HEADER = Type::HEADER;\n        inline std::optional<bool> parseState(const QByteArray &data) { return Type::parseState(data); }\n    }\n\n    // Connection Packets\n    namespace Connection\n    {\n        static const QByteArray HANDSHAKE = QByteArray::fromHex(\"00000400010002000000000000000000\");\n        static const QByteArray SET_SPECIFIC_FEATURES = QByteArray::fromHex(\"040004004d00d700000000000000\");\n        static const QByteArray REQUEST_NOTIFICATIONS = QByteArray::fromHex(\"040004000f00ffffffffff\");\n        static const QByteArray AIRPODS_DISCONNECTED = QByteArray::fromHex(\"00010000\");\n    }\n\n    // Phone Communication Packets\n    namespace Phone\n    {\n        static const QByteArray NOTIFICATION = QByteArray::fromHex(\"00040001\");\n        static const QByteArray CONNECTED = QByteArray::fromHex(\"00010001\");\n        static const QByteArray DISCONNECTED = QByteArray::fromHex(\"00010000\");\n        static const QByteArray STATUS_REQUEST = QByteArray::fromHex(\"00020003\");\n        static const QByteArray DISCONNECT_REQUEST = QByteArray::fromHex(\"00020000\");\n    }\n\n    // Adaptive Noise Packets\n    namespace AdaptiveNoise\n    {\n        const QByteArray HEADER = QByteArray::fromHex(\"0400040009002E\");\n\n        inline QByteArray getPacket(int level)\n        {\n            return HEADER + static_cast<char>(level) + QByteArray::fromHex(\"000000\");\n        }\n    }\n\n    namespace Rename\n    {\n        static QByteArray getPacket(const QString &newName)\n        {\n            QByteArray nameBytes = newName.toUtf8();                   // Convert name to UTF-8\n            quint8 size = static_cast<char>(nameBytes.size());         // Name length (1 byte)\n            QByteArray packet = QByteArray::fromHex(\"040004001A0001\"); // Header\n            packet.append(size);                                       // Append size byte\n            packet.append('\\0');                                       // Append null byte\n            packet.append(nameBytes);                                  // Append name bytes\n            return packet;\n        }\n    }\n\n    namespace MagicPairing {\n        static const QByteArray REQUEST_MAGIC_CLOUD_KEYS = QByteArray::fromHex(\"0400040030000500\");\n        static const QByteArray MAGIC_CLOUD_KEYS_HEADER = QByteArray::fromHex(\"04000400310002\");\n\n        struct MagicCloudKeys {\n            QByteArray magicAccIRK;      // 16 bytes\n            QByteArray magicAccEncKey;    // 16 bytes\n        };\n\n        inline MagicCloudKeys parseMagicCloudKeysPacket(const QByteArray &data)\n        {\n            MagicCloudKeys keys;\n\n            if (data.size() < 47 || !data.startsWith(MAGIC_CLOUD_KEYS_HEADER))\n            {\n                return keys;\n            }\n\n            int index = MAGIC_CLOUD_KEYS_HEADER.size();\n\n            // First TLV block (MagicAccIRK)\n            if (static_cast<quint8>(data.at(index)) != 0x01)\n                return keys;\n            index += 1;\n\n            quint16 len1 = (static_cast<quint8>(data.at(index)) << 8) | static_cast<quint8>(data.at(index + 1));\n            if (len1 != 16)\n                return keys;\n            index += 3; // Skip length (2 bytes) and reserved byte (1 byte)\n\n            keys.magicAccIRK = data.mid(index, 16);\n            index += 16;\n\n            // Second TLV block (MagicAccEncKey)\n            if (static_cast<quint8>(data.at(index)) != 0x04)\n                return keys;\n            index += 1;\n\n            quint16 len2 = (static_cast<quint8>(data.at(index)) << 8) | static_cast<quint8>(data.at(index + 1));\n            if (len2 != 16)\n                return keys;\n            index += 3; // Skip length (2 bytes) and reserved byte (1 byte)\n\n            keys.magicAccEncKey = data.mid(index, 16);\n\n            return keys;\n        }\n    }\n\n    // Parsing Headers\n    namespace Parse\n    {\n        static const QByteArray EAR_DETECTION = QByteArray::fromHex(\"040004000600\");\n        static const QByteArray BATTERY_STATUS = QByteArray::fromHex(\"040004000400\");\n        static const QByteArray METADATA = QByteArray::fromHex(\"040004001d\");\n        static const QByteArray HANDSHAKE_ACK = QByteArray::fromHex(\"01000400\");\n        static const QByteArray FEATURES_ACK = QByteArray::fromHex(\"040004002b00\"); // Note: Only tested with airpods pro 2\n    }\n}\n\n#endif // AIRPODS_PACKETS_H\n"
        },
        {
          "name": "Main.qml",
          "ext": ".qml",
          "size": 12233
        },
        {
          "name": "battery.hpp",
          "ext": ".hpp",
          "size": 9243,
          "preview": "#pragma once\n\n#include <QByteArray>\n#include <QMap>\n#include <QString>\n#include <QObject>\n#include <climits>\n\n#include \"airpods_packets.h\"\n#include \"logger.h\"\n\nclass Battery : public QObject\n{\n    Q_OBJECT\n\n    Q_PROPERTY(quint8 leftPodLevel READ getLeftPodLevel NOTIFY batteryStatusChanged)\n    Q_PROPERTY(bool leftPodCharging READ isLeftPodCharging NOTIFY batteryStatusChanged)\n    Q_PROPERTY(bool leftPodAvailable READ isLeftPodAvailable NOTIFY batteryStatusChanged)\n    Q_PROPERTY(quint8 rightPodLevel READ getRightPodLevel NOTIFY batteryStatusChanged)\n    Q_PROPERTY(bool rightPodCharging READ isRightPodCharging NOTIFY batteryStatusChanged)\n    Q_PROPERTY(bool rightPodAvailable READ isRightPodAvailable NOTIFY batteryStatusChanged)\n    Q_PROPERTY(quint8 caseLevel READ getCaseLevel NOTIFY batteryStatusChanged)\n    Q_PROPERTY(bool caseCharging READ isCaseCharging NOTIFY batteryStatusChanged)\n    Q_PROPERTY(bool caseAvailable READ isCaseAvailable NOTIFY batteryStatusChanged)\n\npublic:\n    explicit Battery(QObject *parent = nullptr) : QObject(parent)\n    {\n        reset();\n    }\n\n    void reset()\n    {\n        // Initialize all components to unknown state\n        states[Component::Left] = {};\n        states[Component::Right] = {};\n        states[Component::Case] = {};\n        emit batteryStatusChanged();\n    }\n\n    // Enum for AirPods components\n    enum class Component\n    {\n        Right = 0x02,\n        Left = 0x04,\n        Case = 0x08,\n    };\n    Q_ENUM(Component)\n\n    enum class BatteryStatus\n    {\n        Charging = 0x01,\n        Discharging = 0x02,\n        Disconnected = 0x04,\n    };\n    Q_ENUM(BatteryStatus)\n\n    // Struct to hold battery level and status\n    struct BatteryState\n    {\n        quint8 level = 0; // Battery level (0-100), 0 if unknown\n        BatteryStatus status = BatteryStatus::Disconnected;\n    };\n\n    // Parse the battery status packet and detect primary/secondary pods\n    bool parsePacket(const QByteArray &packet)\n    {\n        if (!packet.startsWith(AirPodsPackets::Parse::BATTERY_STATUS))\n        {\n            return false;\n        }\n\n        // Get battery count (number of components)\n        quint8 batteryCount = static_cast<quint8>(packet[6]);\n        if (batteryCount > 3 || packet.size() != 7 + 5 * batteryCount)\n        {\n            return false; // Invalid count or size mismatch\n        }\n\n        QMap<Component, BatteryState> newStates = states;\n\n        // Track pods to determine primary and secondary based on order\n        QList<Component> podsInPacket;\n        podsInPacket.reserve(2);\n\n        for (quint8 i = 0; i < batteryCount; ++i)\n        {\n            int offset = 7 + (5 * i);\n            quint8 type = static_cast<quint8>(packet[offset]);\n\n            // Verify spacer and end bytes\n            if (static_cast<quint8>(packet[offset + 1]) != 0x01 ||\n                static_cast<quint8>(packet[offset + 4]) != 0x01)\n            {\n                return false;\n            }\n\n            Component comp = static_cast<Component>(type);\n            auto level = static_cast<quint8>(packet[offset + 2]);\n            auto status = static_cast<BatteryStatus>(packet[offset + 3]);\n\n            if (status != BatteryStatus::Disconnected)\n            {\n                newStates[comp] = {level, status};\n            }\n\n            // If this is a pod (Left or Right), add it to the list\n            if (comp == Component::Left || comp == Component::Right)\n            {\n                podsInPacket.append(comp);\n            }\n        }\n\n        // Update states\n        states = newStates;\n\n        // Set primary and secondary pods based on order\n        if (!podsInPacket.isEmpty())\n        {\n            Component newPrimaryPod = podsInPacket[0]; // First pod is primary\n            if (newPrimaryPod != primaryPod)\n            {\n                primaryPod = newPrimaryPod;\n                emit primaryChanged();\n            }\n        }\n        if (podsInPacket.size() >= 2)\n        {\n            secondaryPod = podsInPacket[1]; // Second pod is secondary\n        }\n\n        // Emit signal to notify about battery status change\n        emit batteryStatusChanged();\n\n        // Log which is left and right pod\n        LOG_INFO(\"Primary Pod:\" << primaryPod);\n        LOG_INFO(\"Secondary Pod:\" << secondaryPod);\n\n        return true;\n    }\n\n    bool parseEncryptedPacket(const QByteArray &packet, bool isLeftPodPrimary, bool podInCase)\n    {\n        // Validate packet size (expect 16 bytes based on provided payloads)\n        if (packet.size() != 16)\n        {\n            return false;\n        }\n\n        // Determine byte indices based on isFlipped\n        int leftByteIndex = isLeftPodPrimary ? 1 : 2;\n        int rightByteIndex = isLeftPodPrimary ? 2 : 1;\n\n        // Extract raw battery bytes\n        unsigned char rawLeftBatteryByte = static_cast<unsigned char>(packet.at(leftByteIndex));\n        unsigned char rawRightBatteryByte = static_cast<unsigned char>(packet.at(rightByteIndex));\n        unsigned char rawCaseBatteryByte = static_cast<unsigned char>(packet.at(3));\n\n        // Extract battery data (charging status and raw level 0-127)\n        auto [isLeftCharging, rawLeftBattery] = formatBattery(rawLeftBatteryByte);\n        auto [isRightCharging, rawRightBattery] = formatBattery(rawRightBatteryByte);\n        auto [isCaseCharging, rawCaseBattery] = formatBattery(rawCaseBatteryByte);\n\n        if (rawLeftBattery == CHAR_MAX) {\n            rawLeftBattery = states.value(Component::Left).level; // Use last valid level\n            isLeftCharging = states.value(Component::Left).status == BatteryStatus::Charging;\n        }\n\n        if (rawRightBattery == CHAR_MAX) {\n            rawRightBattery = states.value(Component::Right).level; // Use last valid level\n            isRightCharging = states.value(Component::Right).status == BatteryStatus::Charging;\n        }\n\n        if (rawCaseBattery == CHAR_MAX) {\n            rawCaseBattery = states.value(Component::Case).level; // Use last valid level\n            isCaseCharging = states.value(Component::Case).status == BatteryStatus::Charging;\n        }\n\n        // Update states\n        states[Component::Left] = {static_cast<quint8>(rawLeftBattery), isLeftCharging ? BatteryStatus::Charging : BatteryStatus::Discharging};\n        states[Component::Right] = {static_cast<quint8>(rawRightBattery), isRightCharging ? BatteryStatus::Charging : BatteryStatus::Discharging};\n        if (podInCase) {\n            states[Component::Case] = {static_cast<quint8>(rawCaseBattery), isCaseCharging ? BatteryStatus::Charging : BatteryStatus::Discharging};\n        }\n        primaryPod = isLeftPodPrimary ? Component::Left : Component::Right;\n        secondaryPod = isLeftPodPrimary ? Component::Right : Component::Left;\n        emit batteryStatusChanged();\n        emit primaryChanged();\n\n        return true;\n    }\n\n    // Get the raw state for a component\n    BatteryState getState(Component comp) const\n    {\n        return states.value(comp, {});\n    }\n\n    // Get a formatted status string including charging state\n    QString getComponentStatus(Component comp) const\n    {\n        BatteryState state = getState(comp);\n        if (state.level == 0)\n        {\n            return \"Unknown\";\n        }\n\n        QString statusStr;\n        switch (state.status)\n        {\n        case BatteryStatus::Charging:\n            statusStr = \"Charging\";\n            break;\n        case BatteryStatus::Discharging:\n            statusStr = \"Discharging\";\n            break;\n        case BatteryStatus::Disconnected:\n            statusStr = \"Disconnected\";\n            break;\n        default:\n            statusStr = \"Invalid\";\n            break;\n        }\n        return QString(\"%1% (%2)\").arg(state.level).arg(statusStr);\n    }\n\n    Component getPrimaryPod() const { return primaryPod; }\n    Component getSecondaryPod() const { return secondaryPod; }\n\n    quint8 getLeftPodLevel() const { return states.value(Component::Left).level; }\n    bool isLeftPodCharging() const { return isStatus(Component::Left, BatteryStatus::Charging); }\n    bool isLeftPodAvailable() const { return !isStatus(Component::Left, BatteryStatus::Disconnected); }\n    quint8 getRightPodLevel() const { return states.value(Component::Right).level; }\n    bool isRightPodCharging() const { return isStatus(Component::Right, BatteryStatus::Charging); }\n    bool isRightPodAvailable() const { return !isStatus(Component::Right, BatteryStatus::Disconnected); }\n    quint8 getCaseLevel() const { return states.value(Component::Case).level; }\n    bool isCaseCharging() const { return isStatus(Component::Case, BatteryStatus::Charging); }\n    bool isCaseAvailable() const { return !isStatus(Component::Case, BatteryStatus::Disconnected); }\n\nsignals:\n    void batteryStatusChanged();\n    void primaryChanged();\n\nprivate:\n    bool isStatus(Component component, BatteryStatus status) const\n    {\n        return states.value(component).status == status;\n    }\n\n    std::pair<bool, int> formatBattery(unsigned char byteVal)\n    {\n        bool charging = (byteVal & 0x80) != 0;\n        int level = byteVal & 0x7F;\n        return std::make_pair(charging, level);\n    }\n\n    QMap<Component, BatteryState> states;\n    Component primaryPod;\n    Component secondaryPod;\n};"
        },
        {
          "name": "main.cpp",
          "ext": ".cpp",
          "size": 40144,
          "preview": "#include <QSettings>\n#include <QLocalServer>\n#include <QLocalSocket>\n#include <QApplication>\n#include <QQmlApplicationEngine>\n#include <QQmlContext>\n#include <QBluetoothLocalDevice>\n#include <QBluetoothSocket>\n#include <QQuickWindow>\n#include <QLoggingCategory>\n#include <QThread>\n#include <QTimer>\n#include <QProcess>\n#include <QRegularExpression>\n\n#include \"airpods_packets.h\"\n#include \"logger.h\"\n#include \"media/mediacontroller.h\"\n#include \"trayiconmanager.h\"\n#include \"enums.h\"\n#include \"battery.hpp\"\n#include \"BluetoothMonitor.h\"\n#include \"autostartmanager.hpp\"\n#include \"deviceinfo.hpp\"\n#include \"ble/blemanager.h\"\n#include \"ble/bleutils.h\"\n#include \"QRCodeImageProvider.hpp\"\n#include \"systemsleepmonitor.hpp\"\n\nusing namespace AirpodsTrayApp::Enums;\n\nQ_LOGGING_CATEGORY(Librepods, \"Librepods\")\n\nclass AirPodsTrayApp : public QObject {\n    Q_OBJECT\n    Q_PROPERTY(bool airpodsConnected READ areAirpodsConnected NOTIFY airPodsStatusChanged)\n    Q_PROPERTY(int earDetectionBehavior READ earDetectionBehavior WRITE setEarDetectionBehavior NOTIFY earDetectionBehaviorChanged)\n    Q_PROPERTY(bool crossDeviceEnabled READ crossDeviceEnabled WRITE setCrossDeviceEnabled NOTIFY crossDeviceEnabledChanged)\n    Q_PROPERTY(AutoStartManager *autoStartManager READ autoStartManager CONSTANT)\n    Q_PROPERTY(bool notificationsEnabled READ notificationsEnabled WRITE setNotificationsEnabled NOTIFY notificationsEnabledChanged)\n    Q_PROPERTY(int retryAttempts READ retryAttempts WRITE setRetryAttempts NOTIFY retryAttemptsChanged)\n    Q_PROPERTY(bool hideOnStart READ hideOnStart CONSTANT)\n    Q_PROPERTY(DeviceInfo *deviceInfo READ deviceInfo CONSTANT)\n    Q_PROPERTY(QString phoneMacStatus READ phoneMacStatus NOTIFY phoneMacStatusChanged)\n\npublic:\n    AirPodsTrayApp(bool debugMode, bool hideOnStart, QQmlApplicationEngine *parent = nullptr)\n        : QObject(parent), debugMode(debugMode), m_settings(new QSettings(\"AirPodsTrayApp\", \"AirPodsTrayApp\"))\n        , m_autoStartManager(new AutoStartManager(this)), m_hideOnStart(hideOnStart), parent(parent)\n        , m_deviceInfo(new DeviceInfo(this)), m_bleManager(new BleManager(this))\n        , m_systemSleepMonitor(new SystemSleepMonitor(this))\n    {\n        QLoggingCategory::setFilterRules(QString(\"Librepods.debug=%1\").arg(debugMode ? \"true\" : \"false\"));\n        LOG_INFO(\"Initializing AirPodsTrayApp\");\n\n        // Initialize tray icon and connect signals\n        trayManager = new TrayIconManager(this);\n        trayManager->setNotificationsEnabled(loadNotificationsEnabled());\n        connect(trayManager, &TrayIconManager::trayClicked, this, &AirPodsTrayApp::onTrayIconActivated);\n        connect(trayManager, &TrayIconManager::openApp, this, &AirPodsTrayApp::onOpenApp);\n        connect(trayManager, &TrayIconManager::openSettings, this, &AirPodsTrayApp::onOpenSettings);\n        connect(trayManager, &TrayIconManager::noiseControlChanged, this, &AirPodsTrayApp::setNoiseControlMode);\n        connect(trayManager, &TrayIconManager::conversationalAwarenessToggled, this, &AirPodsTrayApp::setConversationalAwareness);\n        connect(m_deviceInfo, &DeviceInfo::batteryStatusChanged, trayManager, &TrayIconManager::updateBatteryStatus);\n        connect(m_deviceInfo, &DeviceInfo::noiseControlModeChanged, trayManager, &TrayIconManager::updateNoiseControlState);\n        connect(m_deviceInfo, &DeviceInfo::conversationalAwarenessChanged, trayManager, &TrayIconManager::updateConversationalAwareness);\n        connect(trayManager, &TrayIconManager::notificationsEnabledChanged, this, &AirPodsTrayApp::saveNotificationsEnabled);\n        connect(trayManager, &TrayIconManager::notificationsEnabledChanged, this, &AirPodsTrayApp::notificationsEnabledChanged);\n\n        // Initialize MediaController and connect signals\n        mediaController = new MediaController(this);\n        connect(mediaController, &MediaController::mediaStateChanged, this, &AirPodsTrayApp::handleMediaStateChange);\n        mediaController->followMediaChanges();\n\n        monitor = new BluetoothMonitor(this);\n        connect(monitor, &BluetoothMonitor::deviceConnected, this, &AirPodsTrayApp::bluezDeviceConnected);\n        connect(monitor, &BluetoothMonitor::deviceDisconnected, this, &AirPodsTrayApp::bluezDeviceDisconnected);\n\n        connect(m_bleManager, &BleManager::deviceFound, this, &AirPodsTrayApp::bleDeviceFound);\n        connect(m_deviceInfo->getBattery(), &Battery::primaryChanged, this, &AirPodsTrayApp::primaryChanged);\n        connect(m_systemSleepMonitor, &SystemSleepMonitor::systemGoingToSleep, this, &AirPodsTrayApp::onSystemGoingToSleep);\n        connect(m_systemSleepMonitor, &SystemSleepMonitor::systemWakingUp, this, &AirPodsTrayApp::onSystemWakingUp);\n\n        // Load settings\n        CrossDevice.isEnabled = loadCrossDeviceEnabled();\n        setEarDetectionBehavior(loadEarDetectionSettings());\n        setRetryAttempts(loadRetryAttempts());\n\n        monitor->checkAlreadyConnectedDevices();\n        LOG_INFO(\"AirPodsTrayApp initialized\");\n\n        QBluetoothLocalDevice localDevice;\n\n        const QList<QBluetoothAddress> connectedDevices = localDevice.connectedDevices();\n        for (const QBluetoothAddress &address : connectedDevices) {\n            QBluetoothDeviceInfo device(address, \"\", 0);\n            if (isAirPodsDevice(device)) {\n                connectToDevice(device);\n                return;\n            }\n        }\n\n        initializeDBus();\n        initializeBluetooth();\n    }\n\n    ~AirPodsTrayApp() {\n        saveCrossDeviceEnabled();\n        saveEarDetectionSettings();\n\n        delete socket;\n        delete phoneSocket;\n    }\n\n    bool areAirpodsConnected() const { return socket && socket->isOpen() && socket->state() == QBluetoothSocket::SocketState::ConnectedState; }\n    int earDetectionBehavior() const { return mediaController->getEarDetectionBehavior(); }\n    bool crossDeviceEnabled() const { return CrossDevice.isEnabled; }\n    AutoStartManager *autoStartManager() const { return m_autoStartManager; }\n    bool notificationsEnabled() const { return trayManager->notificationsEnabled(); }\n    void setNotificationsEnabled(bool enabled) { trayManager->setNotificationsEnabled(enabled); }\n    int retryAttempts() const { return m_retryAttempts; }\n    bool hideOnStart() const { return m_hideOnStart; }\n    DeviceInfo *deviceInfo() const { return m_deviceInfo; }\n    QString phoneMacStatus() const { return m_phoneMacStatus; }\n\nprivate:\n    bool debugMode;\n    bool isConnectedLocally = false;\n\n    QQmlApplicationEngine *parent = nullptr;\n\n    struct {\n        bool isAvailable = true;\n        bool isEnabled = true; // Ability to disable the feature\n    } CrossDevice;\n\n    void initializeDBus() { }\n\n    bool isAirPodsDevice(const QBluetoothDeviceInfo &device)\n    {\n        return device.serviceUuids().contains(QBluetoothUuid(\"74ec2172-0bad-4d01-8f77-997b2be0722a\"));\n    }\n\n    void notifyAndroidDevice()\n    {\n        if (!CrossDevice.isEnabled) {\n            return;\n        }\n\n        if (phoneSocket && phoneSocket->isOpen())\n        {\n            phoneSocket->write(AirPodsPackets::Phone::NOTIFICATION);\n            LOG_DEBUG(\"Sent notification packet to Android: \" << AirPodsPackets::Phone::NOTIFICATION.toHex());\n        }\n        else\n        {\n            LOG_WARN(\"Phone socket is not open, cannot send notification packet\");\n        }\n    }\n\n    void disconnectDevice(const QString &devicePath) {\n        LOG_INFO(\"Disconnecting device at \" << devicePath);\n    }\n\npublic slots:\n    void connectToDevice(const QString &address) {\n        LOG_INFO(\"Connecting to device with address: \" << address);\n        QBluetoothAddress btAddress(address);\n        QBluetoothDeviceInfo device(btAddress, \"\", 0);\n        connectToDevice(device);\n    }\n\n    void setNoiseControlMode(NoiseControlMode mode)\n    {\n        if (m_deviceInfo->noiseControlMode() == mode)\n        {\n            LOG_INFO(\"Noise control mode is already set to: \" << static_cast<int>(mode));\n            return;\n        }\n        LOG_INFO(\"Setting noise control mode to: \" << mode);\n        QByteArray packet = AirPodsPackets::NoiseControl::getPacketForMode(mode);\n        writePacketToSocket(packet, \"Noise control mode packet written: \");\n    }\n    void setNoiseControlModeInt(int mode)\n    {\n        if (mode < 0 || mode > static_cast<int>(NoiseControlMode::Adaptive))\n        {\n            LOG_ERROR(\"Invalid noise control mode: \" << mode);\n            return;\n        }\n        setNoiseControlMode(static_cast<NoiseControlMode>(mode));\n    }\n\n    void setConversationalAwareness(bool enabled)\n    {\n        LOG_INFO(\"Setting conversational awareness to: \" << (enabled ? \"enabled\" : \"disabled\"));\n        QByteArray packet = enabled ? AirPodsPackets::ConversationalAwareness::ENABLED\n                                    : AirPodsPackets::ConversationalAwareness::DISABLED;\n\n        writePacketToSocket(packet, \"Conversational awareness packet written: \");\n        m_deviceInfo->setConversationalAwareness(enabled);\n    }\n\n    void setOneBudANCMode(bool enabled)\n    {\n        if (m_deviceInfo->oneBudANCMode() == enabled)\n        {\n            LOG_INFO(\"One Bud ANC mode is already \" << (enabled ? \"enabled\" : \"disabled\"));\n            return;\n        }\n\n        LOG_INFO(\"Setting One Bud ANC mode to: \" << (enabled ? \"enabled\" : \"disabled\"));\n        QByteArray packet = enabled ? AirPodsPackets::OneBudANCMode::ENABLED\n                                    : AirPodsPackets::OneBudANCMode::DISABLED;\n\n        if (writePacketToSocket(packet, \"One Bud ANC mode packet written: \"))\n        {\n            m_deviceInfo->setOneBudANCMode(enabled);\n        }\n        else\n        {\n            LOG_ERROR(\"Failed to send One Bud ANC mode command: socket not open\");\n        }\n    }\n\n    void setRetryAttempts(int attempts)\n    {\n        if (m_retryAttempts != attempts)\n        {\n            LOG_DEBUG(\"Setting retry attempts to: \" << attempts);\n            m_retryAttempts = attempts;\n            emit retryAttemptsChanged(attempts);\n            saveRetryAttempts(attempts);\n        }\n    }\n\n    void initiateMagicPairing()\n    {\n        if (!socket || !socket->isOpen())\n        {\n            LOG_ERROR(\"Socket nicht offen, Magic Pairing kann nicht gestartet werden\");\n            return;\n        }\n\n        writePacketToSocket(AirPodsPackets::MagicPairing::REQUEST_MAGIC_CLOUD_KEYS, \"Magic Pairing packet written: \");\n    }\n\n    void setAdaptiveNoiseLevel(int level)\n    {\n        level = qBound(0, level, 100);\n        if (m_deviceInfo->adaptiveNoiseLevel() != level && m_deviceInfo->adaptiveModeActive())\n        {\n            QByteArray packet = AirPodsPackets::AdaptiveNoise::getPacket(level);\n            writePacketToSocket(packet, \"Adaptive noise level packet written: \");\n            m_deviceInfo->setAdaptiveNoiseLevel(level);\n        }\n    }\n\n    void renameAirPods(const QString &newName)\n    {\n        if (newName.isEmpty())\n        {\n            LOG_WARN(\"Cannot set empty name\");\n            return;\n        }\n        if (newName.size() > 32)\n        {\n            LOG_WARN(\"Name is too long, must be 32 characters or less\");\n            return;\n        }\n        if (newName == m_deviceInfo->deviceName())\n        {\n            LOG_INFO(\"Name is already set to: \" << newName);\n            return;\n        }\n\n        QByteArray packet = AirPodsPackets::Rename::getPacket(newName);\n        if (writePacketToSocket(packet, \"Rename packet written: \"))\n        {\n            LOG_INFO(\"Sent rename command for new name: \" << newName);\n            m_deviceInfo->setDeviceName(newName);\n        }\n        else\n        {\n            LOG_ERROR(\"Failed to send rename command: socket not open\");\n        }\n    }\n\n    void setEarDetectionBehavior(int behavior)\n    {\n        if (behavior == earDetectionBehavior())\n        {\n            LOG_INFO(\"Ear detection behavior is already set to: \" << behavior);\n            return;\n        }\n\n        mediaController->setEarDetectionBehavior(static_cast<MediaController::EarDetectionBehavior>(behavior));\n        saveEarDetectionSettings();\n        emit earDetectionBehaviorChanged(behavior);\n    }\n\n    void setCrossDeviceEnabled(bool enabled)\n    {\n        if (CrossDevice.isEnabled == enabled)\n        {\n            LOG_INFO(\"Cross-device feature is already \" << (enabled ? \"enabled\" : \"disabled\"));\n            return;\n        }\n\n        CrossDevice.isEnabled = enabled;\n        saveCrossDeviceEnabled();\n        connectToPhone();\n        emit crossDeviceEnabledChanged(enabled);\n    }\n\n    void setPhoneMac(const QString &mac)\n    {\n        if (mac.isEmpty()) {\n            LOG_WARN(\"Empty MAC provided, ignoring\");\n            m_phoneMacStatus = QStringLiteral(\"No MAC provided (ignoring)\");\n            emit phoneMacStatusChanged();\n            return;\n        }\n\n        // Basic MAC address validation (accepts formats like AA:BB:CC:DD:EE:FF, AABBCCDDEEFF, AA-BB-CC-DD-EE-FF)\n        QRegularExpression re(\"^([0-9A-Fa-f]{2}([-:]?)){5}[0-9A-Fa-f]{2}$\");\n        if (!re.match(mac).hasMatch()) {\n            LOG_ERROR(\"Invalid MAC address format: \" << mac);\n            m_phoneMacStatus = QStringLiteral(\"Invalid MAC: \") + mac;\n            emit phoneMacStatusChanged();\n            return;\n        }\n\n        // Set environment variable for the running process\n        qputenv(\"PHONE_MAC_ADDRESS\", mac.toUtf8());\n        LOG_INFO(\"PHONE_MAC_ADDRESS environment variable set to: \" << mac);\n\n        m_phoneMacStatus = QStringLiteral(\"Updated MAC: \") + mac;\n        emit phoneMacStatusChanged();\n\n        // Update QML context property so UI placeholders reflect the new value\n        if (parent) {\n            parent->rootContext()->setContextProperty(\"PHONE_MAC_ADDRESS\", mac);\n        }\n\n        // If a phone socket exists, restart connection using the new MAC\n        if (phoneSocket && phoneSocket->isOpen()) {\n            phoneSocket->close();\n            phoneSocket->deleteLater();\n            phoneSocket = nullptr;\n        }\n        connectToPhone();\n    }\n\n    void updatePhoneMacStatus(const QString &status)\n    {\n        m_phoneMacStatus = status;\n        emit phoneMacStatusChanged();\n    }\n\n    bool writePacketToSocket(const QByteArray &packet, const QString &logMessage)\n    {\n        if (socket && socket->isOpen())\n        {\n            socket->write(packet);\n            LOG_DEBUG(logMessage << packet.toHex());\n            return true;\n        }\n        else\n        {\n            LOG_ERROR(\"Socket is not open, cannot write packet\");\n            return false;\n        }\n    }\n\n    bool loadCrossDeviceEnabled() { return m_settings->value(\"crossdevice/enabled\", false).toBool(); }\n    void saveCrossDeviceEnabled() { m_settings->setValue(\"crossdevice/enabled\", CrossDevice.isEnabled); }\n\n    int loadEarDetectionSettings() { return m_settings->value(\"earDetection/setting\", MediaController::EarDetectionBehavior::PauseWhenOneRemoved).toInt(); }\n    void saveEarDetectionSettings() { m_settings->setValue(\"earDetection/setting\", mediaController->getEarDetectionBehavior()); }\n\n    bool loadNotificationsEnabled() const { return m_settings->value(\"notifications/enabled\", true).toBool(); }\n    void saveNotificationsEnabled(bool enabled) { m_settings->setValue(\"notifications/enabled\", enabled); }\n\n    int loadRetryAttempts() const { return m_settings->value(\"bluetooth/retryAttempts\", 3).toInt(); }\n    void saveRetryAttempts(int attempts) { m_settings->setValue(\"bluetooth/retryAttempts\", attempts); }\n\n    void onSystemGoingToSleep()\n    {\n        if (m_bleManager->isScanning())\n        {\n            LOG_INFO(\"Stopping BLE scan before going to sleep\");\n            m_bleManager->stopScan();\n        }\n    }\n    void onSystemWakingUp()\n    {\n        LOG_INFO(\"System is waking up, starting ble scan\");\n        m_bleManager->startScan();\n    }\n\nprivate slots:\n    void onTrayIconActivated()\n    {\n        QQuickWindow *window = qobject_cast<QQuickWindow *>(\n            QGuiApplication::topLevelWindows().constFirst());\n        if (window)\n        {\n            window->show();\n            window->raise();\n            window->requestActivate();\n        }\n    }\n\n    void onOpenApp()\n    {\n        QObject *rootObject = parent->rootObjects().first();\n        if (rootObject) {\n            QMetaObject::invokeMethod(rootObject, \"reopen\", Q_ARG(QVariant, \"app\"));\n        }\n        else\n        {\n            loadMainModule();\n        }\n    }\n\n    void onOpenSettings()\n    {\n        QObject *rootObject = parent->rootObjects().first();\n        if (rootObject) {\n            QMetaObject::invokeMethod(rootObject, \"reopen\", Q_ARG(QVariant, \"settings\"));\n        }\n        else\n        {\n            loadMainModule();\n        }\n    }\n\n    void sendHandshake() {\n        LOG_INFO(\"Connected to device, sending initial packets\");\n        writePacketToSocket(AirPodsPackets::Connection::HANDSHAKE, \"Handshake packet written: \");\n    }\n\n    void bluezDeviceConnected(const QString &address, const QString &name)\n    {\n        QBluetoothDeviceInfo device(QBluetoothAddress(address), name, 0);\n        connectToDevice(device);\n    }\n\n    void onDeviceDisconnected(const QBluetoothAddress &address)\n    {\n        LOG_INFO(\"Device disconnected: \" << address.toString());\n        if (socket)\n        {\n            LOG_WARN(\"Socket is still open, closing it\");\n            socket->close();\n            socket = nullptr;\n        }\n        if (phoneSocket && phoneSocket->isOpen())\n        {\n            phoneSocket->write(AirPodsPackets::Connection::AIRPODS_DISCONNECTED);\n            LOG_DEBUG(\"AIRPODS_DISCONNECTED packet written: \" << AirPodsPackets::Connection::AIRPODS_DISCONNECTED.toHex());\n        }\n\n        // Clear the device name and model\n        m_deviceInfo->reset();\n        m_bleManager->startScan();\n        emit airPodsStatusChanged();\n\n        // Show system notification\n        trayManager->showNotification(\n            tr(\"AirPods Disconnected\"),\n            tr(\"Your AirPods have been disconnected\"));\n        trayManager->resetTrayIcon();\n    }\n\n    void bluezDeviceDisconnected(const QString &address, const QString &name)\n    {\n        if (address == m_deviceInfo->bluetoothAddress())\n        {\n            onDeviceDisconnected(QBluetoothAddress(address));\n        } else {\n            LOG_WARN(\"Disconnected device does not match connected device: \" << address << \" != \" << m_deviceInfo->bluetoothAddress());\n        }\n    }\n\n    void parseMetadata(const QByteArray &data)\n    {\n        // Verify the data starts with the METADATA header\n        if (!data.startsWith(AirPodsPackets::Parse::METADATA))\n        {\n            LOG_ERROR(\"Invalid metadata packet: Incorrect header\");\n            return;\n        }\n\n        int pos = AirPodsPackets::Parse::METADATA.size(); // Start after the header\n\n        // Check if there is enough data to skip the initial bytes (based on example structure)\n        if (data.size() < pos + 6)\n        {\n            LOG_ERROR(\"Metadata packet too short to parse initial bytes\");\n            return;\n        }\n        pos += 6; // Skip 6 bytes after the header as per example structure\n\n        auto extractString = [&data, &pos]() -> QString\n        {\n            if (pos >= data.size())\n            {\n                return QString();\n            }\n            int start = pos;\n            while (pos < data.size() && data.at(pos) != '\\0')\n            {\n                ++pos;\n            }\n            QString str = QString::fromUtf8(data.mid(start, pos - start));\n            if (pos < data.size())\n            {\n                ++pos; // Move past the null terminator\n            }\n            return str;\n        };\n\n        m_deviceInfo->setDeviceName(extractString());\n        m_deviceInfo->setModelNumber(extractString());\n        m_deviceInfo->setManufacturer(extractString());\n\n        m_deviceInfo->setModel(parseModelNumber(m_deviceInfo->modelNumber()));\n        emit modelChanged();\n\n        // Log extracted metadata\n        LOG_INFO(\"Parsed AirPods metadata:\");\n        LOG_INFO(\"Device Name: \" << m_deviceInfo->deviceName());\n        LOG_INFO(\"Model Number: \" << m_deviceInfo->modelNumber());\n        LOG_INFO(\"Manufacturer: \" << m_deviceInfo->manufacturer());\n    }\n\n    QString getEarStatus(char value)\n    {\n        return (value == 0x00) ? \"In Ear\" : (value == 0x01) ? \"Out of Ear\"\n                                                            : \"In case\";\n    }\n\n    void connectToDevice(const QBluetoothDeviceInfo &device)\n    {\n        if (socket && socket->isOpen() && socket->peerAddress() == device.address())\n        {\n            LOG_INFO(\"Already connected to the device: \" << device.name());\n            return;\n        }\n\n        LOG_INFO(\"Connecting to device: \" << device.name());\n\n        // Clean up any existing socket\n        if (socket)\n        {\n            socket->close();\n            socket->deleteLater();\n            socket = nullptr;\n        }\n\n        QBluetoothSocket *localSocket = new QBluetoothSocket(QBluetoothServiceInfo::L2capProtocol);\n        socket = localSocket;\n\n        // Connection handler\n        auto handleConnection = [this, localSocket]()\n        {\n            connect(localSocket, &QBluetoothSocket::readyRead, this, [this, localSocket]()\n                    {\n            QByteArray data = localSocket->readAll();\n            QMetaObject::invokeMethod(this, \"parseData\", Qt::QueuedConnection, Q_ARG(QByteArray, data));\n            QMetaObject::invokeMethod(this, \"relayPacketToPhone\", Qt::QueuedConnection, Q_ARG(QByteArray, data)); });\n            sendHandshake();\n        };\n\n        // Error handler with retry\n        auto handleError = [this, device, localSocket](QBluetoothSocket::SocketError error)\n        {\n            LOG_ERROR(\"Socket error: \" << error << \", \" << localSocket->errorString());\n\n            static int retryCount = 0;\n            if (retryCount < m_retryAttempts)\n            {\n                retryCount++;\n                LOG_INFO(\"Retrying connection (attempt \" << retryCount << \")\");\n                QTimer::singleShot(1500, this, [this, device]()\n                                   { connectToDevice(device); });\n            }\n            else\n            {\n                LOG_ERROR(\"Failed to connect after 3 attempts\");\n                retryCount = 0;\n            }\n        };\n\n        connect(localSocket, &QBluetoothSocket::connected, this, handleConnection);\n        connect(localSocket, QOverload<QBluetoothSocket::SocketError>::of(&QBluetoothSocket::errorOccurred),\n                this, handleError);\n\n        localSocket->connectToService(device.address(), QBluetoothUuid(\"74ec2172-0bad-4d01-8f77-997b2be0722a\"));\n        m_deviceInfo->setBluetoothAddress(device.address().toString());\n        notifyAndroidDevice();\n    }\n\n    void parseData(const QByteArray &data)\n    {\n        LOG_DEBUG(\"Received: \" << data.toHex());\n\n        if (data.startsWith(AirPodsPackets::Parse::HANDSHAKE_ACK))\n        {\n            writePacketToSocket(AirPodsPackets::Connection::SET_SPECIFIC_FEATURES, \"Set specific features packet written: \");\n        }\n        else if (data.startsWith(AirPodsPackets::Parse::FEATURES_ACK))\n        {\n            writePacketToSocket(AirPodsPackets::Connection::REQUEST_NOTIFICATIONS, \"Request notifications packet written: \");\n            \n            QTimer::singleShot(2000, this, [this]() {\n                if (m_deviceInfo->batteryStatus().isEmpty()) {\n                    writePacketToSocket(AirPodsPackets::Connection::REQUEST_NOTIFICATIONS, \"Request notifications packet written: \");\n                }\n            });\n        }\n        // Magic Cloud Keys Response\n        else if (data.startsWith(AirPodsPackets::MagicPairing::MAGIC_CLOUD_KEYS_HEADER))\n        {\n            auto keys = AirPodsPackets::MagicPairing::parseMagicCloudKeysPacket(data);\n            LOG_INFO(\"Received Magic Cloud Keys:\");\n            LOG_INFO(\"MagicAccIRK: \" << keys.magicAccIRK.toHex());\n            LOG_INFO(\"MagicAccEncKey: \" << keys.magicAccEncKey.toHex());\n\n            // Store the keys\n            m_deviceInfo->setMagicAccIRK(keys.magicAccIRK);\n            m_deviceInfo->setMagicAccEncKey(keys.magicAccEncKey);\n            m_deviceInfo->saveToSettings(*m_settings);\n        }\n        // Get CA state\n        else if (data.startsWith(AirPodsPackets::ConversationalAwareness::HEADER)) {\n            if (auto result = AirPodsPackets::ConversationalAwareness::parseState(data))\n            {\n                m_deviceInfo->setConversationalAwareness(result.value());\n                LOG_INFO(\"Conversational awareness state received: \" << m_deviceInfo->conversationalAwareness());\n            }\n        }\n        // Noise Control Mode\n        else if (data.size() == 11 && data.startsWith(AirPodsPackets::NoiseControl::HEADER))\n        {\n            if (auto value = AirPodsPackets::NoiseControl::parseMode(data))\n            {\n                m_deviceInfo->setNoiseControlMode(value.value());\n                LOG_INFO(\"Noise control mode received: \" << m_deviceInfo->noiseControlMode());\n            }\n        }\n        // Ear Detection\n        else if (data.size() == 8 && data.startsWith(AirPodsPackets::Parse::EAR_DETECTION))\n        {\n            m_deviceInfo->getEarDetection()->parseData(data);\n            mediaController->handleEarDetection(m_deviceInfo->getEarDetection());\n        }\n        // Battery Status\n        else if (data.size() == 22 && data.startsWith(AirPodsPackets::Parse::BATTERY_STATUS))\n        {\n            m_deviceInfo->getBattery()->parsePacket(data);\n            m_deviceInfo->updateBatteryStatus();\n            LOG_INFO(\"Battery status: \" << m_deviceInfo->batteryStatus());\n        }\n        // Conversational Awareness Data\n        else if (data.size() == 10 && data.startsWith(AirPodsPackets::ConversationalAwareness::DATA_HEADER))\n        {\n            LOG_INFO(\"Received conversational awareness data\");\n            mediaController->handleConversationalAwareness(data);\n        }\n        else if (data.startsWith(AirPodsPackets::Parse::METADATA))\n        {\n            parseMetadata(data);\n            initiateMagicPairing();\n            mediaController->setConnectedDeviceMacAddress(m_deviceInfo->bluetoothAddress().replace(\":\", \"_\"));\n            if (m_deviceInfo->getEarDetection()->oneOrMorePodsInEar()) // AirPods get added as output device only after this\n            {\n                mediaController->activateA2dpProfile();\n            }\n            m_bleManager->stopScan();\n            emit airPodsStatusChanged();\n        }\n        else if (data.startsWith(AirPodsPackets::OneBudANCMode::HEADER)) {\n            if (auto value = AirPodsPackets::OneBudANCMode::parseState(data))\n            {\n                m_deviceInfo->setOneBudANCMode(value.value());\n                LOG_INFO(\"One Bud ANC mode received: \" << m_deviceInfo->oneBudANCMode());\n            }\n        }\n        else\n        {\n            LOG_DEBUG(\"Unrecognized packet format: \" << data.toHex());\n        }\n    }\n\n    void connectToPhone() {\n        if (!CrossDevice.isEnabled) {\n            return;\n        }\n\n        if (phoneSocket && phoneSocket->isOpen()) {\n            LOG_INFO(\"Already connected to the phone\");\n            return;\n        }\n        QBluetoothAddress phoneAddress(\"00:00:00:00:00:00\"); // Default address, will be overwritten if PHONE_MAC_ADDRESS is set\n        QProcessEnvironment env = QProcessEnvironment::systemEnvironment();\n        \n        if (!env.value(\"PHONE_MAC_ADDRESS\").isEmpty())\n        {\n            phoneAddress = QBluetoothAddress(env.value(\"PHONE_MAC_ADDRESS\"));\n        }\n        phoneSocket = new QBluetoothSocket(QBluetoothServiceInfo::L2capProtocol);\n        connect(phoneSocket, &QBluetoothSocket::connected, this, [this]() {\n            LOG_INFO(\"Connected to phone\");\n            if (!lastBatteryStatus.isEmpty()) {\n                phoneSocket->write(lastBatteryStatus);\n                LOG_DEBUG(\"Sent last battery status to phone: \" << lastBatteryStatus.toHex());\n            }\n            if (!lastEarDetectionStatus.isEmpty()) {\n                phoneSocket->write(lastEarDetectionStatus);\n                LOG_DEBUG(\"Sent last ear detection status to phone: \" << lastEarDetectionStatus.toHex());\n            }\n        });\n\n        connect(phoneSocket, QOverload<QBluetoothSocket::SocketError>::of(&QBluetoothSocket::errorOccurred), this, [this](QBluetoothSocket::SocketError error) {\n            LOG_ERROR(\"Phone socket error: \" << error << \", \" << phoneSocket->errorString());\n        });\n\n        phoneSocket->connectToService(phoneAddress, QBluetoothUuid(\"1abbb9a4-10e4-4000-a75c-8953c5471342\"));\n    }\n\n    void relayPacketToPhone(const QByteArray &packet)\n    {\n        if (!CrossDevice.isEnabled) {\n            return;\n        }\n        if (phoneSocket && phoneSocket->isOpen())\n        {\n            phoneSocket->write(AirPodsPackets::Phone::NOTIFICATION + packet);\n        }\n        else\n        {\n            connectToPhone();\n            LOG_WARN(\"Phone socket is not open, cannot relay packet\");\n        }\n    }\n\n    void handlePhonePacket(const QByteArray &packet) {\n        if (packet.startsWith(AirPodsPackets::Phone::NOTIFICATION))\n        {\n            QByteArray airpodsPacket = packet.mid(4);\n            if (socket && socket->isOpen()) {\n                socket->write(airpodsPacket);\n                LOG_DEBUG(\"Relayed packet to AirPods: \" << airpodsPacket.toHex());\n            } else {\n                LOG_ERROR(\"Socket is not open, cannot relay packet to AirPods\");\n            }\n        }\n        else if (packet.startsWith(AirPodsPackets::Phone::CONNECTED))\n        {\n            LOG_INFO(\"AirPods connected\");\n            isConnectedLocally = true;\n            CrossDevice.isAvailable = false;\n        }\n        else if (packet.startsWith(AirPodsPackets::Phone::DISCONNECTED))\n        {\n            LOG_INFO(\"AirPods disconnected\");\n            isConnectedLocally = false;\n            CrossDevice.isAvailable = true;\n        }\n        else if (packet.startsWith(AirPodsPackets::Phone::STATUS_REQUEST))\n        {\n            LOG_INFO(\"Connection status request received\");\n            QByteArray response = (socket && socket->isOpen()) ? AirPodsPackets::Phone::CONNECTED\n                                                               : AirPodsPackets::Phone::DISCONNECTED;\n            phoneSocket->write(response);\n            LOG_DEBUG(\"Sent connection status response: \" << response.toHex());\n        }\n        else if (packet.startsWith(AirPodsPackets::Phone::DISCONNECT_REQUEST))\n        {\n            LOG_INFO(\"Disconnect request received\");\n            if (socket && socket->isOpen()) {\n                socket->close();\n                LOG_INFO(\"Disconnected from AirPods\");\n                QProcess process;\n                process.start(\"bluetoothctl\", QStringList() << \"disconnect\" << m_deviceInfo->bluetoothAddress());\n                process.waitForFinished();\n                QString output = process.readAllStandardOutput().trimmed();\n                LOG_INFO(\"Bluetoothctl output: \" << output);\n                isConnectedLocally = false;\n                CrossDevice.isAvailable = true;\n            }\n        }\n        else\n        {\n            if (socket && socket->isOpen()) {\n                socket->write(packet);\n                LOG_DEBUG(\"Relayed packet to AirPods: \" << packet.toHex());\n            } else {\n                LOG_ERROR(\"Socket is not open, cannot relay packet to AirPods\");\n            }\n        }\n    }\n\n    void onPhoneDataReceived() {\n        QByteArray data = phoneSocket->readAll();\n        LOG_DEBUG(\"Data received from phone: \" << data.toHex());\n        QMetaObject::invokeMethod(this, \"handlePhonePacket\", Qt::QueuedConnection, Q_ARG(QByteArray, data));\n    }\n\n    void bleDeviceFound(const BleInfo &device)\n    {\n        if (BLEUtils::isValidIrkRpa(m_deviceInfo->magicAccIRK(), device.address)) {\n            m_deviceInfo->setModel(device.modelName);\n            auto decryptet = BLEUtils::decryptLastBytes(device.encryptedPayload, m_deviceInfo->magicAccEncKey());\n            m_deviceInfo->getBattery()->parseEncryptedPacket(decryptet, device.primaryLeft, device.isThisPodInTheCase);\n            m_deviceInfo->getEarDetection()->overrideEarDetectionStatus(device.isPrimaryInEar, device.isSecondaryInEar);\n        }\n    }\n\npublic:\n    void handleMediaStateChange(MediaController::MediaState state) {\n        if (state == MediaController::MediaState::Playing) {\n            LOG_INFO(\"Media started playing, sending disconnect request to Android and taking over audio\");\n            sendDisconnectRequestToAndroid();\n            connectToAirPods(true);\n        }\n    }\n\n    void sendDisconnectRequestToAndroid()\n    {\n        if (!CrossDevice.isEnabled) return;\n\n        if (phoneSocket && phoneSocket->isOpen())\n        {\n            phoneSocket->write(AirPodsPackets::Phone::DISCONNECT_REQUEST);\n            LOG_DEBUG(\"Sent disconnect request to Android: \" << AirPodsPackets::Phone::DISCONNECT_REQUEST.toHex());\n        }\n        else\n        {\n            LOG_WARN(\"Phone socket is not open, cannot send disconnect request\");\n        }\n    }\n\n    bool isPhoneConnected() {\n        return phoneSocket && phoneSocket->isOpen();\n    }\n\n    void connectToAirPods(bool force) {\n        if (socket && socket->isOpen()) {\n            LOG_INFO(\"Already connected to AirPods\");\n            return;\n        }\n\n        if (force) {\n            LOG_INFO(\"Forcing connection to AirPods\");\n            QProcess process;\n            process.start(\"bluetoothctl\", QStringList() << \"connect\" << m_deviceInfo->bluetoothAddress());\n            process.waitForFinished();\n            QString output = process.readAllStandardOutput().trimmed();\n            LOG_INFO(\"Bluetoothctl output: \" << output);\n        }\n        QBluetoothLocalDevice localDevice;\n        const QList<QBluetoothAddress> connectedDevices = localDevice.connectedDevices();\n        for (const QBluetoothAddress &address : connectedDevices) {\n            QBluetoothDeviceInfo device(address, \"\", 0);\n            LOG_DEBUG(\"Connected device: \" << device.name() << \" (\" << device.address().toString() << \")\");\n            if (isAirPodsDevice(device)) {\n                connectToDevice(device);\n                return;\n            }\n        }\n        LOG_WARN(\"AirPods not found among connected devices\");\n    }\n\n    void initializeBluetooth() {\n        connectToPhone();\n\n        m_deviceInfo->loadFromSettings(*m_settings);\n        if (!areAirpodsConnected()) {\n            m_bleManager->startScan();\n        }\n    }\n\n    void loadMainModule() {\n        parent->load(QUrl(QStringLiteral(\"qrc:/linux/Main.qml\")));\n    }\n\nsignals:\n    void noiseControlModeChanged(NoiseControlMode mode);\n    void earDetectionStatusChanged(const QString &status);\n    void batteryStatusChanged(const QString &status);\n    void conversationalAwarenessChanged(bool enabled);\n    void adaptiveNoiseLevelChanged(int level);\n    void deviceNameChanged(const QString &name);\n    void modelChanged();\n    void primaryChanged();\n    void airPodsStatusChanged();\n    void earDetectionBehaviorChanged(int behavior);\n    void crossDeviceEnabledChanged(bool enabled);\n    void notificationsEnabledChanged(bool enabled);\n    void retryAttemptsChanged(int attempts);\n    void oneBudANCModeChanged(bool enabled);\n    void phoneMacStatusChanged();\n\nprivate:\n    QBluetoothSocket *socket = nullptr;\n    QBluetoothSocket *phoneSocket = nullptr;\n    QByteArray lastBatteryStatus;\n    QByteArray lastEarDetectionStatus;\n    MediaController* mediaController;\n    TrayIconManager *trayManager;\n    BluetoothMonitor *monitor;\n    QSettings *m_settings;\n    AutoStartManager *m_autoStartManager;\n    int m_retryAttempts = 3;\n    bool m_hideOnStart = false;\n    DeviceInfo *m_deviceInfo;\n    BleManager *m_bleManager;\n    SystemSleepMonitor *m_systemSleepMonitor = nullptr;\n    QString m_phoneMacStatus;\n};\n\nint main(int argc, char *argv[]) {\n    QApplication app(argc, argv);\n\n    QSharedMemory sharedMemory;\n    sharedMemory.setKey(\"TcpServer-Key\");\n\n    // Check if app is already open\n    if(sharedMemory.create(1) == false) \n    {\n        LOG_INFO(\"Another instance already running! Opening App Window Instead\");\n        QLocalSocket socket;\n        // Connect to the original app, then trigger the reopen signal\n        socket.connectToServer(\"app_server\");\n        if (socket.waitForConnected(500)) {\n            socket.write(\"reopen\");\n            socket.flush();\n            socket.waitForBytesWritten(500);\n            socket.disconnectFromServer();\n            app.exit(); // exit; process already running\n            return 0;\n        }\n        else\n        {\n            // Failed connection, log and open the app (assume it's not running)\n            LOG_ERROR(\"Failed to connect to the original app instance. Assuming it is not running.\");\n            LOG_DEBUG(\"Socket error: \" << socket.errorString());\n        }\n    }\n    app.setQuitOnLastWindowClosed(false);\n\n    bool debugMode = false;\n    bool hideOnStart = false;\n    for (int i = 1; i < argc; ++i) {\n        if (QString(argv[i]) == \"--debug\")\n            debugMode = true;\n\n        if (QString(argv[i]) == \"--hide\")\n            hideOnStart = true;\n    }\n\n    QQmlApplicationEngine engine;\n    qmlRegisterType<Battery>(\"me.kavishdevar.Battery\", 1, 0, \"Battery\");\n    qmlRegisterType<DeviceInfo>(\"me.kavishdevar.DeviceInfo\", 1, 0, \"DeviceInfo\");\n    AirPodsTrayApp *trayApp = new AirPodsTrayApp(debugMode, hideOnStart, &engine);\n    engine.rootContext()->setContextProperty(\"airPodsTrayApp\", trayApp);\n\n    // Expose PHONE_MAC_ADDRESS environment variable to QML for placeholder in settings\n    {\n        QProcessEnvironment env = QProcessEnvironment::systemEnvironment();\n        QString phoneMacEnv = env.value(\"PHONE_MAC_ADDRESS\", \"\");\n        engine.rootContext()->setContextProperty(\"PHONE_MAC_ADDRESS\", phoneMacEnv);\n        // Initialize the visible status in the GUI\n        trayApp->updatePhoneMacStatus(phoneMacEnv.isEmpty() ? QStringLiteral(\"No phone MAC set\") : phoneMacEnv);\n    }\n\n    engine.addImageProvider(\"qrcode\", new QRCodeImageProvider());\n    trayApp->loadMainModule();\n\n    QLocalServer server;\n    QLocalServer::removeServer(\"app_server\");\n\n    if (!server.listen(\"app_server\"))\n    {\n        LOG_ERROR(\"Unable to start the listening server\");\n        LOG_DEBUG(\"Server error: \" << server.errorString());\n    }\n    else\n    {\n        LOG_DEBUG(\"Server started, waiting for connections...\");\n    }\n    QObject::connect(&server, &QLocalServer::newConnection, [&]() {\n        QLocalSocket* socket = server.nextPendingConnection();\n        // Handles Proper Connection\n        QObject::connect(socket, &QLocalSocket::readyRead, [socket, &engine, &trayApp]() {\n            QString msg = socket->readAll();\n            // Check if the message is \"reopen\", if so, trigger onOpenApp function\n            if (msg == \"reopen\") {\n                LOG_INFO(\"Reopening app window\");\n                QObject *rootObject = engine.rootObjects().first();\n                if (rootObject) {\n                    QMetaObject::invokeMethod(rootObject, \"reopen\", Q_ARG(QVariant, \"app\"));\n                }\n                else\n                {\n                    trayApp->loadMainModule();\n                }\n            }\n            else\n            {\n                LOG_ERROR(\"Unknown message received: \" << msg);\n            }\n            socket->disconnectFromServer();\n        });\n        // Handles connection errors\n        QObject::connect(socket, &QLocalSocket::errorOccurred, [socket]() {\n            LOG_ERROR(\"Failed to connect to the duplicate app instance\");\n            LOG_DEBUG(\"Connection error: \" << socket->errorString());\n        });\n        \n        // Handle server-level errors\n        QObject::connect(&server, &QLocalServer::serverError, [&]() {\n            LOG_ERROR(\"Server failed to accept a new connection\");\n            LOG_DEBUG(\"Server error: \" << server.errorString());\n        });\n    });\n\n    QObject::connect(&app, &QCoreApplication::aboutToQuit, [&]() {\n        "
        }
      ]
    },
    {
      "dir": "linux/ble",
      "files": [
        {
          "name": "blemanager.h",
          "ext": ".h",
          "size": 2307,
          "preview": "#ifndef BLEMANAGER_H\n#define BLEMANAGER_H\n\n#include <QObject>\n#include <QBluetoothDeviceDiscoveryAgent>\n#include <QMap>\n#include <QString>\n#include <QDateTime>\n#include \"enums.h\"\n\nclass QTimer;\n\nclass BleInfo\n{\npublic:\n    QString name;\n    QString address;\n    int leftPodBattery = -1; // -1 indicates not available\n    int rightPodBattery = -1;\n    int caseBattery = -1;\n    bool leftCharging = false;\n    bool rightCharging = false;\n    bool caseCharging = false;\n    AirpodsTrayApp::Enums::AirPodsModel modelName = AirpodsTrayApp::Enums::AirPodsModel::Unknown;\n    quint8 lidOpenCounter = 0;\n    QString color = \"Unknown\"; // Default color\n    quint8 status = 0;\n    QByteArray rawData;\n    QByteArray encryptedPayload; // 16 bytes of encrypted payload\n\n    // Additional status flags from Kotlin version\n    bool isLeftPodInEar = false;\n    bool isRightPodInEar = false;\n    bool isPrimaryInEar = false;\n    bool isSecondaryInEar = false;\n    bool isLeftPodMicrophone = false;\n    bool isRightPodMicrophone = false;\n    bool isThisPodInTheCase = false;\n    bool isOnePodInCase = false;\n    bool areBothPodsInCase = false;\n    bool primaryLeft = true; // True if left pod is primary, false if right pod is primary\n\n    // Lid state enumeration\n    enum class LidState\n    {\n        OPEN = 0x0,\n        CLOSED = 0x1,\n        UNKNOWN,\n    } lidState = LidState::UNKNOWN;\n\n    // Connection state enumeration\n    enum class ConnectionState : uint8_t\n    {\n        DISCONNECTED = 0x00,\n        IDLE = 0x04,\n        MUSIC = 0x05,\n        CALL = 0x06,\n        RINGING = 0x07,\n        HANGING_UP = 0x09,\n        UNKNOWN = 0xFF // Using 0xFF for representing null in the original\n    } connectionState = ConnectionState::UNKNOWN;\n\n    QDateTime lastSeen; // Timestamp of last detection\n};\n\nclass BleManager : public QObject\n{\n    Q_OBJECT\npublic:\n    explicit BleManager(QObject *parent = nullptr);\n    ~BleManager();\n\n    void startScan();\n    void stopScan();\n    bool isScanning() const;\n\nprivate slots:\n    void onDeviceDiscovered(const QBluetoothDeviceInfo &info);\n    void onScanFinished();\n    void onErrorOccurred(QBluetoothDeviceDiscoveryAgent::Error error);\n\nsignals:\n    void deviceFound(const BleInfo &device);\n\nprivate:\n    QBluetoothDeviceDiscoveryAgent *discoveryAgent;\n};\n\n#endif // BLEMANAGER_H"
        },
        {
          "name": "blemanager.cpp",
          "ext": ".cpp",
          "size": 8644,
          "preview": "#include \"blemanager.h\"\n#include \"enums.h\"\n#include <QDebug>\n#include <QTimer>\n#include \"logger.h\"\n#include <QMap>\n\nAirpodsTrayApp::Enums::AirPodsModel getModelName(quint16 modelId)\n{\n    using namespace AirpodsTrayApp::Enums;\n    static const QMap<quint16, AirPodsModel> modelMap = {\n        {0x0220, AirPodsModel::AirPods1},\n        {0x0F20, AirPodsModel::AirPods2},\n        {0x1320, AirPodsModel::AirPods3},\n        {0x1920, AirPodsModel::AirPods4},\n        {0x1B20, AirPodsModel::AirPods4ANC},\n        {0x0A20, AirPodsModel::AirPodsMaxLightning},\n        {0x1F20, AirPodsModel::AirPodsMaxUSBC},\n        {0x0E20, AirPodsModel::AirPodsPro},\n        {0x1420, AirPodsModel::AirPodsPro2Lightning},\n        {0x2420, AirPodsModel::AirPodsPro2USBC}\n    };\n\n    return modelMap.value(modelId, AirPodsModel::Unknown);\n}\n\nQString getColorName(quint8 colorId)\n{\n    switch (colorId)\n    {\n    case 0x00:\n        return \"White\";\n    case 0x01:\n        return \"Black\";\n    case 0x02:\n        return \"Red\";\n    case 0x03:\n        return \"Blue\";\n    case 0x04:\n        return \"Pink\";\n    case 0x05:\n        return \"Gray\";\n    case 0x06:\n        return \"Silver\";\n    case 0x07:\n        return \"Gold\";\n    case 0x08:\n        return \"Rose Gold\";\n    case 0x09:\n        return \"Space Gray\";\n    case 0x0A:\n        return \"Dark Blue\";\n    case 0x0B:\n        return \"Light Blue\";\n    case 0x0C:\n        return \"Yellow\";\n    default:\n        return \"Unknown\";\n    }\n}\n\nQString getConnectionStateName(BleInfo::ConnectionState state)\n{\n    using ConnectionState = BleInfo::ConnectionState;\n    switch (state)\n    {\n    case ConnectionState::DISCONNECTED:\n        return QString(\"Disconnected\");\n    case ConnectionState::IDLE:\n        return QString(\"Idle\");\n    case ConnectionState::MUSIC:\n        return QString(\"Playing Music\");\n    case ConnectionState::CALL:\n        return QString(\"On Call\");\n    case ConnectionState::RINGING:\n        return QString(\"Ringing\");\n    case ConnectionState::HANGING_UP:\n        return QString(\"Hanging Up\");\n    case ConnectionState::UNKNOWN:\n    default:\n        return QString(\"Unknown\");\n    }\n}\n\nBleManager::BleManager(QObject *parent) : QObject(parent)\n{\n    discoveryAgent = new QBluetoothDeviceDiscoveryAgent(this);\n    discoveryAgent->setLowEnergyDiscoveryTimeout(0); // Continuous scanning\n\n    connect(discoveryAgent, &QBluetoothDeviceDiscoveryAgent::deviceDiscovered,\n            this, &BleManager::onDeviceDiscovered);\n    connect(discoveryAgent, &QBluetoothDeviceDiscoveryAgent::finished,\n            this, &BleManager::onScanFinished);\n    connect(discoveryAgent, &QBluetoothDeviceDiscoveryAgent::errorOccurred,\n            this, &BleManager::onErrorOccurred);\n}\n\nBleManager::~BleManager()\n{\n    delete discoveryAgent;\n}\n\nvoid BleManager::startScan()\n{\n    LOG_DEBUG(\"Starting BLE scan...\");\n    discoveryAgent->start(QBluetoothDeviceDiscoveryAgent::LowEnergyMethod);\n}\n\nvoid BleManager::stopScan()\n{\n    LOG_DEBUG(\"Stopping BLE scan...\");\n    discoveryAgent->stop();\n}\n\nbool BleManager::isScanning() const\n{\n    return discoveryAgent->isActive();\n}\n\nvoid BleManager::onDeviceDiscovered(const QBluetoothDeviceInfo &info)\n{\n    // Check for Apple's manufacturer ID (0x004C)\n    if (info.manufacturerData().contains(0x004C))\n    {\n        QByteArray data = info.manufacturerData().value(0x004C);\n        // Ensure data is long enough and starts with prefix 0x07 (indicates Proximity Pairing Message)\n        if (data.size() >= 10 && data[0] == 0x07)\n        {\n            QString address = info.address().toString();\n            BleInfo deviceInfo;\n            deviceInfo.name = info.name().isEmpty() ? \"AirPods\" : info.name();\n            deviceInfo.address = address;\n            deviceInfo.rawData = data.left(data.size() - 16);\n            deviceInfo.encryptedPayload = data.mid(data.size() - 16);\n\n            // data[1] is the length of the data, so we can skip it\n\n            // Check if pairing mode is paired (0x01) or pairing (0x00)\n            if (data[2] == 0x00)\n            {\n                return; // Skip pairing mode devices (the values are differently structured)\n            }\n\n            \n            // Parse device model (big-endian: high byte at data[3], low byte at data[4])\n            deviceInfo.modelName = getModelName(static_cast<quint16>(data[4]) | (static_cast<quint8>(data[3]) << 8));\n\n            // Status byte for primary pod and other flags\n            quint8 status = static_cast<quint8>(data[5]);\n            deviceInfo.status = status;\n\n            // Pods battery byte (upper nibble: one pod, lower nibble: other pod)\n            quint8 podsBatteryByte = static_cast<quint8>(data[6]);\n\n            // Flags and case battery byte (upper nibble: case battery, lower nibble: flags)\n            quint8 flagsAndCaseBattery = static_cast<quint8>(data[7]);\n\n            // Lid open counter and device color\n            quint8 lidIndicator = static_cast<quint8>(data[8]);\n            deviceInfo.color = getColorName((quint8)(data[9]));\n\n            deviceInfo.connectionState = static_cast<BleInfo::ConnectionState>(data[10]);\n\n            // Next: Encrypted Payload: 16 bytes\n\n            // Determine primary pod (bit 5 of status) and value flipping\n            bool primaryLeft = (status & 0x20) != 0; // Bit 5: 1 = left primary, 0 = right primary\n            bool areValuesFlipped = !primaryLeft;    // Flipped when right pod is primary\n\n            deviceInfo.primaryLeft = primaryLeft; // Store primary pod information\n\n            // Parse battery levels\n            int leftNibble = areValuesFlipped ? (podsBatteryByte >> 4) & 0x0F : podsBatteryByte & 0x0F;\n            int rightNibble = areValuesFlipped ? podsBatteryByte & 0x0F : (podsBatteryByte >> 4) & 0x0F;\n            deviceInfo.leftPodBattery = (leftNibble == 15) ? -1 : leftNibble * 10;\n            deviceInfo.rightPodBattery = (rightNibble == 15) ? -1 : rightNibble * 10;\n            int caseNibble = flagsAndCaseBattery & 0x0F; // Extracts lower nibble\n            deviceInfo.caseBattery = (caseNibble == 15) ? -1 : caseNibble * 10;\n\n            // Parse charging statuses from flags (uper 4 bits of data[7])\n            quint8 flags = (flagsAndCaseBattery >> 4) & 0x0F;                                        // Extracts lower nibble\n            deviceInfo.rightCharging = areValuesFlipped ? (flags & 0x01) != 0 : (flags & 0x02) != 0; // Depending on primary, bit 0 or 1\n            deviceInfo.leftCharging = areValuesFlipped ? (flags & 0x02) != 0 : (flags & 0x01) != 0;  // Depending on primary, bit 1 or 0\n            deviceInfo.caseCharging = (flags & 0x04) != 0;                                           // bit 2\n\n            // Additional status flags from status byte (data[5])\n            deviceInfo.isThisPodInTheCase = (status & 0x40) != 0; // Bit 6\n            deviceInfo.isOnePodInCase = (status & 0x10) != 0;     // Bit 4\n            deviceInfo.areBothPodsInCase = (status & 0x04) != 0;  // Bit 2\n\n            // In-ear detection with XOR logic\n            bool xorFactor = areValuesFlipped ^ deviceInfo.isThisPodInTheCase;\n            deviceInfo.isLeftPodInEar = xorFactor ? (status & 0x08) != 0 : (status & 0x02) != 0;  // Bit 3 or 1\n            deviceInfo.isRightPodInEar = xorFactor ? (status & 0x02) != 0 : (status & 0x08) != 0; // Bit 1 or 3\n\n            // Determine primary and secondary in-ear status\n            deviceInfo.isPrimaryInEar = primaryLeft ? deviceInfo.isLeftPodInEar : deviceInfo.isRightPodInEar;\n            deviceInfo.isSecondaryInEar = primaryLeft ? deviceInfo.isRightPodInEar : deviceInfo.isLeftPodInEar;\n\n            // Microphone status\n            deviceInfo.isLeftPodMicrophone = primaryLeft ^ deviceInfo.isThisPodInTheCase;\n            deviceInfo.isRightPodMicrophone = !primaryLeft ^ deviceInfo.isThisPodInTheCase;\n\n            deviceInfo.lidOpenCounter = lidIndicator & 0x07; // Extract bits 0-2 (count)\n            quint8 lidState = static_cast<quint8>((lidIndicator >> 3) & 0x01); // Extract bit 3 (lid state)\n            if (deviceInfo.isThisPodInTheCase) {\n                deviceInfo.lidState = static_cast<BleInfo::LidState>(lidState);\n            }\n\n            // Update timestamp\n            deviceInfo.lastSeen = QDateTime::currentDateTime();\n\n            emit deviceFound(deviceInfo); // Emit signal for device found\n        }\n    }\n}\n\nvoid BleManager::onScanFinished()\n{\n    if (discoveryAgent->isActive())\n    {\n        discoveryAgent->start(QBluetoothDeviceDiscoveryAgent::LowEnergyMethod);\n    }\n}\n\nvoid BleManager::onErrorOccurred(QBluetoothDeviceDiscoveryAgent::Error error)\n{\n    LOG_ERROR(\"BLE scan error occurred:\" << error);\n    stopScan();\n}\n"
        },
        {
          "name": "bleutils.h",
          "ext": ".h",
          "size": 1858,
          "preview": "#pragma once\n\n#include <QObject>\n#include <QByteArray>\n\nclass BLEUtils : public QObject\n{\n    Q_OBJECT\npublic:\n    explicit BLEUtils(QObject *parent = nullptr);\n\n    /**\n     * @brief Verifies if the provided Bluetooth address is an RPA that matches the given Identity Resolving Key (IRK)\n     * @param address The Bluetooth address to verify\n     * @param irk The Identity Resolving Key to use for verification\n     * @return true if the address is verified as an RPA matching the IRK\n     */\n    static bool verifyRPA(const QString &address, const QByteArray &irk);\n\n    /**\n     * @brief Checks if the given IRK and RPA are valid\n     * @param irk The Identity Resolving Key\n     * @param rpa The Resolvable Private Address\n     * @return true if the RPA is valid for the given IRK\n     */\n    Q_INVOKABLE static bool isValidIrkRpa(const QByteArray &irk, const QString &rpa);\n\n    /**\n     * @brief Decrypts the last 16 bytes of the input data using the provided key with AES-128 ECB\n     * @param data The input data containing at least 16 bytes\n     * @param key The 16-byte key for decryption\n     * @return The decrypted 16 bytes, or an empty QByteArray on failure\n     */\n    static QByteArray decryptLastBytes(const QByteArray &data, const QByteArray &key);\n\nprivate:\n    /**\n     * @brief Performs E function (AES-128) as specified in Bluetooth Core Specification\n     * @param key The key for encryption\n     * @param data The data to encrypt\n     * @return The encrypted data\n     */\n    static QByteArray e(const QByteArray &key, const QByteArray &data);\n\n    /**\n     * @brief Performs the ah function as specified in Bluetooth Core Specification\n     * @param k The IRK key\n     * @param r The random part of the address\n     * @return The hash part of the address\n     */\n    static QByteArray ah(const QByteArray &k, const QByteArray &r);\n};"
        },
        {
          "name": "bleutils.cpp",
          "ext": ".cpp",
          "size": 3538,
          "preview": "#include <openssl/aes.h>\n#include \"deviceinfo.hpp\"\n#include \"bleutils.h\"\n#include <QDebug>\n#include <QByteArray>\n#include <QtEndian>\n#include <QCryptographicHash>\n#include <cstring> // For memset\n\nBLEUtils::BLEUtils(QObject *parent) : QObject(parent)\n{\n}\n\nbool BLEUtils::verifyRPA(const QString &address, const QByteArray &irk)\n{\n    if (address.isEmpty() || irk.isEmpty() || irk.size() != 16)\n    {\n        return false;\n    }\n\n    // Split address into bytes and reverse order\n    QStringList parts = address.split(':');\n    if (parts.size() != 6)\n    {\n        return false;\n    }\n\n    QByteArray rpa;\n    bool ok;\n    for (int i = parts.size() - 1; i >= 0; --i)\n    {\n        rpa.append(static_cast<char>(parts[i].toInt(&ok, 16)));\n        if (!ok)\n        {\n            return false;\n        }\n    }\n\n    if (rpa.size() != 6)\n    {\n        return false;\n    }\n\n    QByteArray prand = rpa.mid(3, 3);\n    QByteArray hash = rpa.left(3);\n    QByteArray computedHash = ah(irk, prand);\n\n    return hash == computedHash;\n}\n\nbool BLEUtils::isValidIrkRpa(const QByteArray &irk, const QString &rpa)\n{\n    return verifyRPA(rpa, irk);\n}\n\nQByteArray BLEUtils::e(const QByteArray &key, const QByteArray &data)\n{\n    if (key.size() != 16 || data.size() != 16)\n    {\n        return QByteArray();\n    }\n\n    // Prepare key and data (needs to be reversed)\n    QByteArray reversedKey(key);\n    std::reverse(reversedKey.begin(), reversedKey.end());\n\n    QByteArray reversedData(data);\n    std::reverse(reversedData.begin(), reversedData.end());\n\n    // Set up AES encryption\n    AES_KEY aesKey;\n    if (AES_set_encrypt_key(reinterpret_cast<const unsigned char *>(reversedKey.constData()), 128, &aesKey) != 0)\n    {\n        return QByteArray();\n    }\n\n    unsigned char out[16];\n    AES_encrypt(reinterpret_cast<const unsigned char *>(reversedData.constData()), out, &aesKey);\n\n    // Convert output to QByteArray and reverse it\n    QByteArray result(reinterpret_cast<char *>(out), 16);\n    std::reverse(result.begin(), result.end());\n\n    return result;\n}\n\nQByteArray BLEUtils::ah(const QByteArray &k, const QByteArray &r)\n{\n    if (r.size() < 3)\n    {\n        return QByteArray();\n    }\n\n    // Pad the random part to 16 bytes\n    QByteArray rPadded(16, 0);\n    rPadded.replace(0, 3, r.left(3));\n\n    QByteArray encrypted = e(k, rPadded);\n    if (encrypted.isEmpty())\n    {\n        return QByteArray();\n    }\n\n    return encrypted.left(3);\n}\n\nQByteArray BLEUtils::decryptLastBytes(const QByteArray &data, const QByteArray &key)\n{\n    if (data.size() < 16 || key.size() != 16)\n    {\n        qDebug() << \"Invalid input: data size < 16 or key size != 16\";\n        return QByteArray();\n    }\n\n    // Extract the last 16 bytes\n    QByteArray block = data.right(16);\n\n    // Set up AES decryption key (use key directly, no reversal)\n    AES_KEY aesKey;\n    if (AES_set_decrypt_key(reinterpret_cast<const unsigned char *>(key.constData()), 128, &aesKey) != 0)\n    {\n        qDebug() << \"Failed to set AES decryption key\";\n        return QByteArray();\n    }\n\n    unsigned char out[16];\n    unsigned char iv[16];\n    memset(iv, 0, 16); // Zero IV for CBC mode\n\n    // Perform AES decryption using CBC mode with zero IV\n    // AES_cbc_encrypt is used for both encryption and decryption depending on the key schedule\n    AES_cbc_encrypt(reinterpret_cast<const unsigned char *>(block.constData()), out, 16, &aesKey, iv, AES_DECRYPT);\n\n    // Convert output to QByteArray (no reversal)\n    QByteArray result(reinterpret_cast<char *>(out), 16);\n\n    return result;\n}"
        }
      ]
    },
    {
      "dir": "linux/thirdparty",
      "files": []
    },
    {
      "dir": "linux/thirdparty/QR-Code-generator",
      "files": [
        {
          "name": "qrcodegen.hpp",
          "ext": ".hpp",
          "size": 20431,
          "preview": "/* \n * QR Code generator library (C++)\n * \n * Copyright (c) Project Nayuki. (MIT License)\n * https://www.nayuki.io/page/qr-code-generator-library\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n * - The above copyright notice and this permission notice shall be included in\n *   all copies or substantial portions of the Software.\n * - The Software is provided \"as is\", without warranty of any kind, express or\n *   implied, including but not limited to the warranties of merchantability,\n *   fitness for a particular purpose and noninfringement. In no event shall the\n *   authors or copyright holders be liable for any claim, damages or other\n *   liability, whether in an action of contract, tort or otherwise, arising from,\n *   out of or in connection with the Software or the use or other dealings in the\n *   Software.\n */\n\n#pragma once\n\n#include <array>\n#include <cstdint>\n#include <stdexcept>\n#include <string>\n#include <vector>\n\n\nnamespace qrcodegen {\n\n/* \n * A segment of character/binary/control data in a QR Code symbol.\n * Instances of this class are immutable.\n * The mid-level way to create a segment is to take the payload data\n * and call a static factory function such as QrSegment::makeNumeric().\n * The low-level way to create a segment is to custom-make the bit buffer\n * and call the QrSegment() constructor with appropriate values.\n * This segment class imposes no length restrictions, but QR Codes have restrictions.\n * Even in the most favorable conditions, a QR Code can only hold 7089 characters of data.\n * Any segment longer than this is meaningless for the purpose of generating QR Codes.\n */\nclass QrSegment final {\n\t\n\t/*---- Public helper enumeration ----*/\n\t\n\t/* \n\t * Describes how a segment's data bits are interpreted. Immutable.\n\t */\n\tpublic: class Mode final {\n\t\t\n\t\t/*-- Constants --*/\n\t\t\n\t\tpublic: static const Mode NUMERIC;\n\t\tpublic: static const Mode ALPHANUMERIC;\n\t\tpublic: static const Mode BYTE;\n\t\tpublic: static const Mode KANJI;\n\t\tpublic: static const Mode ECI;\n\t\t\n\t\t\n\t\t/*-- Fields --*/\n\t\t\n\t\t// The mode indicator bits, which is a uint4 value (range 0 to 15).\n\t\tprivate: int modeBits;\n\t\t\n\t\t// Number of character count bits for three different version ranges.\n\t\tprivate: int numBitsCharCount[3];\n\t\t\n\t\t\n\t\t/*-- Constructor --*/\n\t\t\n\t\tprivate: Mode(int mode, int cc0, int cc1, int cc2);\n\t\t\n\t\t\n\t\t/*-- Methods --*/\n\t\t\n\t\t/* \n\t\t * (Package-private) Returns the mode indicator bits, which is an unsigned 4-bit value (range 0 to 15).\n\t\t */\n\t\tpublic: int getModeBits() const;\n\t\t\n\t\t/* \n\t\t * (Package-private) Returns the bit width of the character count field for a segment in\n\t\t * this mode in a QR Code at the given version number. The result is in the range [0, 16].\n\t\t */\n\t\tpublic: int numCharCountBits(int ver) const;\n\t\t\n\t};\n\t\n\t\n\t\n\t/*---- Static factory functions (mid level) ----*/\n\t\n\t/* \n\t * Returns a segment representing the given binary data encoded in\n\t * byte mode. All input byte vectors are acceptable. Any text string\n\t * can be converted to UTF-8 bytes and encoded as a byte mode segment.\n\t */\n\tpublic: static QrSegment makeBytes(const std::vector<std::uint8_t> &data);\n\t\n\t\n\t/* \n\t * Returns a segment representing the given string of decimal digits encoded in numeric mode.\n\t */\n\tpublic: static QrSegment makeNumeric(const char *digits);\n\t\n\t\n\t/* \n\t * Returns a segment representing the given text string encoded in alphanumeric mode.\n\t * The characters allowed are: 0 to 9, A to Z (uppercase only), space,\n\t * dollar, percent, asterisk, plus, hyphen, period, slash, colon.\n\t */\n\tpublic: static QrSegment makeAlphanumeric(const char *text);\n\t\n\t\n\t/* \n\t * Returns a list of zero or more segments to represent the given text string. The result\n\t * may use various segment modes and switch modes to optimize the length of the bit stream.\n\t */\n\tpublic: static std::vector<QrSegment> makeSegments(const char *text);\n\t\n\t\n\t/* \n\t * Returns a segment representing an Extended Channel Interpretation\n\t * (ECI) designator with the given assignment value.\n\t */\n\tpublic: static QrSegment makeEci(long assignVal);\n\t\n\t\n\t/*---- Public static helper functions ----*/\n\t\n\t/* \n\t * Tests whether the given string can be encoded as a segment in numeric mode.\n\t * A string is encodable iff each character is in the range 0 to 9.\n\t */\n\tpublic: static bool isNumeric(const char *text);\n\t\n\t\n\t/* \n\t * Tests whether the given string can be encoded as a segment in alphanumeric mode.\n\t * A string is encodable iff each character is in the following set: 0 to 9, A to Z\n\t * (uppercase only), space, dollar, percent, asterisk, plus, hyphen, period, slash, colon.\n\t */\n\tpublic: static bool isAlphanumeric(const char *text);\n\t\n\t\n\t\n\t/*---- Instance fields ----*/\n\t\n\t/* The mode indicator of this segment. Accessed through getMode(). */\n\tprivate: const Mode *mode;\n\t\n\t/* The length of this segment's unencoded data. Measured in characters for\n\t * numeric/alphanumeric/kanji mode, bytes for byte mode, and 0 for ECI mode.\n\t * Always zero or positive. Not the same as the data's bit length.\n\t * Accessed through getNumChars(). */\n\tprivate: int numChars;\n\t\n\t/* The data bits of this segment. Accessed through getData(). */\n\tprivate: std::vector<bool> data;\n\t\n\t\n\t/*---- Constructors (low level) ----*/\n\t\n\t/* \n\t * Creates a new QR Code segment with the given attributes and data.\n\t * The character count (numCh) must agree with the mode and the bit buffer length,\n\t * but the constraint isn't checked. The given bit buffer is copied and stored.\n\t */\n\tpublic: QrSegment(const Mode &md, int numCh, const std::vector<bool> &dt);\n\t\n\t\n\t/* \n\t * Creates a new QR Code segment with the given parameters and data.\n\t * The character count (numCh) must agree with the mode and the bit buffer length,\n\t * but the constraint isn't checked. The given bit buffer is moved and stored.\n\t */\n\tpublic: QrSegment(const Mode &md, int numCh, std::vector<bool> &&dt);\n\t\n\t\n\t/*---- Methods ----*/\n\t\n\t/* \n\t * Returns the mode field of this segment.\n\t */\n\tpublic: const Mode &getMode() const;\n\t\n\t\n\t/* \n\t * Returns the character count field of this segment.\n\t */\n\tpublic: int getNumChars() const;\n\t\n\t\n\t/* \n\t * Returns the data bits of this segment.\n\t */\n\tpublic: const std::vector<bool> &getData() const;\n\t\n\t\n\t// (Package-private) Calculates the number of bits needed to encode the given segments at\n\t// the given version. Returns a non-negative number if successful. Otherwise returns -1 if a\n\t// segment has too many characters to fit its length field, or the total bits exceeds INT_MAX.\n\tpublic: static int getTotalBits(const std::vector<QrSegment> &segs, int version);\n\t\n\t\n\t/*---- Private constant ----*/\n\t\n\t/* The set of all legal characters in alphanumeric mode, where\n\t * each character value maps to the index in the string. */\n\tprivate: static const char *ALPHANUMERIC_CHARSET;\n\t\n};\n\n\n\n/* \n * A QR Code symbol, which is a type of two-dimension barcode.\n * Invented by Denso Wave and described in the ISO/IEC 18004 standard.\n * Instances of this class represent an immutable square grid of dark and light cells.\n * The class provides static factory functions to create a QR Code from text or binary data.\n * The class covers the QR Code Model 2 specification, supporting all versions (sizes)\n * from 1 to 40, all 4 error correction levels, and 4 character encoding modes.\n * \n * Ways to create a QR Code object:\n * - High level: Take the payload data and call QrCode::encodeText() or QrCode::encodeBinary().\n * - Mid level: Custom-make the list of segments and call QrCode::encodeSegments().\n * - Low level: Custom-make the array of data codeword bytes (including\n *   segment headers and final padding, excluding error correction codewords),\n *   supply the appropriate version number, and call the QrCode() constructor.\n * (Note that all ways require supplying the desired error correction level.)\n */\nclass QrCode final {\n\t\n\t/*---- Public helper enumeration ----*/\n\t\n\t/* \n\t * The error correction level in a QR Code symbol.\n\t */\n\tpublic: enum class Ecc {\n\t\tLOW = 0 ,  // The QR Code can tolerate about  7% erroneous codewords\n\t\tMEDIUM  ,  // The QR Code can tolerate about 15% erroneous codewords\n\t\tQUARTILE,  // The QR Code can tolerate about 25% erroneous codewords\n\t\tHIGH    ,  // The QR Code can tolerate about 30% erroneous codewords\n\t};\n\t\n\t\n\t// Returns a value in the range 0 to 3 (unsigned 2-bit integer).\n\tprivate: static int getFormatBits(Ecc ecl);\n\t\n\t\n\t\n\t/*---- Static factory functions (high level) ----*/\n\t\n\t/* \n\t * Returns a QR Code representing the given Unicode text string at the given error correction level.\n\t * As a conservative upper bound, this function is guaranteed to succeed for strings that have 2953 or fewer\n\t * UTF-8 code units (not Unicode code points) if the low error correction level is used. The smallest possible\n\t * QR Code version is automatically chosen for the output. The ECC level of the result may be higher than\n\t * the ecl argument if it can be done without increasing the version.\n\t */\n\tpublic: static QrCode encodeText(const char *text, Ecc ecl);\n\t\n\t\n\t/* \n\t * Returns a QR Code representing the given binary data at the given error correction level.\n\t * This function always encodes using the binary segment mode, not any text mode. The maximum number of\n\t * bytes allowed is 2953. The smallest possible QR Code version is automatically chosen for the output.\n\t * The ECC level of the result may be higher than the ecl argument if it can be done without increasing the version.\n\t */\n\tpublic: static QrCode encodeBinary(const std::vector<std::uint8_t> &data, Ecc ecl);\n\t\n\t\n\t/*---- Static factory functions (mid level) ----*/\n\t\n\t/* \n\t * Returns a QR Code representing the given segments with the given encoding parameters.\n\t * The smallest possible QR Code version within the given range is automatically\n\t * chosen for the output. Iff boostEcl is true, then the ECC level of the result\n\t * may be higher than the ecl argument if it can be done without increasing the\n\t * version. The mask number is either between 0 to 7 (inclusive) to force that\n\t * mask, or -1 to automatically choose an appropriate mask (which may be slow).\n\t * This function allows the user to create a custom sequence of segments that switches\n\t * between modes (such as alphanumeric and byte) to encode text in less space.\n\t * This is a mid-level API; the high-level API is encodeText() and encodeBinary().\n\t */\n\tpublic: static QrCode encodeSegments(const std::vector<QrSegment> &segs, Ecc ecl,\n\t\tint minVersion=1, int maxVersion=40, int mask=-1, bool boostEcl=true);  // All optional parameters\n\t\n\t\n\t\n\t/*---- Instance fields ----*/\n\t\n\t// Immutable scalar parameters:\n\t\n\t/* The version number of this QR Code, which is between 1 and 40 (inclusive).\n\t * This determines the size of this barcode. */\n\tprivate: int version;\n\t\n\t/* The width and height of this QR Code, measured in modules, between\n\t * 21 and 177 (inclusive). This is equal to version * 4 + 17. */\n\tprivate: int size;\n\t\n\t/* The error correction level used in this QR Code. */\n\tprivate: Ecc errorCorrectionLevel;\n\t\n\t/* The index of the mask pattern used in this QR Code, which is between 0 and 7 (inclusive).\n\t * Even if a QR Code is created with automatic masking requested (mask = -1),\n\t * the resulting object still has a mask value between 0 and 7. */\n\tprivate: int mask;\n\t\n\t// Private grids of modules/pixels, with dimensions of size*size:\n\t\n\t// The modules of this QR Code (false = light, true = dark).\n\t// Immutable after constructor finishes. Accessed through getModule().\n\tprivate: std::vector<std::vector<bool> > modules;\n\t\n\t// Indicates function modules that are not subjected to masking. Discarded when constructor finishes.\n\tprivate: std::vector<std::vector<bool> > isFunction;\n\t\n\t\n\t\n\t/*---- Constructor (low level) ----*/\n\t\n\t/* \n\t * Creates a new QR Code with the given version number,\n\t * error correction level, data codeword bytes, and mask number.\n\t * This is a low-level API that most users should not use directly.\n\t * A mid-level API is the encodeSegments() function.\n\t */\n\tpublic: QrCode(int ver, Ecc ecl, const std::vector<std::uint8_t> &dataCodewords, int msk);\n\t\n\t\n\t\n\t/*---- Public instance methods ----*/\n\t\n\t/* \n\t * Returns this QR Code's version, in the range [1, 40].\n\t */\n\tpublic: int getVersion() const;\n\t\n\t\n\t/* \n\t * Returns this QR Code's size, in the range [21, 177].\n\t */\n\tpublic: int getSize() const;\n\t\n\t\n\t/* \n\t * Returns this QR Code's error correction level.\n\t */\n\tpublic: Ecc getErrorCorrectionLevel() const;\n\t\n\t\n\t/* \n\t * Returns this QR Code's mask, in the range [0, 7].\n\t */\n\tpublic: int getMask() const;\n\t\n\t\n\t/* \n\t * Returns the color of the module (pixel) at the given coordinates, which is false\n\t * for light or true for dark. The top left corner has the coordinates (x=0, y=0).\n\t * If the given coordinates are out of bounds, then false (light) is returned.\n\t */\n\tpublic: bool getModule(int x, int y) const;\n\t\n\t\n\t\n\t/*---- Private helper methods for constructor: Drawing function modules ----*/\n\t\n\t// Reads this object's version field, and draws and marks all function modules.\n\tprivate: void drawFunctionPatterns();\n\t\n\t\n\t// Draws two copies of the format bits (with its own error correction code)\n\t// based on the given mask and this object's error correction level field.\n\tprivate: void drawFormatBits(int msk);\n\t\n\t\n\t// Draws two copies of the version bits (with its own error correction code),\n\t// based on this object's version field, iff 7 <= version <= 40.\n\tprivate: void drawVersion();\n\t\n\t\n\t// Draws a 9*9 finder pattern including the border separator,\n\t// with the center module at (x, y). Modules can be out of bounds.\n\tprivate: void drawFinderPattern(int x, int y);\n\t\n\t\n\t// Draws a 5*5 alignment pattern, with the center module\n\t// at (x, y). All modules must be in bounds.\n\tprivate: void drawAlignmentPattern(int x, int y);\n\t\n\t\n\t// Sets the color of a module and marks it as a function module.\n\t// Only used by the constructor. Coordinates must be in bounds.\n\tprivate: void setFunctionModule(int x, int y, bool isDark);\n\t\n\t\n\t// Returns the color of the module at the given coordinates, which must be in range.\n\tprivate: bool module(int x, int y) const;\n\t\n\t\n\t/*---- Private helper methods for constructor: Codewords and masking ----*/\n\t\n\t// Returns a new byte string representing the given data with the appropriate error correction\n\t// codewords appended to it, based on this object's version and error correction level.\n\tprivate: std::vector<std::uint8_t> addEccAndInterleave(const std::vector<std::uint8_t> &data) const;\n\t\n\t\n\t// Draws the given sequence of 8-bit codewords (data and error correction) onto the entire\n\t// data area of this QR Code. Function modules need to be marked off before this is called.\n\tprivate: void drawCodewords(const std::vector<std::uint8_t> &data);\n\t\n\t\n\t// XORs the codeword modules in this QR Code with the given mask pattern.\n\t// The function modules must be marked and the codeword bits must be drawn\n\t// before masking. Due to the arithmetic of XOR, calling applyMask() with\n\t// the same mask value a second time will undo the mask. A final well-formed\n\t// QR Code needs exactly one (not zero, two, etc.) mask applied.\n\tprivate: void applyMask(int msk);\n\t\n\t\n\t// Calculates and returns the penalty score based on state of this QR Code's current modules.\n\t// This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.\n\tprivate: long getPenaltyScore() const;\n\t\n\t\n\t\n\t/*---- Private helper functions ----*/\n\t\n\t// Returns an ascending list of positions of alignment patterns for this version number.\n\t// Each position is in the range [0,177), and are used on both the x and y axes.\n\t// This could be implemented as lookup table of 40 variable-length lists of unsigned bytes.\n\tprivate: std::vector<int> getAlignmentPatternPositions() const;\n\t\n\t\n\t// Returns the number of data bits that can be stored in a QR Code of the given version number, after\n\t// all function modules are excluded. This includes remainder bits, so it might not be a multiple of 8.\n\t// The result is in the range [208, 29648]. This could be implemented as a 40-entry lookup table.\n\tprivate: static int getNumRawDataModules(int ver);\n\t\n\t\n\t// Returns the number of 8-bit data (i.e. not error correction) codewords contained in any\n\t// QR Code of the given version number and error correction level, with remainder bits discarded.\n\t// This stateless pure function could be implemented as a (40*4)-cell lookup table.\n\tprivate: static int getNumDataCodewords(int ver, Ecc ecl);\n\t\n\t\n\t// Returns a Reed-Solomon ECC generator polynomial for the given degree. This could be\n\t// implemented as a lookup table over all possible parameter values, instead of as an algorithm.\n\tprivate: static std::vector<std::uint8_t> reedSolomonComputeDivisor(int degree);\n\t\n\t\n\t// Returns the Reed-Solomon error correction codeword for the given data and divisor polynomials.\n\tprivate: static std::vector<std::uint8_t> reedSolomonComputeRemainder(const std::vector<std::uint8_t> &data, const std::vector<std::uint8_t> &divisor);\n\t\n\t\n\t// Returns the product of the two given field elements modulo GF(2^8/0x11D).\n\t// All inputs are valid. This could be implemented as a 256*256 lookup table.\n\tprivate: static std::uint8_t reedSolomonMultiply(std::uint8_t x, std::uint8_t y);\n\t\n\t\n\t// Can only be called immediately after a light run is added, and\n\t// returns either 0, 1, or 2. A helper function for getPenaltyScore().\n\tprivate: int finderPenaltyCountPatterns(const std::array<int,7> &runHistory) const;\n\t\n\t\n\t// Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().\n\tprivate: int finderPenaltyTerminateAndCount(bool currentRunColor, int currentRunLength, std::array<int,7> &runHistory) const;\n\t\n\t\n\t// Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().\n\tprivate: void finderPenaltyAddHistory(int currentRunLength, std::array<int,7> &runHistory) const;\n\t\n\t\n\t// Returns true iff the i'th bit of x is set to 1.\n\tprivate: static bool getBit(long x, int i);\n\t\n\t\n\t/*---- Constants and tables ----*/\n\t\n\t// The minimum version number supported in the QR Code Model 2 standard.\n\tpublic: static constexpr int MIN_VERSION =  1;\n\t\n\t// The maximum version number supported in the QR Code Model 2 standard.\n\tpublic: static constexpr int MAX_VERSION = 40;\n\t\n\t\n\t// For use in getPenaltyScore(), when evaluating which mask is best.\n\tprivate: static const int PENALTY_N1;\n\tprivate: static const int PENALTY_N2;\n\tprivate: static const int PENALTY_N3;\n\tprivate: static const int PENALTY_N4;\n\t\n\t\n\tprivate: static const std::int8_t ECC_CODEWORDS_PER_BLOCK[4][41];\n\tprivate: static const std::int8_t NUM_ERROR_CORRECTION_BLOCKS[4][41];\n\t\n};\n\n\n\n/*---- Public exception class ----*/\n\n/* \n * Thrown when the supplied data does not fit any QR Code version. Ways to handle this exception include:\n * - Decrease the error correction level if it was greater than Ecc::LOW.\n * - If the encodeSegments() function was called with a maxVersion argument, then increase\n *   it if it was less than QrCode::MAX_VERSION. (This advice does not apply to the other\n *   factory functions because they search all versions up to QrCode::MAX_VERSION.)\n * - Split the text data into better or optimal segments in order to reduce the number of bits required.\n * - Change the text or binary data to be shorter.\n * - Change the text to fit the character set of a particular segment mode (e.g. alphanumeric).\n * - Propagate the error upward to the caller/user.\n */\nclass data_too_long : public std::length_error {\n\t\n\tpublic: explicit data_too_long(const std::string &msg);\n\t\n};\n\n\n\n/* \n * An appendable sequence of bits (0s and 1s). Mainly used by QrSegment.\n */\nclass BitBuffer final : public std::vector<bool> {\n\t\n\t/*---- Constructor ----*/\n\t\n\t// Creates an empty bit buffer (length 0).\n\tpublic: BitBuffer();\n\t\n\t\n\t\n\t/*---- Method ----*/\n\t\n\t// Appends the given number of low-order bits of the given value\n\t// to this buffer. Requires 0 <= len <= 31 and val < 2^len.\n\tpublic: void appendBits(std::uint32_t val, int len);\n\t\n};\n\n}\n"
        },
        {
          "name": "qrcodegen.cpp",
          "ext": ".cpp",
          "size": 27296,
          "preview": "/* \n * QR Code generator library (C++)\n * \n * Copyright (c) Project Nayuki. (MIT License)\n * https://www.nayuki.io/page/qr-code-generator-library\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n * - The above copyright notice and this permission notice shall be included in\n *   all copies or substantial portions of the Software.\n * - The Software is provided \"as is\", without warranty of any kind, express or\n *   implied, including but not limited to the warranties of merchantability,\n *   fitness for a particular purpose and noninfringement. In no event shall the\n *   authors or copyright holders be liable for any claim, damages or other\n *   liability, whether in an action of contract, tort or otherwise, arising from,\n *   out of or in connection with the Software or the use or other dealings in the\n *   Software.\n */\n\n#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cstddef>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <utility>\n#include \"qrcodegen.hpp\"\n\nusing std::int8_t;\nusing std::uint8_t;\nusing std::size_t;\nusing std::vector;\n\n\nnamespace qrcodegen {\n\n/*---- Class QrSegment ----*/\n\nQrSegment::Mode::Mode(int mode, int cc0, int cc1, int cc2) :\n\t\tmodeBits(mode) {\n\tnumBitsCharCount[0] = cc0;\n\tnumBitsCharCount[1] = cc1;\n\tnumBitsCharCount[2] = cc2;\n}\n\n\nint QrSegment::Mode::getModeBits() const {\n\treturn modeBits;\n}\n\n\nint QrSegment::Mode::numCharCountBits(int ver) const {\n\treturn numBitsCharCount[(ver + 7) / 17];\n}\n\n\nconst QrSegment::Mode QrSegment::Mode::NUMERIC     (0x1, 10, 12, 14);\nconst QrSegment::Mode QrSegment::Mode::ALPHANUMERIC(0x2,  9, 11, 13);\nconst QrSegment::Mode QrSegment::Mode::BYTE        (0x4,  8, 16, 16);\nconst QrSegment::Mode QrSegment::Mode::KANJI       (0x8,  8, 10, 12);\nconst QrSegment::Mode QrSegment::Mode::ECI         (0x7,  0,  0,  0);\n\n\nQrSegment QrSegment::makeBytes(const vector<uint8_t> &data) {\n\tif (data.size() > static_cast<unsigned int>(INT_MAX))\n\t\tthrow std::length_error(\"Data too long\");\n\tBitBuffer bb;\n\tfor (uint8_t b : data)\n\t\tbb.appendBits(b, 8);\n\treturn QrSegment(Mode::BYTE, static_cast<int>(data.size()), std::move(bb));\n}\n\n\nQrSegment QrSegment::makeNumeric(const char *digits) {\n\tBitBuffer bb;\n\tint accumData = 0;\n\tint accumCount = 0;\n\tint charCount = 0;\n\tfor (; *digits != '\\0'; digits++, charCount++) {\n\t\tchar c = *digits;\n\t\tif (c < '0' || c > '9')\n\t\t\tthrow std::domain_error(\"String contains non-numeric characters\");\n\t\taccumData = accumData * 10 + (c - '0');\n\t\taccumCount++;\n\t\tif (accumCount == 3) {\n\t\t\tbb.appendBits(static_cast<uint32_t>(accumData), 10);\n\t\t\taccumData = 0;\n\t\t\taccumCount = 0;\n\t\t}\n\t}\n\tif (accumCount > 0)  // 1 or 2 digits remaining\n\t\tbb.appendBits(static_cast<uint32_t>(accumData), accumCount * 3 + 1);\n\treturn QrSegment(Mode::NUMERIC, charCount, std::move(bb));\n}\n\n\nQrSegment QrSegment::makeAlphanumeric(const char *text) {\n\tBitBuffer bb;\n\tint accumData = 0;\n\tint accumCount = 0;\n\tint charCount = 0;\n\tfor (; *text != '\\0'; text++, charCount++) {\n\t\tconst char *temp = std::strchr(ALPHANUMERIC_CHARSET, *text);\n\t\tif (temp == nullptr)\n\t\t\tthrow std::domain_error(\"String contains unencodable characters in alphanumeric mode\");\n\t\taccumData = accumData * 45 + static_cast<int>(temp - ALPHANUMERIC_CHARSET);\n\t\taccumCount++;\n\t\tif (accumCount == 2) {\n\t\t\tbb.appendBits(static_cast<uint32_t>(accumData), 11);\n\t\t\taccumData = 0;\n\t\t\taccumCount = 0;\n\t\t}\n\t}\n\tif (accumCount > 0)  // 1 character remaining\n\t\tbb.appendBits(static_cast<uint32_t>(accumData), 6);\n\treturn QrSegment(Mode::ALPHANUMERIC, charCount, std::move(bb));\n}\n\n\nvector<QrSegment> QrSegment::makeSegments(const char *text) {\n\t// Select the most efficient segment encoding automatically\n\tvector<QrSegment> result;\n\tif (*text == '\\0');  // Leave result empty\n\telse if (isNumeric(text))\n\t\tresult.push_back(makeNumeric(text));\n\telse if (isAlphanumeric(text))\n\t\tresult.push_back(makeAlphanumeric(text));\n\telse {\n\t\tvector<uint8_t> bytes;\n\t\tfor (; *text != '\\0'; text++)\n\t\t\tbytes.push_back(static_cast<uint8_t>(*text));\n\t\tresult.push_back(makeBytes(bytes));\n\t}\n\treturn result;\n}\n\n\nQrSegment QrSegment::makeEci(long assignVal) {\n\tBitBuffer bb;\n\tif (assignVal < 0)\n\t\tthrow std::domain_error(\"ECI assignment value out of range\");\n\telse if (assignVal < (1 << 7))\n\t\tbb.appendBits(static_cast<uint32_t>(assignVal), 8);\n\telse if (assignVal < (1 << 14)) {\n\t\tbb.appendBits(2, 2);\n\t\tbb.appendBits(static_cast<uint32_t>(assignVal), 14);\n\t} else if (assignVal < 1000000L) {\n\t\tbb.appendBits(6, 3);\n\t\tbb.appendBits(static_cast<uint32_t>(assignVal), 21);\n\t} else\n\t\tthrow std::domain_error(\"ECI assignment value out of range\");\n\treturn QrSegment(Mode::ECI, 0, std::move(bb));\n}\n\n\nQrSegment::QrSegment(const Mode &md, int numCh, const std::vector<bool> &dt) :\n\t\tmode(&md),\n\t\tnumChars(numCh),\n\t\tdata(dt) {\n\tif (numCh < 0)\n\t\tthrow std::domain_error(\"Invalid value\");\n}\n\n\nQrSegment::QrSegment(const Mode &md, int numCh, std::vector<bool> &&dt) :\n\t\tmode(&md),\n\t\tnumChars(numCh),\n\t\tdata(std::move(dt)) {\n\tif (numCh < 0)\n\t\tthrow std::domain_error(\"Invalid value\");\n}\n\n\nint QrSegment::getTotalBits(const vector<QrSegment> &segs, int version) {\n\tint result = 0;\n\tfor (const QrSegment &seg : segs) {\n\t\tint ccbits = seg.mode->numCharCountBits(version);\n\t\tif (seg.numChars >= (1L << ccbits))\n\t\t\treturn -1;  // The segment's length doesn't fit the field's bit width\n\t\tif (4 + ccbits > INT_MAX - result)\n\t\t\treturn -1;  // The sum will overflow an int type\n\t\tresult += 4 + ccbits;\n\t\tif (seg.data.size() > static_cast<unsigned int>(INT_MAX - result))\n\t\t\treturn -1;  // The sum will overflow an int type\n\t\tresult += static_cast<int>(seg.data.size());\n\t}\n\treturn result;\n}\n\n\nbool QrSegment::isNumeric(const char *text) {\n\tfor (; *text != '\\0'; text++) {\n\t\tchar c = *text;\n\t\tif (c < '0' || c > '9')\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\n\nbool QrSegment::isAlphanumeric(const char *text) {\n\tfor (; *text != '\\0'; text++) {\n\t\tif (std::strchr(ALPHANUMERIC_CHARSET, *text) == nullptr)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\n\nconst QrSegment::Mode &QrSegment::getMode() const {\n\treturn *mode;\n}\n\n\nint QrSegment::getNumChars() const {\n\treturn numChars;\n}\n\n\nconst std::vector<bool> &QrSegment::getData() const {\n\treturn data;\n}\n\n\nconst char *QrSegment::ALPHANUMERIC_CHARSET = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:\";\n\n\n\n/*---- Class QrCode ----*/\n\nint QrCode::getFormatBits(Ecc ecl) {\n\tswitch (ecl) {\n\t\tcase Ecc::LOW     :  return 1;\n\t\tcase Ecc::MEDIUM  :  return 0;\n\t\tcase Ecc::QUARTILE:  return 3;\n\t\tcase Ecc::HIGH    :  return 2;\n\t\tdefault:  throw std::logic_error(\"Unreachable\");\n\t}\n}\n\n\nQrCode QrCode::encodeText(const char *text, Ecc ecl) {\n\tvector<QrSegment> segs = QrSegment::makeSegments(text);\n\treturn encodeSegments(segs, ecl);\n}\n\n\nQrCode QrCode::encodeBinary(const vector<uint8_t> &data, Ecc ecl) {\n\tvector<QrSegment> segs{QrSegment::makeBytes(data)};\n\treturn encodeSegments(segs, ecl);\n}\n\n\nQrCode QrCode::encodeSegments(const vector<QrSegment> &segs, Ecc ecl,\n\t\tint minVersion, int maxVersion, int mask, bool boostEcl) {\n\tif (!(MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= MAX_VERSION) || mask < -1 || mask > 7)\n\t\tthrow std::invalid_argument(\"Invalid value\");\n\t\n\t// Find the minimal version number to use\n\tint version, dataUsedBits;\n\tfor (version = minVersion; ; version++) {\n\t\tint dataCapacityBits = getNumDataCodewords(version, ecl) * 8;  // Number of data bits available\n\t\tdataUsedBits = QrSegment::getTotalBits(segs, version);\n\t\tif (dataUsedBits != -1 && dataUsedBits <= dataCapacityBits)\n\t\t\tbreak;  // This version number is found to be suitable\n\t\tif (version >= maxVersion) {  // All versions in the range could not fit the given data\n\t\t\tstd::ostringstream sb;\n\t\t\tif (dataUsedBits == -1)\n\t\t\t\tsb << \"Segment too long\";\n\t\t\telse {\n\t\t\t\tsb << \"Data length = \" << dataUsedBits << \" bits, \";\n\t\t\t\tsb << \"Max capacity = \" << dataCapacityBits << \" bits\";\n\t\t\t}\n\t\t\tthrow data_too_long(sb.str());\n\t\t}\n\t}\n\tassert(dataUsedBits != -1);\n\t\n\t// Increase the error correction level while the data still fits in the current version number\n\tfor (Ecc newEcl : {Ecc::MEDIUM, Ecc::QUARTILE, Ecc::HIGH}) {  // From low to high\n\t\tif (boostEcl && dataUsedBits <= getNumDataCodewords(version, newEcl) * 8)\n\t\t\tecl = newEcl;\n\t}\n\t\n\t// Concatenate all segments to create the data bit string\n\tBitBuffer bb;\n\tfor (const QrSegment &seg : segs) {\n\t\tbb.appendBits(static_cast<uint32_t>(seg.getMode().getModeBits()), 4);\n\t\tbb.appendBits(static_cast<uint32_t>(seg.getNumChars()), seg.getMode().numCharCountBits(version));\n\t\tbb.insert(bb.end(), seg.getData().begin(), seg.getData().end());\n\t}\n\tassert(bb.size() == static_cast<unsigned int>(dataUsedBits));\n\t\n\t// Add terminator and pad up to a byte if applicable\n\tsize_t dataCapacityBits = static_cast<size_t>(getNumDataCodewords(version, ecl)) * 8;\n\tassert(bb.size() <= dataCapacityBits);\n\tbb.appendBits(0, std::min(4, static_cast<int>(dataCapacityBits - bb.size())));\n\tbb.appendBits(0, (8 - static_cast<int>(bb.size() % 8)) % 8);\n\tassert(bb.size() % 8 == 0);\n\t\n\t// Pad with alternating bytes until data capacity is reached\n\tfor (uint8_t padByte = 0xEC; bb.size() < dataCapacityBits; padByte ^= 0xEC ^ 0x11)\n\t\tbb.appendBits(padByte, 8);\n\t\n\t// Pack bits into bytes in big endian\n\tvector<uint8_t> dataCodewords(bb.size() / 8);\n\tfor (size_t i = 0; i < bb.size(); i++)\n\t\tdataCodewords.at(i >> 3) |= (bb.at(i) ? 1 : 0) << (7 - (i & 7));\n\t\n\t// Create the QR Code object\n\treturn QrCode(version, ecl, dataCodewords, mask);\n}\n\n\nQrCode::QrCode(int ver, Ecc ecl, const vector<uint8_t> &dataCodewords, int msk) :\n\t\t// Initialize fields and check arguments\n\t\tversion(ver),\n\t\terrorCorrectionLevel(ecl) {\n\tif (ver < MIN_VERSION || ver > MAX_VERSION)\n\t\tthrow std::domain_error(\"Version value out of range\");\n\tif (msk < -1 || msk > 7)\n\t\tthrow std::domain_error(\"Mask value out of range\");\n\tsize = ver * 4 + 17;\n\tsize_t sz = static_cast<size_t>(size);\n\tmodules    = vector<vector<bool> >(sz, vector<bool>(sz));  // Initially all light\n\tisFunction = vector<vector<bool> >(sz, vector<bool>(sz));\n\t\n\t// Compute ECC, draw modules\n\tdrawFunctionPatterns();\n\tconst vector<uint8_t> allCodewords = addEccAndInterleave(dataCodewords);\n\tdrawCodewords(allCodewords);\n\t\n\t// Do masking\n\tif (msk == -1) {  // Automatically choose best mask\n\t\tlong minPenalty = LONG_MAX;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tapplyMask(i);\n\t\t\tdrawFormatBits(i);\n\t\t\tlong penalty = getPenaltyScore();\n\t\t\tif (penalty < minPenalty) {\n\t\t\t\tmsk = i;\n\t\t\t\tminPenalty = penalty;\n\t\t\t}\n\t\t\tapplyMask(i);  // Undoes the mask due to XOR\n\t\t}\n\t}\n\tassert(0 <= msk && msk <= 7);\n\tmask = msk;\n\tapplyMask(msk);  // Apply the final choice of mask\n\tdrawFormatBits(msk);  // Overwrite old format bits\n\t\n\tisFunction.clear();\n\tisFunction.shrink_to_fit();\n}\n\n\nint QrCode::getVersion() const {\n\treturn version;\n}\n\n\nint QrCode::getSize() const {\n\treturn size;\n}\n\n\nQrCode::Ecc QrCode::getErrorCorrectionLevel() const {\n\treturn errorCorrectionLevel;\n}\n\n\nint QrCode::getMask() const {\n\treturn mask;\n}\n\n\nbool QrCode::getModule(int x, int y) const {\n\treturn 0 <= x && x < size && 0 <= y && y < size && module(x, y);\n}\n\n\nvoid QrCode::drawFunctionPatterns() {\n\t// Draw horizontal and vertical timing patterns\n\tfor (int i = 0; i < size; i++) {\n\t\tsetFunctionModule(6, i, i % 2 == 0);\n\t\tsetFunctionModule(i, 6, i % 2 == 0);\n\t}\n\t\n\t// Draw 3 finder patterns (all corners except bottom right; overwrites some timing modules)\n\tdrawFinderPattern(3, 3);\n\tdrawFinderPattern(size - 4, 3);\n\tdrawFinderPattern(3, size - 4);\n\t\n\t// Draw numerous alignment patterns\n\tconst vector<int> alignPatPos = getAlignmentPatternPositions();\n\tsize_t numAlign = alignPatPos.size();\n\tfor (size_t i = 0; i < numAlign; i++) {\n\t\tfor (size_t j = 0; j < numAlign; j++) {\n\t\t\t// Don't draw on the three finder corners\n\t\t\tif (!((i == 0 && j == 0) || (i == 0 && j == numAlign - 1) || (i == numAlign - 1 && j == 0)))\n\t\t\t\tdrawAlignmentPattern(alignPatPos.at(i), alignPatPos.at(j));\n\t\t}\n\t}\n\t\n\t// Draw configuration data\n\tdrawFormatBits(0);  // Dummy mask value; overwritten later in the constructor\n\tdrawVersion();\n}\n\n\nvoid QrCode::drawFormatBits(int msk) {\n\t// Calculate error correction code and pack bits\n\tint data = getFormatBits(errorCorrectionLevel) << 3 | msk;  // errCorrLvl is uint2, msk is uint3\n\tint rem = data;\n\tfor (int i = 0; i < 10; i++)\n\t\trem = (rem << 1) ^ ((rem >> 9) * 0x537);\n\tint bits = (data << 10 | rem) ^ 0x5412;  // uint15\n\tassert(bits >> 15 == 0);\n\t\n\t// Draw first copy\n\tfor (int i = 0; i <= 5; i++)\n\t\tsetFunctionModule(8, i, getBit(bits, i));\n\tsetFunctionModule(8, 7, getBit(bits, 6));\n\tsetFunctionModule(8, 8, getBit(bits, 7));\n\tsetFunctionModule(7, 8, getBit(bits, 8));\n\tfor (int i = 9; i < 15; i++)\n\t\tsetFunctionModule(14 - i, 8, getBit(bits, i));\n\t\n\t// Draw second copy\n\tfor (int i = 0; i < 8; i++)\n\t\tsetFunctionModule(size - 1 - i, 8, getBit(bits, i));\n\tfor (int i = 8; i < 15; i++)\n\t\tsetFunctionModule(8, size - 15 + i, getBit(bits, i));\n\tsetFunctionModule(8, size - 8, true);  // Always dark\n}\n\n\nvoid QrCode::drawVersion() {\n\tif (version < 7)\n\t\treturn;\n\t\n\t// Calculate error correction code and pack bits\n\tint rem = version;  // version is uint6, in the range [7, 40]\n\tfor (int i = 0; i < 12; i++)\n\t\trem = (rem << 1) ^ ((rem >> 11) * 0x1F25);\n\tlong bits = static_cast<long>(version) << 12 | rem;  // uint18\n\tassert(bits >> 18 == 0);\n\t\n\t// Draw two copies\n\tfor (int i = 0; i < 18; i++) {\n\t\tbool bit = getBit(bits, i);\n\t\tint a = size - 11 + i % 3;\n\t\tint b = i / 3;\n\t\tsetFunctionModule(a, b, bit);\n\t\tsetFunctionModule(b, a, bit);\n\t}\n}\n\n\nvoid QrCode::drawFinderPattern(int x, int y) {\n\tfor (int dy = -4; dy <= 4; dy++) {\n\t\tfor (int dx = -4; dx <= 4; dx++) {\n\t\t\tint dist = std::max(std::abs(dx), std::abs(dy));  // Chebyshev/infinity norm\n\t\t\tint xx = x + dx, yy = y + dy;\n\t\t\tif (0 <= xx && xx < size && 0 <= yy && yy < size)\n\t\t\t\tsetFunctionModule(xx, yy, dist != 2 && dist != 4);\n\t\t}\n\t}\n}\n\n\nvoid QrCode::drawAlignmentPattern(int x, int y) {\n\tfor (int dy = -2; dy <= 2; dy++) {\n\t\tfor (int dx = -2; dx <= 2; dx++)\n\t\t\tsetFunctionModule(x + dx, y + dy, std::max(std::abs(dx), std::abs(dy)) != 1);\n\t}\n}\n\n\nvoid QrCode::setFunctionModule(int x, int y, bool isDark) {\n\tsize_t ux = static_cast<size_t>(x);\n\tsize_t uy = static_cast<size_t>(y);\n\tmodules   .at(uy).at(ux) = isDark;\n\tisFunction.at(uy).at(ux) = true;\n}\n\n\nbool QrCode::module(int x, int y) const {\n\treturn modules.at(static_cast<size_t>(y)).at(static_cast<size_t>(x));\n}\n\n\nvector<uint8_t> QrCode::addEccAndInterleave(const vector<uint8_t> &data) const {\n\tif (data.size() != static_cast<unsigned int>(getNumDataCodewords(version, errorCorrectionLevel)))\n\t\tthrow std::invalid_argument(\"Invalid argument\");\n\t\n\t// Calculate parameter numbers\n\tint numBlocks = NUM_ERROR_CORRECTION_BLOCKS[static_cast<int>(errorCorrectionLevel)][version];\n\tint blockEccLen = ECC_CODEWORDS_PER_BLOCK  [static_cast<int>(errorCorrectionLevel)][version];\n\tint rawCodewords = getNumRawDataModules(version) / 8;\n\tint numShortBlocks = numBlocks - rawCodewords % numBlocks;\n\tint shortBlockLen = rawCodewords / numBlocks;\n\t\n\t// Split data into blocks and append ECC to each block\n\tvector<vector<uint8_t> > blocks;\n\tconst vector<uint8_t> rsDiv = reedSolomonComputeDivisor(blockEccLen);\n\tfor (int i = 0, k = 0; i < numBlocks; i++) {\n\t\tvector<uint8_t> dat(data.cbegin() + k, data.cbegin() + (k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1)));\n\t\tk += static_cast<int>(dat.size());\n\t\tconst vector<uint8_t> ecc = reedSolomonComputeRemainder(dat, rsDiv);\n\t\tif (i < numShortBlocks)\n\t\t\tdat.push_back(0);\n\t\tdat.insert(dat.end(), ecc.cbegin(), ecc.cend());\n\t\tblocks.push_back(std::move(dat));\n\t}\n\t\n\t// Interleave (not concatenate) the bytes from every block into a single sequence\n\tvector<uint8_t> result;\n\tfor (size_t i = 0; i < blocks.at(0).size(); i++) {\n\t\tfor (size_t j = 0; j < blocks.size(); j++) {\n\t\t\t// Skip the padding byte in short blocks\n\t\t\tif (i != static_cast<unsigned int>(shortBlockLen - blockEccLen) || j >= static_cast<unsigned int>(numShortBlocks))\n\t\t\t\tresult.push_back(blocks.at(j).at(i));\n\t\t}\n\t}\n\tassert(result.size() == static_cast<unsigned int>(rawCodewords));\n\treturn result;\n}\n\n\nvoid QrCode::drawCodewords(const vector<uint8_t> &data) {\n\tif (data.size() != static_cast<unsigned int>(getNumRawDataModules(version) / 8))\n\t\tthrow std::invalid_argument(\"Invalid argument\");\n\t\n\tsize_t i = 0;  // Bit index into the data\n\t// Do the funny zigzag scan\n\tfor (int right = size - 1; right >= 1; right -= 2) {  // Index of right column in each column pair\n\t\tif (right == 6)\n\t\t\tright = 5;\n\t\tfor (int vert = 0; vert < size; vert++) {  // Vertical counter\n\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\tsize_t x = static_cast<size_t>(right - j);  // Actual x coordinate\n\t\t\t\tbool upward = ((right + 1) & 2) == 0;\n\t\t\t\tsize_t y = static_cast<size_t>(upward ? size - 1 - vert : vert);  // Actual y coordinate\n\t\t\t\tif (!isFunction.at(y).at(x) && i < data.size() * 8) {\n\t\t\t\t\tmodules.at(y).at(x) = getBit(data.at(i >> 3), 7 - static_cast<int>(i & 7));\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\t// If this QR Code has any remainder bits (0 to 7), they were assigned as\n\t\t\t\t// 0/false/light by the constructor and are left unchanged by this method\n\t\t\t}\n\t\t}\n\t}\n\tassert(i == data.size() * 8);\n}\n\n\nvoid QrCode::applyMask(int msk) {\n\tif (msk < 0 || msk > 7)\n\t\tthrow std::domain_error(\"Mask value out of range\");\n\tsize_t sz = static_cast<size_t>(size);\n\tfor (size_t y = 0; y < sz; y++) {\n\t\tfor (size_t x = 0; x < sz; x++) {\n\t\t\tbool invert;\n\t\t\tswitch (msk) {\n\t\t\t\tcase 0:  invert = (x + y) % 2 == 0;                    break;\n\t\t\t\tcase 1:  invert = y % 2 == 0;                          break;\n\t\t\t\tcase 2:  invert = x % 3 == 0;                          break;\n\t\t\t\tcase 3:  invert = (x + y) % 3 == 0;                    break;\n\t\t\t\tcase 4:  invert = (x / 3 + y / 2) % 2 == 0;            break;\n\t\t\t\tcase 5:  invert = x * y % 2 + x * y % 3 == 0;          break;\n\t\t\t\tcase 6:  invert = (x * y % 2 + x * y % 3) % 2 == 0;    break;\n\t\t\t\tcase 7:  invert = ((x + y) % 2 + x * y % 3) % 2 == 0;  break;\n\t\t\t\tdefault:  throw std::logic_error(\"Unreachable\");\n\t\t\t}\n\t\t\tmodules.at(y).at(x) = modules.at(y).at(x) ^ (invert & !isFunction.at(y).at(x));\n\t\t}\n\t}\n}\n\n\nlong QrCode::getPenaltyScore() const {\n\tlong result = 0;\n\t\n\t// Adjacent modules in row having same color, and finder-like patterns\n\tfor (int y = 0; y < size; y++) {\n\t\tbool runColor = false;\n\t\tint runX = 0;\n\t\tstd::array<int,7> runHistory = {};\n\t\tfor (int x = 0; x < size; x++) {\n\t\t\tif (module(x, y) == runColor) {\n\t\t\t\trunX++;\n\t\t\t\tif (runX == 5)\n\t\t\t\t\tresult += PENALTY_N1;\n\t\t\t\telse if (runX > 5)\n\t\t\t\t\tresult++;\n\t\t\t} else {\n\t\t\t\tfinderPenaltyAddHistory(runX, runHistory);\n\t\t\t\tif (!runColor)\n\t\t\t\t\tresult += finderPenaltyCountPatterns(runHistory) * PENALTY_N3;\n\t\t\t\trunColor = module(x, y);\n\t\t\t\trunX = 1;\n\t\t\t}\n\t\t}\n\t\tresult += finderPenaltyTerminateAndCount(runColor, runX, runHistory) * PENALTY_N3;\n\t}\n\t// Adjacent modules in column having same color, and finder-like patterns\n\tfor (int x = 0; x < size; x++) {\n\t\tbool runColor = false;\n\t\tint runY = 0;\n\t\tstd::array<int,7> runHistory = {};\n\t\tfor (int y = 0; y < size; y++) {\n\t\t\tif (module(x, y) == runColor) {\n\t\t\t\trunY++;\n\t\t\t\tif (runY == 5)\n\t\t\t\t\tresult += PENALTY_N1;\n\t\t\t\telse if (runY > 5)\n\t\t\t\t\tresult++;\n\t\t\t} else {\n\t\t\t\tfinderPenaltyAddHistory(runY, runHistory);\n\t\t\t\tif (!runColor)\n\t\t\t\t\tresult += finderPenaltyCountPatterns(runHistory) * PENALTY_N3;\n\t\t\t\trunColor = module(x, y);\n\t\t\t\trunY = 1;\n\t\t\t}\n\t\t}\n\t\tresult += finderPenaltyTerminateAndCount(runColor, runY, runHistory) * PENALTY_N3;\n\t}\n\t\n\t// 2*2 blocks of modules having same color\n\tfor (int y = 0; y < size - 1; y++) {\n\t\tfor (int x = 0; x < size - 1; x++) {\n\t\t\tbool  color = module(x, y);\n\t\t\tif (  color == module(x + 1, y) &&\n\t\t\t      color == module(x, y + 1) &&\n\t\t\t      color == module(x + 1, y + 1))\n\t\t\t\tresult += PENALTY_N2;\n\t\t}\n\t}\n\t\n\t// Balance of dark and light modules\n\tint dark = 0;\n\tfor (const vector<bool> &row : modules) {\n\t\tfor (bool color : row) {\n\t\t\tif (color)\n\t\t\t\tdark++;\n\t\t}\n\t}\n\tint total = size * size;  // Note that size is odd, so dark/total != 1/2\n\t// Compute the smallest integer k >= 0 such that (45-5k)% <= dark/total <= (55+5k)%\n\tint k = static_cast<int>((std::abs(dark * 20L - total * 10L) + total - 1) / total) - 1;\n\tassert(0 <= k && k <= 9);\n\tresult += k * PENALTY_N4;\n\tassert(0 <= result && result <= 2568888L);  // Non-tight upper bound based on default values of PENALTY_N1, ..., N4\n\treturn result;\n}\n\n\nvector<int> QrCode::getAlignmentPatternPositions() const {\n\tif (version == 1)\n\t\treturn vector<int>();\n\telse {\n\t\tint numAlign = version / 7 + 2;\n\t\tint step = (version * 8 + numAlign * 3 + 5) / (numAlign * 4 - 4) * 2;\n\t\tvector<int> result;\n\t\tfor (int i = 0, pos = size - 7; i < numAlign - 1; i++, pos -= step)\n\t\t\tresult.insert(result.begin(), pos);\n\t\tresult.insert(result.begin(), 6);\n\t\treturn result;\n\t}\n}\n\n\nint QrCode::getNumRawDataModules(int ver) {\n\tif (ver < MIN_VERSION || ver > MAX_VERSION)\n\t\tthrow std::domain_error(\"Version number out of range\");\n\tint result = (16 * ver + 128) * ver + 64;\n\tif (ver >= 2) {\n\t\tint numAlign = ver / 7 + 2;\n\t\tresult -= (25 * numAlign - 10) * numAlign - 55;\n\t\tif (ver >= 7)\n\t\t\tresult -= 36;\n\t}\n\tassert(208 <= result && result <= 29648);\n\treturn result;\n}\n\n\nint QrCode::getNumDataCodewords(int ver, Ecc ecl) {\n\treturn getNumRawDataModules(ver) / 8\n\t\t- ECC_CODEWORDS_PER_BLOCK    [static_cast<int>(ecl)][ver]\n\t\t* NUM_ERROR_CORRECTION_BLOCKS[static_cast<int>(ecl)][ver];\n}\n\n\nvector<uint8_t> QrCode::reedSolomonComputeDivisor(int degree) {\n\tif (degree < 1 || degree > 255)\n\t\tthrow std::domain_error(\"Degree out of range\");\n\t// Polynomial coefficients are stored from highest to lowest power, excluding the leading term which is always 1.\n\t// For example the polynomial x^3 + 255x^2 + 8x + 93 is stored as the uint8 array {255, 8, 93}.\n\tvector<uint8_t> result(static_cast<size_t>(degree));\n\tresult.at(result.size() - 1) = 1;  // Start off with the monomial x^0\n\t\n\t// Compute the product polynomial (x - r^0) * (x - r^1) * (x - r^2) * ... * (x - r^{degree-1}),\n\t// and drop the highest monomial term which is always 1x^degree.\n\t// Note that r = 0x02, which is a generator element of this field GF(2^8/0x11D).\n\tuint8_t root = 1;\n\tfor (int i = 0; i < degree; i++) {\n\t\t// Multiply the current product by (x - r^i)\n\t\tfor (size_t j = 0; j < result.size(); j++) {\n\t\t\tresult.at(j) = reedSolomonMultiply(result.at(j), root);\n\t\t\tif (j + 1 < result.size())\n\t\t\t\tresult.at(j) ^= result.at(j + 1);\n\t\t}\n\t\troot = reedSolomonMultiply(root, 0x02);\n\t}\n\treturn result;\n}\n\n\nvector<uint8_t> QrCode::reedSolomonComputeRemainder(const vector<uint8_t> &data, const vector<uint8_t> &divisor) {\n\tvector<uint8_t> result(divisor.size());\n\tfor (uint8_t b : data) {  // Polynomial division\n\t\tuint8_t factor = b ^ result.at(0);\n\t\tresult.erase(result.begin());\n\t\tresult.push_back(0);\n\t\tfor (size_t i = 0; i < result.size(); i++)\n\t\t\tresult.at(i) ^= reedSolomonMultiply(divisor.at(i), factor);\n\t}\n\treturn result;\n}\n\n\nuint8_t QrCode::reedSolomonMultiply(uint8_t x, uint8_t y) {\n\t// Russian peasant multiplication\n\tint z = 0;\n\tfor (int i = 7; i >= 0; i--) {\n\t\tz = (z << 1) ^ ((z >> 7) * 0x11D);\n\t\tz ^= ((y >> i) & 1) * x;\n\t}\n\tassert(z >> 8 == 0);\n\treturn static_cast<uint8_t>(z);\n}\n\n\nint QrCode::finderPenaltyCountPatterns(const std::array<int,7> &runHistory) const {\n\tint n = runHistory.at(1);\n\tassert(n <= size * 3);\n\tbool core = n > 0 && runHistory.at(2) == n && runHistory.at(3) == n * 3 && runHistory.at(4) == n && runHistory.at(5) == n;\n\treturn (core && runHistory.at(0) >= n * 4 && runHistory.at(6) >= n ? 1 : 0)\n\t     + (core && runHistory.at(6) >= n * 4 && runHistory.at(0) >= n ? 1 : 0);\n}\n\n\nint QrCode::finderPenaltyTerminateAndCount(bool currentRunColor, int currentRunLength, std::array<int,7> &runHistory) const {\n\tif (currentRunColor) {  // Terminate dark run\n\t\tfinderPenaltyAddHistory(currentRunLength, runHistory);\n\t\tcurrentRunLength = 0;\n\t}\n\tcurrentRunLength += size;  // Add light border to final run\n\tfinderPenaltyAddHistory(currentRunLength, runHistory);\n\treturn finderPenaltyCountPatterns(runHistory);\n}\n\n\nvoid QrCode::finderPenaltyAddHistory(int currentRunLength, std::array<int,7> &runHistory) const {\n\tif (runHistory.at(0) == 0)\n\t\tcurrentRunLength += size;  // Add light border to initial run\n\tstd::copy_backward(runHistory.cbegin(), runHistory.cend() - 1, runHistory.end());\n\trunHistory.at(0) = currentRunLength;\n}\n\n\nbool QrCode::getBit(long x, int i) {\n\treturn ((x >> i) & 1) != 0;\n}\n\n\n/*---- Tables of constants ----*/\n\nconst int QrCode::PENALTY_N1 =  3;\nconst int QrCode::PENALTY_N2 =  3;\nconst int QrCode::PENALTY_N3 = 40;\nconst int QrCode::PENALTY_N4 = 10;\n\n\nconst int8_t QrCode::ECC_CODEWORDS_PER_BLOCK[4][41] = {\n\t// Version: (note that index 0 is for padding, and is set to an illegal value)\n\t//0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level\n\t{-1,  7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30},  // Low\n\t{-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28},  // Medium\n\t{-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30},  // Quartile\n\t{-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30},  // High\n};\n\nconst int8_t QrCode::NUM_ERROR_CORRECTION_BLOCKS[4][41] = {\n\t// Version: (note that index 0 is for padding, and is set to an illegal value)\n\t//0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level\n\t{-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4,  4,  4,  4,  4,  6,  6,  6,  6,  7,  8,  8,  9,  9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25},  // Low\n\t{-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5,  5,  8,  9,  9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49},  // Medium\n\t{-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8,  8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68},  // Quartile\n\t{-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81},  // High\n};\n\n\ndata_too_long::data_too_long(const std::string &msg) :\n\tstd::length_error(msg) {}\n\n\n\n/*---- Class BitBuffer ----*/\n\nBitBuffer::BitBuffer()\n\t: std::vector<bool>() {}\n\n\nvoid BitBuffer::appendBits(std::uint32_t val, int len) {\n\tif (len < 0 || len > 31 || val >> len != 0)\n\t\tthrow std::domain_error(\"Value out of range\");\n\tfor (int i = len - 1; i >= 0; i--)  // Append bit by bit\n\t\tthis->push_back(((val >> i) & 1) != 0);\n}\n\n}\n"
        }
      ]
    },
    {
      "dir": "linux/media",
      "files": [
        {
          "name": "playerstatuswatcher.cpp",
          "ext": ".cpp",
          "size": 2805,
          "preview": "#include \"playerstatuswatcher.h\"\n#include <QDBusConnection>\n#include <QDBusPendingReply>\n#include <QVariantMap>\n#include <QDBusReply>\n#include <QDBusConnectionInterface>\n\nPlayerStatusWatcher::PlayerStatusWatcher(const QString &playerService, QObject *parent)\n    : QObject(parent),\n      m_playerService(playerService),\n      m_iface(new QDBusInterface(playerService, \"/org/mpris/MediaPlayer2\",\n                                 \"org.mpris.MediaPlayer2.Player\", QDBusConnection::sessionBus(), this)),\n      m_serviceWatcher(new QDBusServiceWatcher(playerService, QDBusConnection::sessionBus(),\n                                               QDBusServiceWatcher::WatchForOwnerChange, this))\n{\n    QDBusConnection::sessionBus().connect(\n        playerService, \"/org/mpris/MediaPlayer2\", \"org.freedesktop.DBus.Properties\",\n        \"PropertiesChanged\", this, SLOT(onPropertiesChanged(QString,QVariantMap,QStringList))\n    );\n    connect(m_serviceWatcher, &QDBusServiceWatcher::serviceOwnerChanged,\n            this, &PlayerStatusWatcher::onServiceOwnerChanged);\n    updateStatus();\n}\n\nvoid PlayerStatusWatcher::onPropertiesChanged(const QString &interface,\n                                              const QVariantMap &changed,\n                                              const QStringList &)\n{\n    if (interface == \"org.mpris.MediaPlayer2.Player\" && changed.contains(\"PlaybackStatus\")) {\n        emit playbackStatusChanged(changed.value(\"PlaybackStatus\").toString());\n    }\n}\n\nvoid PlayerStatusWatcher::updateStatus() {\n    QVariant reply = m_iface->property(\"PlaybackStatus\");\n    if (reply.isValid()) {\n        emit playbackStatusChanged(reply.toString());\n    }\n}\n\nvoid PlayerStatusWatcher::onServiceOwnerChanged(const QString &name, const QString &, const QString &newOwner)\n{\n    if (name == m_playerService && newOwner.isEmpty()) {\n        emit playbackStatusChanged(\"\"); // player disappeared\n    } else if (name == m_playerService && !newOwner.isEmpty()) {\n        updateStatus(); // player appeared/reappeared\n    }\n}\n\nQString PlayerStatusWatcher::getCurrentPlaybackStatus(const QString &playerService)\n{\n    QDBusConnection bus = QDBusConnection::sessionBus();\n    QStringList services = bus.interface()->registeredServiceNames().value();\n\n    for (const QString &service : services) {\n        if (service.startsWith(\"org.mpris.MediaPlayer2.\")) {\n            QDBusInterface iface(service, \"/org/mpris/MediaPlayer2\",\n                               \"org.mpris.MediaPlayer2.Player\", bus);\n            \n            if (iface.isValid()) {\n                QVariant status = iface.property(\"PlaybackStatus\");\n                if (status.isValid() && status.toString() == \"Playing\") {\n                    return status.toString();\n                }\n            }\n        }\n    }\n\n    return QString();\n}"
        },
        {
          "name": "mediacontroller.h",
          "ext": ".h",
          "size": 1550,
          "preview": "#ifndef MEDIACONTROLLER_H\n#define MEDIACONTROLLER_H\n\n#include <QObject>\n\nclass QProcess;\nclass EarDetection;\nclass PlayerStatusWatcher;\nclass QDBusInterface;\n\nclass MediaController : public QObject\n{\n  Q_OBJECT\npublic:\n  enum MediaState\n  {\n    Playing,\n    Paused,\n    Stopped\n  };\n  Q_ENUM(MediaState)\n  enum EarDetectionBehavior\n  {\n    PauseWhenOneRemoved,\n    PauseWhenBothRemoved,\n    Disabled\n  };\n  Q_ENUM(EarDetectionBehavior)\n\n  explicit MediaController(QObject *parent = nullptr);\n  ~MediaController();\n\n  void handleEarDetection(EarDetection*);\n  void followMediaChanges();\n  bool isActiveOutputDeviceAirPods();\n  void handleConversationalAwareness(const QByteArray &data);\n  void activateA2dpProfile();\n  void removeAudioOutputDevice();\n  void setConnectedDeviceMacAddress(const QString &macAddress);\n\n  void setEarDetectionBehavior(EarDetectionBehavior behavior);\n  inline EarDetectionBehavior getEarDetectionBehavior() const { return earDetectionBehavior; }\n\n  void play();\n  void pause();\n  MediaState getCurrentMediaState() const;\n\nQ_SIGNALS:\n  void mediaStateChanged(MediaState state);\n\nprivate:\n  MediaState mediaStateFromPlayerctlOutput(const QString &output) const;\n  QString getAudioDeviceName();\n  bool sendMediaPlayerCommand(const QString &method);\n\n  bool wasPausedByApp = false;\n  int initialVolume = -1;\n  QString connectedDeviceMacAddress;\n  EarDetectionBehavior earDetectionBehavior = PauseWhenOneRemoved;\n  QString m_deviceOutputName;\n  PlayerStatusWatcher *playerStatusWatcher = nullptr;\n};\n\n#endif // MEDIACONTROLLER_H"
        },
        {
          "name": "playerstatuswatcher.h",
          "ext": ".h",
          "size": 750,
          "preview": "#pragma once\n\n#include <QObject>\n#include <QDBusInterface>\n#include <QDBusServiceWatcher>\n\nclass PlayerStatusWatcher : public QObject {\n    Q_OBJECT\npublic:\n    explicit PlayerStatusWatcher(const QString &playerService, QObject *parent = nullptr);\n    static QString getCurrentPlaybackStatus(const QString &playerService);\n\nsignals:\n    void playbackStatusChanged(const QString &status);\n\nprivate slots:\n    void onPropertiesChanged(const QString &interface, const QVariantMap &changed, const QStringList &);\n    void onServiceOwnerChanged(const QString &name, const QString &oldOwner, const QString &newOwner);\n\nprivate:\n    void updateStatus();\n    QString m_playerService;\n    QDBusInterface *m_iface;\n    QDBusServiceWatcher *m_serviceWatcher;\n};"
        },
        {
          "name": "mediacontroller.cpp",
          "ext": ".cpp",
          "size": 9605,
          "preview": "#include \"mediacontroller.h\"\n#include \"logger.h\"\n#include \"eardetection.hpp\"\n#include \"playerstatuswatcher.h\"\n\n#include <QDebug>\n#include <QProcess>\n#include <QRegularExpression>\n#include <QDBusConnection>\n#include <QDBusConnectionInterface>\n\nMediaController::MediaController(QObject *parent) : QObject(parent) {\n}\n\nvoid MediaController::handleEarDetection(EarDetection *earDetection)\n{\n  if (earDetectionBehavior == Disabled)\n  {\n    LOG_DEBUG(\"Ear detection is disabled, ignoring status\");\n    return;\n  }\n\n  bool primaryInEar = earDetection->isPrimaryInEar();\n  bool secondaryInEar = earDetection->isSecondaryInEar();\n\n  LOG_DEBUG(\"Ear detection status: primaryInEar=\"\n            << primaryInEar << \", secondaryInEar=\" << secondaryInEar\n            << \", isAirPodsActive=\" << isActiveOutputDeviceAirPods());\n\n  // First handle playback pausing based on selected behavior\n  bool shouldPause = false;\n  bool shouldResume = false;\n\n  if (earDetectionBehavior == PauseWhenOneRemoved)\n  {\n    shouldPause = !primaryInEar || !secondaryInEar;\n    shouldResume = primaryInEar && secondaryInEar;\n  }\n  else if (earDetectionBehavior == PauseWhenBothRemoved)\n  {\n    shouldPause = !primaryInEar && !secondaryInEar;\n    shouldResume = primaryInEar || secondaryInEar;\n  }\n\n  if (shouldPause && isActiveOutputDeviceAirPods())\n  {\n    if (getCurrentMediaState() == Playing)\n    {\n      pause();\n    }\n  }\n\n  // Then handle device profile switching\n  if (primaryInEar || secondaryInEar)\n  {\n    LOG_INFO(\"At least one AirPod is in ear\");\n    activateA2dpProfile();\n\n    // Resume if conditions are met and we previously paused\n    if (shouldResume && wasPausedByApp && isActiveOutputDeviceAirPods())\n    {\n      play();\n    }\n  }\n  else\n  {\n    LOG_INFO(\"Both AirPods are out of ear\");\n    removeAudioOutputDevice();\n  }\n}\n\nvoid MediaController::setEarDetectionBehavior(EarDetectionBehavior behavior)\n{\n  earDetectionBehavior = behavior;\n  LOG_INFO(\"Set ear detection behavior to: \" << behavior);\n}\n\nvoid MediaController::followMediaChanges() {\n  playerStatusWatcher = new PlayerStatusWatcher(\"\", this);\n  connect(playerStatusWatcher, &PlayerStatusWatcher::playbackStatusChanged,\n          this, [this](const QString &status)\n          {\n            LOG_DEBUG(\"Playback status changed: \" << status);\n            MediaState state = mediaStateFromPlayerctlOutput(status);\n            emit mediaStateChanged(state);\n          });\n}\n\nbool MediaController::isActiveOutputDeviceAirPods() {\n  QProcess process;\n  process.start(\"pactl\", QStringList() << \"get-default-sink\");\n  process.waitForFinished();\n  QString output = process.readAllStandardOutput().trimmed();\n  LOG_DEBUG(\"Default sink: \" << output);\n  return output.contains(connectedDeviceMacAddress);\n}\n\nvoid MediaController::handleConversationalAwareness(const QByteArray &data) {\n  LOG_DEBUG(\"Handling conversational awareness data: \" << data.toHex());\n  bool lowered = data[9] == 0x01;\n  LOG_INFO(\"Conversational awareness: \" << (lowered ? \"enabled\" : \"disabled\"));\n\n  if (lowered) {\n    if (initialVolume == -1 && isActiveOutputDeviceAirPods()) {\n      QProcess process;\n      process.start(\"pactl\", QStringList()\n                                 << \"get-sink-volume\" << \"@DEFAULT_SINK@\");\n      process.waitForFinished();\n      QString output = process.readAllStandardOutput();\n      QRegularExpression re(\"front-left: \\\\d+ /\\\\s*(\\\\d+)%\");\n      QRegularExpressionMatch match = re.match(output);\n      if (match.hasMatch()) {\n        LOG_DEBUG(\"Matched: \" << match.captured(1));\n        initialVolume = match.captured(1).toInt();\n      } else {\n        LOG_ERROR(\"Failed to parse initial volume from output: \" << output);\n        return;\n      }\n    }\n    QProcess::execute(\n        \"pactl\", QStringList() << \"set-sink-volume\" << \"@DEFAULT_SINK@\"\n                               << QString::number(initialVolume * 0.20) + \"%\");\n    LOG_INFO(\"Volume lowered to 0.20 of initial which is \"\n             << initialVolume * 0.20 << \"%\");\n  } else {\n    if (initialVolume != -1 && isActiveOutputDeviceAirPods()) {\n      QProcess::execute(\"pactl\", QStringList()\n                                     << \"set-sink-volume\" << \"@DEFAULT_SINK@\"\n                                     << QString::number(initialVolume) + \"%\");\n      LOG_INFO(\"Volume restored to \" << initialVolume << \"%\");\n      initialVolume = -1;\n    }\n  }\n}\n\nvoid MediaController::activateA2dpProfile() {\n  if (connectedDeviceMacAddress.isEmpty() || m_deviceOutputName.isEmpty()) {\n    LOG_WARN(\"Connected device MAC address or output name is empty, cannot activate A2DP profile\");\n    return;\n  }\n\n  LOG_INFO(\"Activating A2DP profile for AirPods\");\n  int result = QProcess::execute(\n      \"pactl\", QStringList()\n                   << \"set-card-profile\"\n                   << m_deviceOutputName << \"a2dp-sink\");\n  if (result != 0) {\n    LOG_ERROR(\"Failed to activate A2DP profile\");\n  }\n}\n\nvoid MediaController::removeAudioOutputDevice() {\n  if (connectedDeviceMacAddress.isEmpty() || m_deviceOutputName.isEmpty()) {\n    LOG_WARN(\"Connected device MAC address or output name is empty, cannot remove audio output device\");\n    return;\n  }\n  \n  LOG_INFO(\"Removing AirPods as audio output device\");\n  int result = QProcess::execute(\n      \"pactl\", QStringList()\n                   << \"set-card-profile\"\n                   << m_deviceOutputName << \"off\");\n  if (result != 0) {\n    LOG_ERROR(\"Failed to remove AirPods as audio output device\");\n  }\n}\n\nvoid MediaController::setConnectedDeviceMacAddress(const QString &macAddress) {\n  connectedDeviceMacAddress = macAddress;\n  m_deviceOutputName = getAudioDeviceName();\n  LOG_INFO(\"Device output name set to: \" << m_deviceOutputName);\n}\n\nMediaController::MediaState MediaController::mediaStateFromPlayerctlOutput(\n    const QString &output) const {\n  if (output == \"Playing\") {\n    return MediaState::Playing;\n  } else if (output == \"Paused\") {\n    return MediaState::Paused;\n  } else {\n    return MediaState::Stopped;\n  }\n}\n\nMediaController::MediaState MediaController::getCurrentMediaState() const\n{\n  return mediaStateFromPlayerctlOutput(PlayerStatusWatcher::getCurrentPlaybackStatus(\"\"));\n}\n\nbool MediaController::sendMediaPlayerCommand(const QString &method)\n{\n  // Connect to the session bus\n  QDBusConnection bus = QDBusConnection::sessionBus();\n\n  // Find available MPRIS-compatible media players\n  QStringList services = bus.interface()->registeredServiceNames().value();\n  QStringList mprisServices;\n  for (const QString &service : services)\n  {\n    if (service.startsWith(\"org.mpris.MediaPlayer2.\"))\n    {\n      mprisServices << service;\n    }\n  }\n\n  if (mprisServices.isEmpty())\n  {\n    LOG_ERROR(\"No MPRIS-compatible media players found on DBus\");\n    return false;\n  }\n\n  bool success = false;\n  // Try each MPRIS service until one succeeds\n  for (const QString &service : mprisServices)\n  {\n    QDBusInterface playerInterface(\n        service,\n        \"/org/mpris/MediaPlayer2\",\n        \"org.mpris.MediaPlayer2.Player\",\n        bus);\n\n    if (!playerInterface.isValid())\n    {\n      LOG_ERROR(\"Invalid DBus interface for service: \" << service);\n      continue;\n    }\n\n    // Send the Play or Pause command\n    if (method == \"Play\" || method == \"Pause\")\n    {\n      QDBusReply<void> reply = playerInterface.call(method);\n      if (reply.isValid())\n      {\n        LOG_INFO(\"Successfully sent \" << method << \" to \" << service);\n        success = true;\n        break; // Exit after the first successful command\n      }\n      else\n      {\n        LOG_ERROR(\"Failed to send \" << method << \" to \" << service\n                                    << \": \" << reply.error().message());\n      }\n    }\n    else\n    {\n      LOG_ERROR(\"Unsupported method: \" << method);\n      return false;\n    }\n  }\n\n  if (!success)\n  {\n    LOG_ERROR(\"No media player responded successfully to \" << method);\n  }\n  return success;\n}\n\nvoid MediaController::play()\n{\n  if (sendMediaPlayerCommand(\"Play\"))\n  {\n    LOG_INFO(\"Resumed playback via DBus\");\n    wasPausedByApp = false;\n  }\n  else\n  {\n    LOG_ERROR(\"Failed to resume playback via DBus\");\n  }\n}\n\nvoid MediaController::pause()\n{\n  if (sendMediaPlayerCommand(\"Pause\"))\n  {\n    LOG_INFO(\"Paused playback via DBus\");\n    wasPausedByApp = true;\n  }\n  else\n  {\n    LOG_ERROR(\"Failed to pause playback via DBus\");\n  }\n}\n\nMediaController::~MediaController() {\n}\n\nQString MediaController::getAudioDeviceName()\n{\n  if (connectedDeviceMacAddress.isEmpty()) { return QString(); }\n\n  // Set up QProcess to run pactl directly\n  QProcess process;\n  process.start(\"pactl\", QStringList() << \"list\" << \"cards\" << \"short\");\n  if (!process.waitForFinished(3000)) // Timeout after 3 seconds\n  {\n    LOG_ERROR(\"pactl command failed or timed out: \" << process.errorString());\n    return QString();\n  }\n\n  // Check for execution errors\n  if (process.exitCode() != 0)\n  {\n    LOG_ERROR(\"pactl exited with error code: \" << process.exitCode());\n    return QString();\n  }\n\n  // Read and parse the command output\n  QString output = process.readAllStandardOutput();\n  QStringList lines = output.split(\"\\n\", Qt::SkipEmptyParts);\n\n  // Iterate through each line to find a matching Bluetooth sink\n  for (const QString &line : lines)\n  {\n    QStringList fields = line.split(\"\\t\", Qt::SkipEmptyParts);\n    if (fields.size() < 2) { continue; }\n\n    QString sinkName = fields[1].trimmed();\n    if (sinkName.startsWith(\"bluez\") && sinkName.contains(connectedDeviceMacAddress))\n    {\n      return sinkName;\n    }\n  }\n\n  // No matching sink found\n  LOG_ERROR(\"No matching Bluetooth sink found for MAC address: \" << connectedDeviceMacAddress);\n  return QString();\n}"
        }
      ]
    },
    {
      "dir": "linux/assets",
      "files": [
        {
          "name": "pod4_case.png",
          "ext": ".png",
          "size": 7425
        },
        {
          "name": "pod3.png",
          "ext": ".png",
          "size": 6550
        },
        {
          "name": "airpods.png",
          "ext": ".png",
          "size": 78127
        },
        {
          "name": "podpro.png",
          "ext": ".png",
          "size": 7522
        },
        {
          "name": "pod.png",
          "ext": ".png",
          "size": 2938
        },
        {
          "name": "podpro_case.png",
          "ext": ".png",
          "size": 5547
        },
        {
          "name": "podmax.png",
          "ext": ".png",
          "size": 10922
        },
        {
          "name": "pod3_case.png",
          "ext": ".png",
          "size": 5856
        },
        {
          "name": "pod_case.png",
          "ext": ".png",
          "size": 4335
        }
      ]
    },
    {
      "dir": "linux/assets/fonts",
      "files": [
        {
          "name": "SF-Symbols-6.ttf",
          "ext": ".ttf",
          "size": 3762948
        }
      ]
    },
    {
      "dir": "docs",
      "files": [
        {
          "name": "control_commands.md",
          "ext": ".md",
          "size": 4223,
          "preview": "# Control Commands\n\nAACP uses opcode `9` for control commands. opcodes are 16 bit integers that specify the kind of action being done. The length of a control command is fixed to 7 bytes + 4 bytes header (`04 00 04 00`)\n\nAn AACP packet is formated as:\n\n`04 00 04 00 [opcode, little endianness] [data]`\n\nSo, our control commands becomes\n\n```\n04 00 04 00 09 00 [identifier] [data1] [data2] [data3] [data4]\n```\n\nBytes that are not used are set to `0x00`. From what I've observed, the `data3` and `data4` are never used, and hence always zero. And, the `data2` is usually used when the configuration can be different for the two buds: like, to change the long press mode. Or, if there can be two \"state\" variables for the same feature: like the Hearing Aid feature.\n\n## Control Commands \nThese commands\n\n| Command identifier | Description | Format |\n|--------------|---------------------|--------|\n| 0x01 | Mic Mode | Single value (1 byte) |\n| 0x05 | Button Send Mode | Single value (1 byte) |\n| 0x12 | VoiceTrigger for Siri | Single Value (1 byte): `0x01` = enabled, `0x01` = disabled |\n| 0x14 | SingleClickMode | Single value (1 byte) |\n| 0x15 | DoubleClickMode | Single value (1 byte) |\n| 0x16 | ClickHoldMode | Two values (2 bytes; First byte = right bud Second byte = for left): `0x01` = Noise control `0x05` = Siri |\n| 0x17 | DoubleClickInterval | Single value (1 byte): 0x00 = Default, `0x01` = Slower, `0x02` = Slowest|\n| 0x18 | ClickHoldInterval | Single value (1 byte): 0x00 = Default, `0x01` = Slower, `0x02` = Slowest|\n| 0x1A | ListeningModeConfigs | Single value (1 byte): bitmask, Off mode = `0x01`, ANC=`0x02`, Transparency = 0x04, Adaptive = `0x08` |\n| 0x1B | OneBudANCMode | Single value (1 byte): `0x01` = enabled, `0x02` = disabled |\n| 0x1C | CrownRotationDirection | Single value (1 byte): `0x01` = reversed, `0x02` = default |\n| 0x0D | ListeningMode | Single value (1 byte): 1 = Off, 2 = noise cancellation, 3 = transparency, 4 = adaptive |\n| 0x1E | AutoAnswerMode | Single value (1 byte) |\n| 0x1F | Chime Volume | Single value (1 byte): 0 to 100|\n| 0x23 | VolumeSwipeInterval | Single value (1 byte): 0x00 = Default, `0x01` = Longer, `0x02` = Longest |\n| 0x24 | Call Management Config | Single value (1 byte) |\n| 0x25 | VolumeSwipeMode | Single value (1 byte): `0x01` = enabled, `0x02` = disabled |\n| 0x26 | Adaptive Volume Config | Single value (1 byte): `0x01` = enabled, `0x02` = disabled |\n| 0x27 | Software Mute config | Single value (1 byte) |\n| 0x28 | Conversation Detect config | Single value (1 byte): `0x01` = enabled, `0x02` = disabled |\n| 0x29 | SSL | Single value (1 byte) |\n| 0x2C | Hearing Aid Enrolled and Hearing Aid Enabled | Two values (2 bytes; First byte - enrolled, Second byte = enabled): `0x01` = enabled, `0x02` = disabled |\n| 0x2E | AutoANC Strength | Single value (1 byte): 0 to 100|\n| 0x2F | HPS Gain Swipe | Single value (1 byte) |\n| 0x30 | HRM enable/disable state | Single value (1 byte) |\n| 0x31 | In Case Tone config | Single value (1 byte): `0x01` = enabled, `0x02` = disabled |\n| 0x32 | Siri Multitone config | Single value (1 byte) |\n| 0x33 | Hearing Assist config | Single value (1 byte): `0x01` = enabled, `0x02` = disabled |\n| 0x34 | Allow Off Option for Listening Mode config | Single value (1 byte): `0x01` = enabled, `0x02` = disabled |\n| 0x35 | Sleep Detection config | Single value (1 byte): `0x01` = enabled, `0x02` = disabled |\n| 0x36 | Allow Auto Connect | Single value (1 byte): `0x01` = allow, `0x02` = disallow |\n| 0x39 | Raw Gestures config | Single value (1 byte): bitmask, single press = `0x01`, double press = `0x02`, triple press = `0x04`, long press = `0x08` |\n| 0x3C | System Siri message config | Single value (1 byte) |\n| 0x3E | Uplink EQ Bud config | Single value (1 byte) |\n| 0x3F | Uplink EQ Source config | Single value (1 byte) |\n| 0x40 | In Case Tone Volume | Single value (1 byte): 0 to 100 |\n| 0x41 | Disable Button Input config | Single value (1 byte) |\n\n\n\n> [!NOTE]\n> - These identifiers have been extracted from the macOS 15.4 Beta (24E5238a)'s bluetooth stack. \n> - I have already added the ranges of values a command takes that I know of. Feel free to experiemnt by sending the packets for which the range/values are not given here.\n"
        }
      ]
    },
    {
      "dir": ".github",
      "files": []
    },
    {
      "dir": ".github/workflows",
      "files": [
        {
          "name": "AirysDark-AI_prob.yml",
          "ext": ".yml",
          "size": 2431,
          "preview": "name: AirysDark-AI - Probe (LLM builds workflow)\n\non:\n  workflow_dispatch: {}\n\npermissions:\n  contents: write\n  pull-requests: write\n\n# Set TARGET to one of: android, linux, cmake, node, python, rust, dotnet, maven, flutter, go\nenv:\n  TARGET: \"android\"\n\njobs:\n  probe:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout (no credentials)\n        uses: actions/checkout@v4\n        with:\n          fetch-depth: 0\n          persist-credentials: false\n\n      - name: Setup Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: \"3.11\"\n\n      - name: Verify tools exist (added by detector PR)\n        shell: bash\n        run: |\n          set -euxo pipefail\n          test -f tools/AirysDark-AI_prob.py\n          test -f tools/AirysDark-AI_builder.py\n          ls -la tools\n          echo \"TARGET=$TARGET\"\n\n      - name: Run repo probe (AI-assisted)\n        shell: bash\n        env:\n          TARGET: ${{ env.TARGET }}\n          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}   # optional\n          OPENAI_MODEL: ${{ vars.OPENAI_MODEL || 'gpt-4o-mini' }}\n        run: |\n          set -euxo pipefail\n          python3 tools/AirysDark-AI_prob.py\n\n      - name: Upload probe artifacts\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: airysdark-ai-probe-artifacts\n          if-no-files-found: warn\n          retention-days: 7\n          path: |\n            tools/airysdark_ai_prob_report.json\n            tools/airysdark_ai_prob_report.log\n            tools/airysdark_ai_build_ai_response.txt\n            pr_body_build.md\n            .github/workflows/AirysDark-AI_build.yml\n\n      - name: Stage generated build workflow\n        id: diff\n        shell: bash\n        run: |\n          set -euxo pipefail\n          git add -A\n          if git diff --cached --quiet; then\n            echo \"changed=false\" >> \"$GITHUB_OUTPUT\"\n          else\n            echo \"changed=true\" >> \"$GITHUB_OUTPUT\"\n          fi\n\n      - name: Open PR with generated build workflow\n        if: steps.diff.outputs.changed == 'true'\n        uses: peter-evans/create-pull-request@v6\n        with:\n          token: ${{ secrets.BOT_TOKEN }}\n          branch: ai/airysdark-ai-build\n          commit-message: \"chore: add AirysDark-AI_build.yml (from probe)\"\n          title: \"AirysDark-AI: add build workflow (from probe)\"\n          body-path: pr_body_build.md\n          labels: \"automation, ci\"\n"
        },
        {
          "name": "AirysDark-AI_detector.yml",
          "ext": ".yml",
          "size": 3027,
          "preview": "name: AirysDark-AI - Detector (bootstrap)\n\non:\n  workflow_dispatch: {}\n\npermissions:\n  contents: write\n  pull-requests: write\n\njobs:\n  detect:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout (no credentials)\n        uses: actions/checkout@v4\n        with:\n          fetch-depth: 0\n          persist-credentials: false\n\n      - name: Setup Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: \"3.11\"\n\n      - name: Install jq (for JSON formatting)\n        run: |\n          set -euxo pipefail\n          sudo apt-get update\n          sudo apt-get install -y jq\n\n      # Fetch once here ONLY. The generated PROB workflow will NOT re-fetch tools.\n      - name: Fetch tools.tar (ONLY here)\n        run: |\n          set -euxo pipefail\n          mkdir -p tools\n          curl -fL https://raw.githubusercontent.com/AirysDark-AI/AirysDark-AI_builder/main/tools/tools.tar -o /tmp/tools.tar\n          tar -xvf /tmp/tools.tar -C tools\n          ls -la tools\n\n      - name: Run detector (generates AirysDark-AI_prob.yml + logs)\n        run: |\n          set -euxo pipefail\n          python3 tools/AirysDark-AI_detector.py\n\n      - name: Compose PR body with detected types\n        run: |\n          set -euo pipefail\n          echo \"### AirysDark-AI: detector results\" > pr_body.md\n          echo \"\" >> pr_body.md\n          if [ -f tools/airysdark_ai_scan.json ]; then\n            echo \"**Detected build types:**\" >> pr_body.md\n            types=$(jq -r '.types[]?' tools/airysdark_ai_scan.json 2>/dev/null || true)\n            if [ -n \"$types\" ]; then\n              while IFS= read -r t; do\n                echo \"- $t\" >> pr_body.md\n              done <<< \"$types\"\n            else\n              echo \"- (none)\" >> pr_body.md\n            fi\n          else\n            echo \"_No detector JSON found (tools/airysdark_ai_scan.json)._ \" >> pr_body.md\n          fi\n          echo \"\" >> pr_body.md\n          echo \"**Next steps:**\" >> pr_body.md\n          echo \"1. Edit \\`.github/workflows/AirysDark-AI_prob.yml\\` and set **env.TARGET** (e.g. \\`android\\`, \\`linux\\`, \\`cmake\\`).\" >> pr_body.md\n          echo \"2. Merge this PR.\" >> pr_body.md\n          echo \"3. Manually run **AirysDark-AI - Probe (LLM builds workflow)** from the Actions tab.\" >> pr_body.md\n\n      - name: Stage detector outputs\n        id: diff\n        run: |\n          set -euxo pipefail\n          git add -A\n          if git diff --cached --quiet; then\n            echo \"changed=false\" >> \"$GITHUB_OUTPUT\"\n          else\n            echo \"changed=true\" >> \"$GITHUB_OUTPUT\"\n          fi\n\n      - name: Open PR with PROB workflow\n        if: steps.diff.outputs.changed == 'true'\n        uses: peter-evans/create-pull-request@v6\n        with:\n          token: ${{ secrets.BOT_TOKEN }}\n          branch: ai/airysdark-ai-prob\n          commit-message: \"chore: add AirysDark-AI_prob.yml + tools (bootstrap)\"\n          title: \"AirysDark-AI: add single PROB workflow + tools\"\n          body-path: pr_body.md\n          labels: automation, ci\n"
        }
      ]
    },
    {
      "dir": "tools",
      "files": [
        {
          "name": "AirysDark-AI_android.py",
          "ext": ".py",
          "size": 12270,
          "preview": "#!/usr/bin/env python3\n# AirysDark-AI_android.py \u2014 Android workflow generator + AI probe\n#\n# Modes:\n#   --mode probe-ai    -> Use AI (OpenAI -> llama.cpp -> heuristic) to derive BUILD_CMD,\n#                         write final Android workflow, and dump probe artifacts.\n#\n# Env used for AI:\n#   OPENAI_API_KEY, OPENAI_MODEL (default gpt-4o-mini)\n#   MODEL_PATH (llama gguf), LLAMA_CPP_BIN (llama-cli)\n#\n# Secrets expected in workflow when running final build:\n#   BOT_TOKEN (FG-PAT), optional OPENAI_API_KEY\n#\n# Files consumed (optional, produced by detector):\n#   tools/airysdark_ai_probe_inputs.json\n#\n# Files written:\n#   tools/android_probe.json\n#   tools/android_probe.log\n#   .github/workflows/AirysDark-AI_android.yml\n#\nimport os, json, pathlib, subprocess, shlex, re, textwrap, sys\n\nROOT = pathlib.Path(\".\").resolve()\nTOOLS = ROOT / \"tools\"\nWF    = ROOT / \".github\" / \"workflows\"\nTOOLS.mkdir(parents=True, exist_ok=True)\nWF.mkdir(parents=True, exist_ok=True)\n\nOPENAI_MODEL = os.getenv(\"OPENAI_MODEL\", \"gpt-4o-mini\")\nLLAMA_CPP_BIN = os.getenv(\"LLAMA_CPP_BIN\", \"llama-cli\")\nLLAMA_MODEL_PATH = os.getenv(\"MODEL_PATH\", \"models/tinyllama-1.1b-chat-v1.0.Q4_K_M.gguf\")\n\ndef sh(cmd, cwd=None):\n    p = subprocess.run(cmd, cwd=cwd, shell=True, text=True,\n                       stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n    return p.stdout, p.returncode\n\ndef read_text(p: pathlib.Path) -> str:\n    try:\n        return p.read_text(errors=\"ignore\")\n    except Exception:\n        return \"\"\n\ndef repo_tree(limit=400):\n    out, _ = sh(\"git ls-files || true\")\n    files = out.strip().splitlines()\n    return \"\\n\".join(files[:limit])\n\ndef load_probe_inputs():\n    p = TOOLS / \"airysdark_ai_probe_inputs.json\"\n    if p.exists():\n        try:\n            return json.loads(p.read_text())\n        except Exception:\n            return {}\n    return {}\n\ndef call_openai(prompt: str) -> str:\n    import requests\n    key = os.getenv(\"OPENAI_API_KEY\")\n    if not key:\n        raise RuntimeError(\"no_openai_key\")\n    url = \"https://api.openai.com/v1/chat/completions\"\n    payload = {\"model\": OPENAI_MODEL,\n               \"messages\": [{\"role\": \"user\", \"content\": prompt}],\n               \"temperature\": 0.2}\n    headers = {\"Authorization\": f\"Bearer {key}\", \"Content-Type\": \"application/json\"}\n    r = requests.post(url, headers=headers, json=payload, timeout=180)\n    if r.status_code >= 400:\n        raise RuntimeError(f\"openai_http_{r.status_code}:{r.text[:300]}\")\n    data = r.json()\n    return data[\"choices\"][0][\"message\"][\"content\"]\n\ndef call_llama(prompt: str) -> str:\n    mp = pathlib.Path(LLAMA_MODEL_PATH)\n    if not mp.exists():\n        raise RuntimeError(\"llama_model_missing\")\n    args = [LLAMA_CPP_BIN, \"-m\", str(mp), \"-p\", prompt, \"-n\", \"512\", \"--temp\", \"0.2\", \"-c\", \"4096\"]\n    out = subprocess.run(args, text=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n    if out.returncode != 0:\n        raise RuntimeError(\"llama_failed\")\n    return out.stdout\n\ndef parse_build_cmd_from_ai(text: str) -> str | None:\n    \"\"\"\n    Accepts answers that contain a command line; we try to pull the first plausible gradle invocation.\n    \"\"\"\n    # common patterns\n    m = re.search(r'(?:^|\\n)(?:cd [^\\n]+ && )?\\.?/gradlew[^\\n]+', text)\n    if m: return m.group(0).strip()\n    m = re.search(r'(?:^|\\n)cd [^\\n]+ && \\.\\/gradlew[^\\n]+', text)\n    if m: return m.group(0).strip()\n    # minimal\n    m = re.search(r'(?:^|\\n)\\.\\/gradlew\\s+[^\\n]+', text)\n    if m: return m.group(0).strip()\n    return None\n\ndef heuristic_fallback() -> str:\n    # last-resort guess\n    # try to find a gradlew nearest root\n    gw = None\n    if (ROOT/\"gradlew\").exists(): gw = ROOT/\"gradlew\"\n    else:\n        for p in ROOT.glob(\"**/gradlew\"):\n            gw = p; break\n    if gw is None:\n        return \"./gradlew assembleDebug --stacktrace\"\n    return f\"cd {shlex.quote(str(gw.parent))} && ./gradlew assembleDebug --stacktrace\"\n\ndef build_prompt(context):\n    tree = repo_tree()\n    hints = json.dumps(context, indent=2)\n    log_tail = \"\"\n    bl = ROOT / \"build.log\"\n    if bl.exists():\n        t = bl.read_text(errors=\"ignore\").splitlines()\n        log_tail = \"\\n\".join(t[-120:])\n    prompt = f\"\"\"\nYou are an Android build sherpa. Given this repo tree and hints, produce the single most likely command to build an installable app (APK/AAB) in CI. Prefer Debug if flavors exist.\n\nConstraints:\n- Output ONLY the shell command (NO explanation), e.g.:\n  cd app && ./gradlew :app:assembleDebug --stacktrace\n\nRepo tree (truncated):\n{tree}\n\nHints (from detector):\n{hints}\n\nRecent build.log tail (if any):\n{log_tail}\n\"\"\".strip()\n    return prompt\n\ndef write_final_workflow(build_cmd: str):\n    yml = r\"\"\"\nname: AirysDark-AI - Android (generated)\n\non:\n  workflow_dispatch: {}\n\npermissions:\n  contents: write\n  pull-requests: write\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          fetch-depth: 0\n          persist-credentials: false\n\n      - uses: actions/setup-python@v5\n        with:\n          python-version: \"3.11\"\n      - run: pip install requests\n\n      # Android toolchain\n      - uses: actions/setup-java@v4\n        with:\n          distribution: temurin\n          java-version: \"17\"\n      - uses: android-actions/setup-android@v3\n      - run: yes | sdkmanager --licenses\n      - run: sdkmanager \"platform-tools\" \"platforms;android-34\" \"build-tools;34.0.0\"\n\n      - name: Ensure AirysDark-AI tools (builder)\n        shell: bash\n        run: |\n          set -euo pipefail\n          mkdir -p tools\n          BASE_URL=\"https://raw.githubusercontent.com/AirysDark-AI/AirysDark-AI_builder/main/tools\"\n          [ -f tools/AirysDark-AI_builder.py ] || curl -fL \"$BASE_URL/AirysDark-AI_builder.py\" -o tools/AirysDark-AI_builder.py\n\n      - name: Build (capture)\n        id: build\n        run: |\n          set -euxo pipefail\n          CMD=\"__BUILD_CMD__\"\n          echo \"BUILD_CMD=$CMD\" >> \"$GITHUB_OUTPUT\"\n          set +e; bash -lc \"$CMD\" | tee build.log; EXIT=$?; set -e\n          echo \"EXIT_CODE=$EXIT\" >> \"$GITHUB_OUTPUT\"\n          [ -s build.log ] || echo \"(no build output captured)\" > build.log\n          exit 0\n        continue-on-error: true\n\n      - name: Upload build log\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: android-build-log\n          path: build.log\n          if-no-files-found: warn\n          retention-days: 7\n\n      - name: Upload common Android outputs\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: android-outputs\n          if-no-files-found: ignore\n          retention-days: 7\n          path: |\n            **/build/outputs/**/*.apk\n            **/build/outputs/**/*.aab\n            **/build/outputs/**/*.mapping.txt\n            **/build/outputs/**/mapping.txt\n\n      # --- AI auto-fix (OpenAI -> llama.cpp) ---\n      - name: Build llama.cpp (CMake, no CURL, in temp)\n        if: ${{ always() && steps.build.outputs.EXIT_CODE != '0' }}\n        run: |\n          set -euxo pipefail\n          TMP=\"${{ runner.temp }}\"\n          cd \"$TMP\"\n          rm -rf llama.cpp\n          git clone --depth=1 https://github.com/ggml-org/llama.cpp\n          cd llama.cpp\n          cmake -S . -B build -D CMAKE_BUILD_TYPE=Release -DLLAMA_CURL=OFF\n          cmake --build build -j\n          echo \"LLAMA_CPP_BIN=$PWD/build/bin/llama-cli\" >> $GITHUB_ENV\n\n      - name: Fetch GGUF model (TinyLlama)\n        if: ${{ always() && steps.build.outputs.EXIT_CODE != '0' }}\n        run: |\n          mkdir -p models\n          curl -L -o models/tinyllama-1.1b-chat-v1.0.Q4_K_M.gguf \\\n            https://huggingface.co/TheBloke/TinyLlama-1.1B-Chat-v1.0-GGUF/resolve/main/tinyllama-1.1b-chat-v1.0.Q4_K_M.gguf\n\n      - name: Attempt AI auto-fix (OpenAI -> llama fallback)\n        if: ${{ always() && steps.build.outputs.EXIT_CODE != '0' }}\n        env:\n          PROVIDER: openai\n          FALLBACK_PROVIDER: llama\n          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}\n          OPENAI_MODEL: ${{ vars.OPENAI_MODEL || 'gpt-4o-mini' }}\n          MODEL_PATH: models/tinyllama-1.1b-chat-v1.0.Q4_K_M.gguf\n          AI_BUILDER_ATTEMPTS: \"3\"\n          BUILD_CMD: ${{ steps.build.outputs.BUILD_CMD }}\n        run: python3 tools/AirysDark-AI_builder.py || true\n\n      - name: Upload AI patch (if any)\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: android-ai-patch\n          path: .pre_ai_fix.patch\n          if-no-files-found: ignore\n          retention-days: 7\n\n      - name: Check for changes\n        id: diff\n        run: |\n          git add -A\n          if git diff --cached --quiet; then\n            echo \"changed=false\" >> \"$GITHUB_OUTPUT\"\n          else:\n            echo \"changed=true\" >> \"$GITHUB_OUTPUT\"\n          fi\n\n      - name: Pin git remote with token (FG-PAT)\n        if: ${{ steps.diff.outputs.changed == 'true' }}\n        env:\n          BOT_TOKEN: ${{ secrets.BOT_TOKEN }}\n          REPO_SLUG: ${{ github.repository }}\n        run: |\n          set -euxo pipefail\n          git config --local --name-only --get-regexp '^http\\.https://github\\.com/\\.extraheader$' >/dev/null 2>&1 && \\\n            git config --local --unset-all http.https://github.com/.extraheader || true\n          git config --global --add safe.directory \"$GITHUB_WORKSPACE\"\n          git remote set-url origin \"https://x-access-token:${BOT_TOKEN}@github.com/${REPO_SLUG}.git\"\n          git config --global url.\"https://x-access-token:${BOT_TOKEN}@github.com/\".insteadOf \"https://github.com/\"\n          git remote -v\n\n      - name: Create PR with AI fixes\n        if: ${{ steps.diff.outputs.changed == 'true' }}\n        uses: peter-evans/create-pull-request@v6\n        with:\n          token: ${{ secrets.BOT_TOKEN }}\n          branch: ai/airysdark-ai-autofix-android\n          commit-message: \"chore: AirysDark-AI auto-fix (android)\"\n          title: \"AirysDark-AI: automated build fix (android)\"\n          body: |\n            This PR was opened automatically by a generated workflow after a failed build.\n            - Build command: ${{ steps.build.outputs.BUILD_CMD }}\n            - Captured the failing build log\n            - Proposed a minimal fix via AI\n            - Committed the changes for review\n          labels: automation, ci\n\"\"\".lstrip(\"\\n\").replace(\"__BUILD_CMD__\", build_cmd)\n    (WF / \"AirysDark-AI_android.yml\").write_text(yml)\n\ndef probe_ai():\n    log_lines = []\n    def log(x): \n        print(x)\n        log_lines.append(x)\n\n    # Build prompt from repo context + detector inputs\n    ctx = load_probe_inputs()\n    prompt = build_prompt(ctx)\n\n    # 1) Try OpenAI\n    build_cmd = None\n    try:\n        out = call_openai(prompt)\n        candidate = parse_build_cmd_from_ai(out)\n        if candidate:\n            build_cmd = candidate\n            log(\"[probe] OpenAI produced a build command.\")\n    except Exception as e:\n        log(f\"[probe] OpenAI error: {e}\")\n\n    # 2) Try llama.cpp\n    if not build_cmd:\n        try:\n            out = call_llama(prompt)\n            candidate = parse_build_cmd_from_ai(out)\n            if candidate:\n                build_cmd = candidate\n                log(\"[probe] llama.cpp produced a build command.\")\n        except Exception as e:\n            log(f\"[probe] llama.cpp error: {e}\")\n\n    # 3) Heuristic fallback\n    if not build_cmd:\n        build_cmd = heuristic_fallback()\n        log(\"[probe] Falling back to heuristic build command.\")\n\n    # Normalize to include --stacktrace\n    if \" --stacktrace\" not in build_cmd:\n        build_cmd = build_cmd.strip() + \" --stacktrace\"\n\n    # Write final workflow and probe artifacts\n    write_final_workflow(build_cmd)\n    (TOOLS / \"android_probe.json\").write_text(json.dumps({\"build_cmd\": build_cmd}, indent=2))\n    (TOOLS / \"android_probe.log\").write_text(\"\\n\".join(log_lines))\n\n    # Print for GHA output capture\n    print(f\"BUILD_CMD={build_cmd}\")\n\ndef main():\n    # Only implemented probe-ai for now\n    if len(sys.argv) >= 3 and sys.argv[1] == \"--mode\" and sys.argv[2] == \"probe-ai\":\n        return probe_ai()\n    print(\"Usage: AirysDark-AI_android.py --mode probe-ai\")\n    return 2\n\nif __name__ == \"__main__\":\n    sys.exit(main())"
        },
        {
          "name": "airysdark_ai_detector_summary.txt",
          "ext": ".txt",
          "size": 174,
          "preview": "[2025-09-05T08:36:38.742830Z] AirysDark-AI detector scan\nDetected build types: android, linux, cmake\n\n- Android Gradle files: 4\n- CMake files: 3\n- Make/Meson/Ninja signals: 1"
        },
        {
          "name": "airysdark_ai_scan.json",
          "ext": ".json",
          "size": 1931,
          "preview": "{\n  \"timestamp\": \"2025-09-05T08:36:38.742830Z\",\n  \"types\": [\n    \"android\",\n    \"linux\",\n    \"cmake\"\n  ],\n  \"hits\": {\n    \"android_gradle\": [\n      \"android/settings.gradle.kts\",\n      \"android/build.gradle.kts\",\n      \"android/app/build.gradle.kts\",\n      \"folder-hint:android\"\n    ],\n    \"cmakelists\": [\n      \"CMakeLists.txt\",\n      \"linux/CMakeLists.txt\",\n      \"android/app/src/main/cpp/CMakeLists.txt\"\n    ],\n    \"make_like\": [\n      \"folder-hint:linux\"\n    ],\n    \"node\": [],\n    \"python\": [],\n    \"rust\": [],\n    \"dotnet\": [],\n    \"maven\": [],\n    \"flutter\": [],\n    \"go\": [],\n    \"bazel\": [],\n    \"scons\": [],\n    \"ninja\": []\n  },\n  \"cmake_flavors\": [\n    {\n      \"path\": \"CMakeLists.txt\",\n      \"flavor\": \"desktop\"\n    },\n    {\n      \"path\": \"linux/CMakeLists.txt\",\n      \"flavor\": \"desktop\"\n    },\n    {\n      \"path\": \"android/app/src/main/cpp/CMakeLists.txt\",\n      \"flavor\": \"desktop\"\n    }\n  ],\n  \"folder_hints\": [\n    \".github\",\n    \"airpods\",\n    \"android\",\n    \"app\",\n    \"assets\",\n    \"ble\",\n    \"com\",\n    \"composables\",\n    \"constants\",\n    \"cpp\",\n    \"docs\",\n    \"drawable\",\n    \"drawable-nodpi\",\n    \"drawable-v21\",\n    \"drawable-v24\",\n    \"font\",\n    \"fonts\",\n    \"gradle\",\n    \"head-tracking\",\n    \"imgs\",\n    \"include\",\n    \"java\",\n    \"kavishdevar\",\n    \"layout\",\n    \"librepods\",\n    \"libs\",\n    \"linux\",\n    \"main\",\n    \"me\",\n    \"media\",\n    \"meta-inf\",\n    \"mipmap-anydpi-v26\",\n    \"mipmap-hdpi\",\n    \"mipmap-mdpi\",\n    \"mipmap-xhdpi\",\n    \"mipmap-xxhdpi\",\n    \"mipmap-xxxhdpi\",\n    \"models\",\n    \"packaging\",\n    \"qr-code-generator\",\n    \"raw\",\n    \"raw-night\",\n    \"receivers\",\n    \"res\",\n    \"resources\",\n    \"screens\",\n    \"services\",\n    \"src\",\n    \"theme\",\n    \"thirdparty\",\n    \"tools\",\n    \"ui\",\n    \"utils\",\n    \"values\",\n    \"values-night\",\n    \"values-night-v31\",\n    \"values-v21\",\n    \"values-v31\",\n    \"widgets\",\n    \"workflows\",\n    \"wrapper\",\n    \"xml\",\n    \"xposed\",\n    \"yourco\"\n  ]\n}"
        },
        {
          "name": "AirysDark-AI_builder.py",
          "ext": ".py",
          "size": 543,
          "preview": "#!/usr/bin/env python3\n\"\"\"\nAirysDark-AI_builder.py\n- Placeholder AI auto-fix script to be used by generated build workflows later.\n- Keeps it simple & no external fetching here (per your design).\n\"\"\"\nimport os, sys\n\ndef main():\n    print(\"AirysDark-AI_builder running...\")\n    build_cmd = os.getenv(\"BUILD_CMD\",\"\")\n    print(\"Would attempt fix for build cmd:\", build_cmd)\n    # Your future patch-application logic goes here (OpenAI \u2192 llama fallback, unified diff application, etc.)\n    return 0\n\nif __name__==\"__main__\":\n    sys.exit(main())"
        },
        {
          "name": "AirysDark-AI_prob.py",
          "ext": ".py",
          "size": 9867,
          "preview": "#!/usr/bin/env python3\n\"\"\"\nAirysDark-AI_prob.py (Step 2)\n- Reads detector logs + JSON\n- Deep-scans entire repo (all folders/subfolders)\n- Builds a concise report and (optionally) asks the AI to produce a build workflow YAML\n- Writes:\n    .github/workflows/AirysDark-AI_build.yml\n    tools/airysdark_ai_prob_report.json\n    tools/airysdark_ai_prob_report.log\n    tools/airysdark_ai_build_ai_response.txt\n    pr_body_build.md\n\"\"\"\nimport os, json, pathlib, datetime, re, sys\n\nROOT  = pathlib.Path(os.getenv(\"PROJECT_DIR\", \".\")).resolve()\nTOOLS = ROOT / \"tools\"\nWF    = ROOT / \".github\" / \"workflows\"\nWF.mkdir(parents=True, exist_ok=True)\nTOOLS.mkdir(parents=True, exist_ok=True)\n\nTARGET = os.getenv(\"TARGET\", \"__SET_ME__\").strip()\n\nREPORT_JSON = TOOLS / \"airysdark_ai_prob_report.json\"\nREPORT_LOG  = TOOLS / \"airysdark_ai_prob_report.log\"\nAI_OUT_TXT  = TOOLS / \"airysdark_ai_build_ai_response.txt\"\nPR_BODY     = ROOT / \"pr_body_build.md\"\nOUT_WORKFLOW= WF / \"AirysDark-AI_build.yml\"\n\nOPENAI_API_KEY = os.getenv(\"OPENAI_API_KEY\", \"\").strip()\nOPENAI_MODEL   = os.getenv(\"OPENAI_MODEL\", \"gpt-4o-mini\").strip()\n\ndef read_text(p: pathlib.Path, max_bytes=200_000):\n    try:\n        b = p.read_bytes()[:max_bytes]\n        return b.decode(\"utf-8\", errors=\"ignore\")\n    except Exception:\n        try:\n            return p.read_text(errors=\"ignore\")\n        except Exception:\n            return \"\"\n\ndef list_repo():\n    items = []\n    for root, dirs, files in os.walk(ROOT):\n        if \".git\" in dirs:\n            dirs.remove(\".git\")\n        r = pathlib.Path(root)\n        rel_dir = str(r.relative_to(ROOT)) or \".\"\n        dir_entry = {\"dir\": rel_dir, \"files\": []}\n        for fn in files:\n            path = r / fn\n            try:\n                size = path.stat().st_size\n            except Exception:\n                size = -1\n            ext = pathlib.Path(fn).suffix.lower()\n            info = {\"name\": fn, \"ext\": ext, \"size\": size}\n            if size >= 0 and size <= 200*1024 and ext in (\".gradle\",\".kts\",\".xml\",\".json\",\".yml\",\".yaml\",\".cmake\",\".txt\",\".md\",\".toml\",\".ini\",\".c\",\".cpp\",\".h\",\".hpp\",\".java\",\".kt\",\".py\"):\n                info[\"preview\"] = read_text(path, 40_000)\n            dir_entry[\"files\"].append(info)\n        items.append(dir_entry)\n    return items\n\ndef load_detector_data():\n    scan_log = (TOOLS / \"airysdark_ai_scan.log\").read_text(errors=\"ignore\") if (TOOLS / \"airysdark_ai_scan.log\").exists() else \"\"\n    scan_json = {}\n    for candidate in [\"airysdark_ai_scan.json\", \"airysdark_ai_detected.json\"]:\n        p = TOOLS / candidate\n        if p.exists():\n            try:\n                scan_json = json.loads(p.read_text(errors=\"ignore\"))\n                break\n            except Exception:\n                pass\n    return scan_log, scan_json\n\ndef write_probe_reports(structure, detector_log, detector_json):\n    ts = datetime.datetime.utcnow().isoformat() + \"Z\"\n    REPORT_JSON.write_text(json.dumps({\"timestamp\": ts,\"target\": TARGET,\"detector_log\": detector_log,\"detector_json\": detector_json,\"structure\": structure}, indent=2))\n    with REPORT_LOG.open(\"w\", encoding=\"utf-8\") as f:\n        f.write(f\"[{ts}] AirysDark-AI probe report (target={TARGET})\\n\\n\")\n        f.write(\"Detected types (from detector): \" + \", \".join(detector_json.get(\"types\", [])) + \"\\n\\n\")\n        f.write(\"Directory structure summary:\\n\")\n        for d in structure[:200]:\n            f.write(f\"- {d['dir']}/\\n\")\n            for fi in d[\"files\"][:30]:\n                f.write(f\"   {fi['name']} (ext={fi['ext']}, size={fi['size']})\\n\")\n        f.write(\"\\n--- End of probe ---\\n\")\n\ndef extract_yaml_from_text(text):\n    m = re.search(r\"```yaml\\s+(.+?)```\", text, flags=re.S|re.I)\n    if m: return m.group(1).strip()\n    m = re.search(r\"```[^\\n]*\\n(.+?)```\", text, flags=re.S)\n    if m: return m.group(1).strip()\n    if text.strip().lower().startswith((\"name:\", \"on:\", \"permissions:\", \"jobs:\", \"env:\")):\n        return text.strip()\n    return \"\"\n\ndef heuristic_template(target:str) -> str:\n    base_cmd = {\n        \"android\": \"bash -lc './gradlew assembleDebug --stacktrace'\",\n        \"linux\":   \"bash -lc 'make -j || ( [ -d linux ] && make -C linux -j ) || true'\",\n        \"cmake\":   \"bash -lc 'cmake -S . -B build && cmake --build build -j'\",\n        \"node\":    \"bash -lc 'npm ci && npm run build --if-present'\",\n        \"python\":  \"bash -lc 'pip install -e . && (pytest || python -m pytest || true)'\",\n        \"rust\":    \"bash -lc 'cargo build --locked --all-targets --verbose'\",\n        \"dotnet\":  \"bash -lc 'dotnet restore && dotnet build -c Release'\",\n        \"maven\":   \"bash -lc 'mvn -B package --file pom.xml'\",\n        \"flutter\": \"bash -lc 'flutter build apk --debug'\",\n        \"go\":      \"bash -lc 'go build ./...'\",\n        \"bazel\":   \"bash -lc 'bazel build //... || true'\",\n        \"scons\":   \"bash -lc 'scons -j$(nproc) || true'\",\n        \"ninja\":   \"bash -lc 'ninja -C build || true'\",\n        \"unknown\": \"bash -lc 'echo no-known-build-system && exit 1'\"\n    }.get(target, \"bash -lc 'echo no-known-build-system && exit 1'\")\n\n    return f\"\"\"name: AirysDark-AI - Build ({target})\n\non:\n  workflow_dispatch: {{}}  # manual only\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          fetch-depth: 0\n          persist-credentials: false\n\n      - uses: actions/setup-python@v5\n        with: {{ python-version: \"3.11\" }}\n\n      - name: Install basics (best-effort)\n        run: |\n          sudo apt-get update\n          sudo apt-get install -y git curl ca-certificates\n\n      - name: Build ({target})\n        run: {base_cmd}\n\n      - name: Upload outputs (best-effort)\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: {target}-outputs\n          if-no-files-found: ignore\n          retention-days: 7\n          path: |\n            build/**\n            out/**\n            dist/**\n            target/**\n            **/build/**\n            **/out/**\n            **/dist/**\n            **/target/**\n            **/*.so\n            **/*.a\n            **/*.dll\n            **/*.dylib\n            **/*.exe\n            **/*.whl\n            **/outputs/**/*.apk\n            **/outputs/**/*.aab\n\"\"\"\n\ndef call_openai(messages):\n    import requests\n    url = \"https://api.openai.com/v1/chat/completions\"\n    headers = {\"Authorization\": f\"Bearer {OPENAI_API_KEY}\", \"Content-Type\":\"application/json\"}\n    data = {\"model\": OPENAI_MODEL, \"messages\": messages, \"temperature\": 0.2}\n    r = requests.post(url, headers=headers, json=data, timeout=180)\n    r.raise_for_status()\n    j = r.json()\n    return j[\"choices\"][0][\"message\"][\"content\"]\n\ndef synthesize_workflow_with_ai(target, detector_log, detector_json, structure):\n    # Compact, bounded structure summary to fit context\n    lines = []\n    max_dirs = 150\n    max_files_per_dir = 25\n    for d in structure[:max_dirs]:\n        lines.append(f\"- {d['dir']}/\")\n        for fi in d[\"files\"][:max_files_per_dir]:\n            nm = fi[\"name\"]; ex = fi[\"ext\"]\n            lines.append(f\"   {nm} (ext={ex})\")\n    structure_text = \"\\n\".join(lines)\n\n    sys_prompt = (\n        \"You are a GitHub Actions expert. Given a repository scan and a target platform, \"\n        \"write a single, correct GitHub Actions workflow YAML file that builds the project.\"\n    )\n    user_prompt = f\"\"\"\nTarget platform: {target}\n\nConstraints:\n- The workflow's filename will be .github/workflows/AirysDark-AI_build.yml\n- It MUST trigger only on: workflow_dispatch\n- It MUST NOT auto-run on push or pull_request\n- It MUST include needed setup steps for {target} (e.g., Java/Android SDK, CMake, Node, etc.)\n- Prefer reproducible, standard steps. Avoid secrets or PAT use here.\n- Upload typical build artifacts (build/, out/, dist/, target/, APK/AAB/whl, etc.)\n- Output ONLY a YAML workflow (no backticks, no prose). If unsure, provide a safe baseline for {target}.\n\nDetector summary (truncated):\n{detector_log[:5000]}\n\nDetected types (JSON): {json.dumps(detector_json.get('types', []))}\n\nRepo structure (trimmed):\n{structure_text[:20000]}\n\"\"\".strip()\n\n    messages = [\n        {\"role\":\"system\",\"content\":sys_prompt},\n        {\"role\":\"user\",\"content\":user_prompt}\n    ]\n    text = call_openai(messages)\n    AI_OUT_TXT.write_text(text)\n    yaml = extract_yaml_from_text(text) or text.strip()\n    # Force manual-only trigger\n    if \"on:\" not in yaml.lower():\n        yaml = \"on:\\n  workflow_dispatch: {}\\n\" + yaml\n    yaml = re.sub(r\"\\bon:\\s*\\n(?:.*\\n)*?(?=jobs:|env:|permissions:|name:|$)\", \"on:\\n  workflow_dispatch: {}\\n\", yaml, count=1, flags=re.I)\n    return yaml\n\ndef main():\n    if TARGET == \"__SET_ME__\":  # guard\n        print(\"TARGET is not set. Edit env.TARGET in the workflow and run again.\", file=sys.stderr)\n        sys.exit(2)\n\n    detector_log, detector_json = load_detector_data()\n    structure = list_repo()\n    write_probe_reports(structure, detector_log, detector_json)\n\n    yaml_text = \"\"\n    if OPENAI_API_KEY:\n        try:\n            yaml_text = synthesize_workflow_with_ai(TARGET, detector_log, detector_json, structure)\n        except Exception as e:\n            print(f\"OpenAI failed: {e}\", file=sys.stderr)\n            yaml_text = heuristic_template(TARGET)\n    else:\n        yaml_text = heuristic_template(TARGET)\n\n    OUT_WORKFLOW.write_text(yaml_text)\n    print(f\"\u2705 Wrote workflow: {OUT_WORKFLOW}\")\n\n    PR_BODY.write_text(\n        f\"\"\"### AirysDark-AI: build workflow (from probe)\nTarget: **{TARGET}**\n\nThis PR adds `.github/workflows/AirysDark-AI_build.yml`, generated by the probe.\n- The workflow triggers **only** on `workflow_dispatch` (manual run required).\n- Review the steps and adjust if needed.\n\nArtifacts from the probe:\n- `tools/airysdark_ai_prob_report.json`\n- `tools/airysdark_ai_prob_report.log`\n- `tools/airysdark_ai_build_ai_response.txt` (raw LLM output, if AI was used)\n\"\"\"\n    )\n\nif __name__ == \"__main__\":\n    main()"
        },
        {
          "name": "AirysDark-AI_detector.py",
          "ext": ".py",
          "size": 9715,
          "preview": "#!/usr/bin/env python3\n# AirysDark-AI_detector.py \u2014 DETECT ONLY\n#\n# - Deep scans repo (all dirs; skips .git)\n# - Decides build types: android, linux, cmake, node, python, rust, dotnet, maven, flutter, go, bazel, scons, ninja, unknown\n# - Writes logs + JSON under tools/\n# - Generates exactly ONE workflow: .github/workflows/AirysDark-AI_prob.yml\n#   \u2022 The workflow *does not* fetch tools; it assumes this detector PR added them\n#   \u2022 The workflow requires manual edit: env.TARGET must be set by the user before running\n\nimport os, json, pathlib, datetime, sys\n\nROOT  = pathlib.Path(os.getenv(\"PROJECT_DIR\", \".\")).resolve()\nTOOLS = ROOT / \"tools\"\nWF    = ROOT / \".github\" / \"workflows\"\nTOOLS.mkdir(parents=True, exist_ok=True)\nWF.mkdir(parents=True, exist_ok=True)\n\n# --- signal lists for CMake flavor ---\nANDROID_HINTS = (\n    \"android\", \"android_abi\", \"android_platform\", \"ndk\", \"cmake_android\",\n    \"gradle\", \"externalnativebuild\", \"find_library(log)\", \"log-lib\", \"loglib\"\n)\nDESKTOP_HINTS = (\n    \"add_executable\", \"pkgconfig\", \"find_package(\", \"threads\", \"pthread\",\n    \"x11\", \"wayland\", \"gtk\", \"qt\", \"set(cmake_system_name linux\"\n)\n\ndef read_text_safe(p: pathlib.Path) -> str:\n    try: return p.read_text(errors=\"ignore\")\n    except Exception: return \"\"\n\ndef cmakelists_flavor(cm_txt: str) -> str:\n    t = cm_txt.lower()\n    if any(h in t for h in ANDROID_HINTS): return \"android\"\n    if any(h in t for h in DESKTOP_HINTS): return \"desktop\"\n    return \"desktop\"\n\ndef deep_scan():\n    hits = {k: [] for k in [\n        \"android_gradle\",\"cmakelists\",\"make_like\",\"node\",\"python\",\"rust\",\n        \"dotnet\",\"maven\",\"flutter\",\"go\",\"bazel\",\"scons\",\"ninja\"\n    ]}\n    cmake_flavors = []\n    folder_hints = set()\n\n    for root, dirs, files in os.walk(ROOT):\n        if \".git\" in dirs: dirs.remove(\".git\")\n        r = pathlib.Path(root)\n        for part in r.relative_to(ROOT).parts:\n            if part: folder_hints.add(part.lower())\n        for fn in files:\n            low = fn.lower()\n            rel = (r / fn).relative_to(ROOT)\n            if low == \"gradlew\" or low.startswith(\"build.gradle\") or low.startswith(\"settings.gradle\"):\n                hits[\"android_gradle\"].append(str(rel))\n            if low == \"cmakelists.txt\":\n                hits[\"cmakelists\"].append(str(rel))\n                cmake_flavors.append({\"path\": str(rel), \"flavor\": cmakelists_flavor(read_text_safe(r / fn))})\n            if low in (\"makefile\",\"gnumakefile\",\"meson.build\",\"build.ninja\") or low.endswith(\".mk\"):\n                hits[\"make_like\"].append(str(rel))\n            if low == \"package.json\":\n                hits[\"node\"].append(str(rel))\n            if low in (\"pyproject.toml\",\"setup.py\"):\n                hits[\"python\"].append(str(rel))\n            if low == \"cargo.toml\":\n                hits[\"rust\"].append(str(rel))\n            if low.endswith(\".sln\") or low.endswith(\".csproj\") or low.endswith(\".fsproj\"):\n                hits[\"dotnet\"].append(str(rel))\n            if low == \"pom.xml\":\n                hits[\"maven\"].append(str(rel))\n            if low == \"pubspec.yaml\":\n                hits[\"flutter\"].append(str(rel))\n            if low == \"go.mod\":\n                hits[\"go\"].append(str(rel))\n            if low in (\"workspace\",\"workspace.bazel\",\"module.bazel\") or fn in (\"BUILD\",\"BUILD.bazel\"):\n                hits[\"bazel\"].append(str(rel))\n            if low in (\"sconstruct\",\"sconscript\"):\n                hits[\"scons\"].append(str(rel))\n            if low == \"build.ninja\":\n                hits[\"ninja\"].append(str(rel))\n\n    # Folder name hints\n    if \"android\" in folder_hints: hits[\"android_gradle\"].append(\"folder-hint:android\")\n    if \"linux\"   in folder_hints: hits[\"make_like\"].append(\"folder-hint:linux\")\n\n    return hits, cmake_flavors, sorted(folder_hints)\n\ndef decide_types(hits, cmake_flavors):\n    types = set()\n    if hits[\"android_gradle\"]: types.add(\"android\")\n    if hits[\"cmakelists\"]:\n        types.add(\"cmake\")\n        if any(x[\"flavor\"] == \"desktop\" for x in cmake_flavors): types.add(\"linux\")\n    if hits[\"make_like\"]: types.add(\"linux\")\n    if hits[\"node\"]:      types.add(\"node\")\n    if hits[\"python\"]:    types.add(\"python\")\n    if hits[\"rust\"]:      types.add(\"rust\")\n    if hits[\"dotnet\"]:    types.add(\"dotnet\")\n    if hits[\"maven\"]:     types.add(\"maven\")\n    if hits[\"flutter\"]:   types.add(\"flutter\")\n    if hits[\"go\"]:        types.add(\"go\")\n    if hits[\"bazel\"]:     types.add(\"bazel\")\n    if hits[\"scons\"]:     types.add(\"scons\")\n    if hits[\"ninja\"]:     types.add(\"ninja\")\n    if not types:         types.add(\"unknown\")\n    order = [\"android\",\"linux\",\"cmake\",\"node\",\"python\",\"rust\",\"dotnet\",\"maven\",\"flutter\",\"go\",\"bazel\",\"scons\",\"ninja\",\"unknown\"]\n    return [t for t in order if t in types]\n\ndef write_artifacts(hits, cmake_flavors, folder_hints, types):\n    ts = datetime.datetime.utcnow().isoformat()+\"Z\"\n\n    # Human summary\n    summary = [f\"[{ts}] AirysDark-AI detector scan\", \"Detected build types: \" + \", \".join(types), \"\"]\n    def add(label, key):\n        if hits[key]:\n            summary.append(f\"- {label}: {len(hits[key])}\")\n    add(\"Android Gradle files\", \"android_gradle\")\n    add(\"CMake files\", \"cmakelists\")\n    add(\"Make/Meson/Ninja signals\", \"make_like\")\n    add(\"Node projects\", \"node\")\n    add(\"Python projects\", \"python\")\n    add(\"Rust projects\", \"rust\")\n    add(\".NET projects\", \"dotnet\")\n    add(\"Maven projects\", \"maven\")\n    add(\"Flutter projects\", \"flutter\")\n    add(\"Go projects\", \"go\")\n    add(\"Bazel signals\", \"bazel\")\n    add(\"SCons signals\", \"scons\")\n    add(\"Ninja files\", \"ninja\")\n\n    log = summary[:] + [\"\", \"Detailed file hits:\"]\n    for k, arr in hits.items():\n        if arr:\n            log.append(f\"{k}:\")\n            for p in arr:\n                log.append(f\"  - {p}\")\n    if cmake_flavors:\n        log.append(\"\")\n        log.append(\"cmake_flavors:\")\n        for x in cmake_flavors:\n            log.append(f\"  - {x['path']} -> {x['flavor']}\")\n\n    (TOOLS / \"airysdark_ai_detector_summary.txt\").write_text(\"\\n\".join(summary))\n    (TOOLS / \"airysdark_ai_scan.log\").write_text(\"\\n\".join(log))\n    (TOOLS / \"airysdark_ai_detected.json\").write_text(json.dumps({\"types\": types}, indent=2))\n    (TOOLS / \"airysdark_ai_scan.json\").write_text(json.dumps({\n        \"timestamp\": ts,\n        \"types\": types,\n        \"hits\": hits,\n        \"cmake_flavors\": cmake_flavors,\n        \"folder_hints\": folder_hints,\n    }, indent=2))\n\ndef generate_prob_workflow(types):\n    valid = types[:] or [\"unknown\"]\n    valid_list = \", \".join(valid)\n    yml = f\"\"\"name: AirysDark-AI - Probe (LLM builds workflow)\n\non:\n  workflow_dispatch: {{}}  # manual only\n\npermissions:\n  contents: write\n  pull-requests: write\n\n# IMPORTANT: set TARGET to one of: {valid_list}\nenv:\n  TARGET: \"__SET_ME__\"  # e.g. android / linux / cmake / node / python / ...\n\njobs:\n  probe:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout (no credentials)\n        uses: actions/checkout@v4\n        with:\n          fetch-depth: 0\n          persist-credentials: false\n\n      - name: Guard: ensure TARGET is set\n        run: |\n          if [ \"${{{{ env.TARGET }}}}\" = \"__SET_ME__\" ]; then\n            echo \"TARGET is not set. Edit this workflow to set env.TARGET (e.g. android) and run again.\"\n            exit 1\n          fi\n          echo \"TARGET=${{{{ env.TARGET }}}}\"\n\n      - name: Setup Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: \"3.11\"\n\n      - name: Verify tools exist (added by detector PR)\n        run: |\n          set -euxo pipefail\n          test -f tools/AirysDark-AI_prob.py\n          test -f tools/AirysDark-AI_builder.py\n          ls -la tools\n\n      - name: Run repo probe (AI-assisted)\n        env:\n          TARGET: ${{{{ env.TARGET }}}}\n          OPENAI_API_KEY: ${{{{ secrets.OPENAI_API_KEY }}}}   # optional; falls back to heuristic if absent\n          OPENAI_MODEL: ${{{{ vars.OPENAI_MODEL || 'gpt-4o-mini' }}}}\n        run: |\n          set -euxo pipefail\n          python3 tools/AirysDark-AI_prob.py\n\n      - name: Upload probe artifacts\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: airysdark-ai-probe-artifacts\n          if-no-files-found: warn\n          retention-days: 7\n          path: |\n            tools/airysdark_ai_prob_report.json\n            tools/airysdark_ai_prob_report.log\n            tools/airysdark_ai_build_ai_response.txt\n            pr_body_build.md\n            .github/workflows/AirysDark-AI_build.yml\n\n      - name: Stage generated build workflow\n        id: diff\n        run: |\n          set -euxo pipefail\n          git add -A\n          if git diff --cached --quiet; then\n            echo \"changed=false\" >> \"$GITHUB_OUTPUT\"\n          else\n            echo \"changed=true\" >> \"$GITHUB_OUTPUT\"\n          fi\n\n      - name: Open PR with generated build workflow\n        if: steps.diff.outputs.changed == 'true'\n        uses: peter-evans/create-pull-request@v6\n        with:\n          token: ${{{{ secrets.BOT_TOKEN }}}}   # Fine-grained PAT: contents+pull-requests on this repo\n          branch: ai/airysdark-ai-build\n          commit-message: \"chore: add AirysDark-AI_build.yml (from probe)\"\n          title: \"AirysDark-AI: add build workflow (from probe)\"\n          body-path: pr_body_build.md\n          labels: automation, ci\n\"\"\"\n    (WF / \"AirysDark-AI_prob.yml\").write_text(yml)\n\ndef main():\n    hits, cmake_flavors, folder_hints = deep_scan()\n    types = decide_types(hits, cmake_flavors)\n    write_artifacts(hits, cmake_flavors, folder_hints, types)\n    generate_prob_workflow(types)\n    print(\"Detected types:\", \", \".join(types))\n    print(f\"Wrote workflow: {WF / 'AirysDark-AI_prob.yml'}\")\n\nif __name__ == \"__main__\":\n    sys.exit(main())"
        },
        {
          "name": "airysdark_ai_detected.json",
          "ext": ".json",
          "size": 60,
          "preview": "{\n  \"types\": [\n    \"android\",\n    \"linux\",\n    \"cmake\"\n  ]\n}"
        }
      ]
    },
    {
      "dir": "src",
      "files": []
    },
    {
      "dir": "src/ble",
      "files": [
        {
          "name": "bluez_ble.h",
          "ext": ".h",
          "size": 2691,
          "preview": "#include \"ble/ble_backend.h\"\n#include \"ble/bluez_ble.h\"\n#include <dbus/dbus.h>\n#include <cstring>\n#include <string>\n#include <vector>\n\nstatic bool call_read_value(DBusConnection* conn, const std::string& char_path, std::vector<uint8_t>& out, std::string& err) {\n  DBusMessage* msg = dbus_message_new_method_call(\"org.bluez\", char_path.c_str(), \"org.bluez.GattCharacteristic1\", \"ReadValue\");\n  if (!msg) { err=\"dbus_message_new_method_call failed\"; return false; }\n  DBusMessageIter args, dict;\n  dbus_message_iter_init_append(msg, &args);\n  dbus_message_iter_open_container(&args, DBUS_TYPE_ARRAY, \"{sv}\", &dict); // empty options {}\n  dbus_message_iter_close_container(&args, &dict);\n\n  DBusError dbus_err; dbus_error_init(&dbus_err);\n  DBusMessage* reply = dbus_connection_send_with_reply_and_block(conn, msg, 5000, &dbus_err);\n  dbus_message_unref(msg);\n  if (!reply) {\n    err = dbus_err.message ? dbus_err.message : \"ReadValue call failed\";\n    dbus_error_free(&dbus_err);\n    return false;\n  }\n\n  DBusMessageIter it;\n  if (!dbus_message_iter_init(reply, &it) || dbus_message_iter_get_arg_type(&it) != DBUS_TYPE_ARRAY) {\n    err = \"Unexpected DBus reply\";\n    dbus_message_unref(reply);\n    return false;\n  }\n  DBusMessageIter arr;\n  dbus_message_iter_recurse(&it, &arr);\n  while (dbus_message_iter_get_arg_type(&arr) == DBUS_TYPE_BYTE) {\n    uint8_t b; dbus_message_iter_get_basic(&arr, &b);\n    out.push_back(b);\n    dbus_message_iter_next(&arr);\n  }\n  dbus_message_unref(reply);\n  return true;\n}\n\nstd::optional<std::vector<uint8_t>>\nbluez_read_characteristic(const std::string& char_object_path,\n                          std::string* error_out) {\n#ifdef PLATFORM_BLUEZ\n  DBusError err; dbus_error_init(&err);\n  DBusConnection* conn = dbus_bus_get(DBUS_BUS_SYSTEM, &err);\n  if (!conn) {\n    if (error_out) *error_out = err.message ? err.message : \"DBus connect failed\";\n    dbus_error_free(&err);\n    return std::nullopt;\n  }\n  std::vector<uint8_t> data; std::string e;\n  bool ok = call_read_value(conn, char_object_path, data, e);\n  if (!ok) { if (error_out) *error_out = e; return std::nullopt; }\n  return data;\n#else\n  (void)char_object_path; (void)error_out;\n  return std::nullopt;\n#endif\n}\n\nstd::optional<std::vector<uint8_t>>\nble_read_characteristic(const std::string& device_id_or_path,\n                        const std::string& service_uuid,\n                        const std::string& characteristic_uuid,\n                        std::string* error_out) {\n  (void)service_uuid; (void)characteristic_uuid;\n#ifdef PLATFORM_BLUEZ\n  return bluez_read_characteristic(device_id_or_path, error_out);\n#else\n  (void)device_id_or_path; (void)error_out;\n  return std::nullopt;\n#endif\n}"
        },
        {
          "name": "bluez_ble.cpp",
          "ext": ".cpp",
          "size": 2691,
          "preview": "#include \"ble/ble_backend.h\"\n#include \"ble/bluez_ble.h\"\n#include <dbus/dbus.h>\n#include <cstring>\n#include <string>\n#include <vector>\n\nstatic bool call_read_value(DBusConnection* conn, const std::string& char_path, std::vector<uint8_t>& out, std::string& err) {\n  DBusMessage* msg = dbus_message_new_method_call(\"org.bluez\", char_path.c_str(), \"org.bluez.GattCharacteristic1\", \"ReadValue\");\n  if (!msg) { err=\"dbus_message_new_method_call failed\"; return false; }\n  DBusMessageIter args, dict;\n  dbus_message_iter_init_append(msg, &args);\n  dbus_message_iter_open_container(&args, DBUS_TYPE_ARRAY, \"{sv}\", &dict); // empty options {}\n  dbus_message_iter_close_container(&args, &dict);\n\n  DBusError dbus_err; dbus_error_init(&dbus_err);\n  DBusMessage* reply = dbus_connection_send_with_reply_and_block(conn, msg, 5000, &dbus_err);\n  dbus_message_unref(msg);\n  if (!reply) {\n    err = dbus_err.message ? dbus_err.message : \"ReadValue call failed\";\n    dbus_error_free(&dbus_err);\n    return false;\n  }\n\n  DBusMessageIter it;\n  if (!dbus_message_iter_init(reply, &it) || dbus_message_iter_get_arg_type(&it) != DBUS_TYPE_ARRAY) {\n    err = \"Unexpected DBus reply\";\n    dbus_message_unref(reply);\n    return false;\n  }\n  DBusMessageIter arr;\n  dbus_message_iter_recurse(&it, &arr);\n  while (dbus_message_iter_get_arg_type(&arr) == DBUS_TYPE_BYTE) {\n    uint8_t b; dbus_message_iter_get_basic(&arr, &b);\n    out.push_back(b);\n    dbus_message_iter_next(&arr);\n  }\n  dbus_message_unref(reply);\n  return true;\n}\n\nstd::optional<std::vector<uint8_t>>\nbluez_read_characteristic(const std::string& char_object_path,\n                          std::string* error_out) {\n#ifdef PLATFORM_BLUEZ\n  DBusError err; dbus_error_init(&err);\n  DBusConnection* conn = dbus_bus_get(DBUS_BUS_SYSTEM, &err);\n  if (!conn) {\n    if (error_out) *error_out = err.message ? err.message : \"DBus connect failed\";\n    dbus_error_free(&err);\n    return std::nullopt;\n  }\n  std::vector<uint8_t> data; std::string e;\n  bool ok = call_read_value(conn, char_object_path, data, e);\n  if (!ok) { if (error_out) *error_out = e; return std::nullopt; }\n  return data;\n#else\n  (void)char_object_path; (void)error_out;\n  return std::nullopt;\n#endif\n}\n\nstd::optional<std::vector<uint8_t>>\nble_read_characteristic(const std::string& device_id_or_path,\n                        const std::string& service_uuid,\n                        const std::string& characteristic_uuid,\n                        std::string* error_out) {\n  (void)service_uuid; (void)characteristic_uuid;\n#ifdef PLATFORM_BLUEZ\n  return bluez_read_characteristic(device_id_or_path, error_out);\n#else\n  (void)device_id_or_path; (void)error_out;\n  return std::nullopt;\n#endif\n}"
        }
      ]
    },
    {
      "dir": "src/models",
      "files": [
        {
          "name": "winrt_ble.h",
          "ext": ".h",
          "size": 3219,
          "preview": "#include \"ble/ble_backend.h\"\n#include \"ble/winrt_ble.h\"\n#include <winrt/Windows.Devices.Bluetooth.h>\n#include <winrt/Windows.Devices.Bluetooth.GenericAttributeProfile.h>\n#include <winrt/Windows.Devices.Enumeration.h>\n#include <winrt/Windows.Storage.Streams.h>\n#include <codecvt>\n#include <locale>\n\nusing namespace winrt;\nusing namespace Windows::Devices::Bluetooth;\nusing namespace Windows::Devices::Bluetooth::GenericAttributeProfile;\nusing namespace Windows::Devices::Enumeration;\nusing namespace Windows::Storage::Streams;\n\nstatic std::wstring widen(const std::string& s) {\n  std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> conv;\n  return conv.from_bytes(s);\n}\nstatic std::string narrow(const std::wstring& ws) {\n  std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> conv;\n  return conv.to_bytes(ws);\n}\n\nstd::optional<std::vector<uint8_t>>\nwinrt_read_characteristic(const std::wstring& device_id_w,\n                          const std::wstring& service_uuid_w,\n                          const std::wstring& char_uuid_w,\n                          std::wstring* error_out) {\n#ifdef PLATFORM_WINRT\n  try {\n    init_apartment(apartment_type::multi_threaded);\n    auto dev = BluetoothLEDevice::FromIdAsync(hstring{device_id_w}).get();\n    if (!dev) { if (error_out) *error_out=L\"BluetoothLEDevice null\"; return std::nullopt; }\n    auto svcRes = dev.GetGattServicesForUuid(guid{service_uuid_w});\n    if (svcRes.Status()!=GattCommunicationStatus::Success || svcRes.Services().Size()==0) {\n      if (error_out) *error_out=L\"Service not found\"; return std::nullopt;\n    }\n    auto svc = svcRes.Services().GetAt(0);\n    auto chRes = svc.GetCharacteristicsForUuid(guid{char_uuid_w});\n    if (chRes.Status()!=GattCommunicationStatus::Success || chRes.Characteristics().Size()==0) {\n      if (error_out) *error_out=L\"Characteristic not found\"; return std::nullopt;\n    }\n    auto ch = chRes.Characteristics().GetAt(0);\n    auto read = ch.ReadValueAsync().get();\n    if (read.Status()!=GattCommunicationStatus::Success) {\n      if (error_out) *error_out=L\"Read failed\"; return std::nullopt;\n    }\n    auto buffer = read.Value();\n    DataReader reader = DataReader::FromBuffer(buffer);\n    std::vector<uint8_t> out(reader.UnconsumedBufferLength());\n    reader.ReadBytes(out);\n    return out;\n  } catch (const hresult_error& ex) {\n    if (error_out) *error_out = ex.message();\n    return std::nullopt;\n  } catch (...) {\n    if (error_out) *error_out = L\"Unknown exception\";\n    return std::nullopt;\n  }\n#else\n  (void)device_id_w; (void)service_uuid_w; (void)char_uuid_w; (void)error_out;\n  return std::nullopt;\n#endif\n}\n\nstd::optional<std::vector<uint8_t>>\nble_read_characteristic(const std::string& device_id,\n                        const std::string& service_uuid,\n                        const std::string& characteristic_uuid,\n                        std::string* error_out) {\n#ifdef PLATFORM_WINRT\n  std::wstring err;\n  auto res = winrt_read_characteristic(widen(device_id), widen(service_uuid), widen(characteristic_uuid), &err);\n  if (!res && error_out) *error_out = narrow(err);\n  return res;\n#else\n  (void)device_id; (void)service_uuid; (void)characteristic_uuid; (void)error_out;\n  return std::nullopt;\n#endif\n}"
        }
      ]
    },
    {
      "dir": "packaging",
      "files": [
        {
          "name": "installer.nsi",
          "ext": ".nsi",
          "size": 397
        }
      ]
    },
    {
      "dir": "include",
      "files": []
    },
    {
      "dir": "include/ble",
      "files": [
        {
          "name": "bluez_ble.h",
          "ext": ".h",
          "size": 219,
          "preview": "#pragma once\n#include <string>\n#include <vector>\n#include <optional>\n\nstd::optional<std::vector<uint8_t>>\nbluez_read_characteristic(const std::string& char_object_path,\n                          std::string* error_out);"
        },
        {
          "name": "winrt_ble.h",
          "ext": ".h",
          "size": 337,
          "preview": "#pragma once\n#include <string>\n#include <vector>\n#include <optional>\n\nstd::optional<std::vector<uint8_t>>\nwinrt_read_characteristic(const std::wstring& device_id_w,\n                          const std::wstring& service_uuid_w,\n                          const std::wstring& char_uuid_w,\n                          std::wstring* error_out);"
        },
        {
          "name": "ble_backend.h",
          "ext": ".h",
          "size": 395,
          "preview": "#pragma once\n#include <string>\n#include <vector>\n#include <optional>\n\n// Unified GATT read for both Windows & Linux backends.\nstd::optional<std::vector<uint8_t>>\nble_read_characteristic(const std::string& device_id,\n                        const std::string& service_uuid,\n                        const std::string& characteristic_uuid,\n                        std::string* error_out = nullptr);"
        }
      ]
    },
    {
      "dir": "include/models",
      "files": [
        {
          "name": "airpods_models.h",
          "ext": ".h",
          "size": 470,
          "preview": "#pragma once\n#include <cstdint>\n#include <string>\n#include <string_view>\n\nnamespace airpods {\n\nenum class Model : uint16_t {\n  Unknown      = 0x0000,\n  AirPods1     = 0x2002,\n  AirPods2     = 0x2008,\n  AirPods3     = 0x2015,\n  AirPods4     = 0x2019, // NEW\n  AirPods4ANC  = 0x201B, // NEW\n  AirPodsPro   = 0x2101,\n  AirPodsPro2  = 0x2201,\n  AirPodsMax   = 0x2301\n};\n\nstd::string_view ModelName(Model m);\nstd::string FallbackName(uint16_t raw_id);\n\n} // namespace airpods"
        }
      ]
    },
    {
      "dir": "android",
      "files": [
        {
          "name": "gradle.properties",
          "ext": ".properties",
          "size": 246
        },
        {
          "name": "settings.gradle.kts",
          "ext": ".kts",
          "size": 327,
          "preview": "pluginManagement {\n    repositories {\n        google()\n        gradlePluginPortal()\n        mavenCentral()\n    }\n}\ndependencyResolutionManagement {\n    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n    repositories {\n        google()\n        mavenCentral()\n    }\n}\nrootProject.name = \"BlueLibre\"\ninclude(\":app\")\n"
        },
        {
          "name": "gradlew.bat",
          "ext": ".bat",
          "size": 2674
        },
        {
          "name": "build.gradle.kts",
          "ext": ".kts",
          "size": 411,
          "preview": "plugins {\n    alias(cat.plugins.android.application) apply false\n    alias(cat.plugins.kotlin.android)      apply false\n    alias(cat.plugins.kotlin.compose)      apply false\n}\n\ntasks.register<Delete>(\"clean\") {\n    delete(rootProject.buildDir)\n}\n\nbuildscript {\n    repositories {\n        google()\n        mavenCentral()\n    }\n}\n\nallprojects {\n    repositories {\n        google()\n        mavenCentral()\n    }\n}\n"
        },
        {
          "name": ".gitignore",
          "ext": "",
          "size": 234
        }
      ]
    },
    {
      "dir": "android/gradle",
      "files": [
        {
          "name": "libs.versions.toml",
          "ext": ".toml",
          "size": 2143,
          "preview": "[versions]\nagp = \"8.5.2\"\nkotlin = \"2.0.20\"\ncompose-bom = \"2024.12.01\"\ncoreKtx = \"1.13.1\"\nlifecycle = \"2.8.7\"\nactivity = \"1.10.1\"\nnavigation = \"2.8.9\"\nmaterial3 = \"1.3.2\"\nconstraintlayout = \"2.2.1\"\ndynamicanimation = \"1.1.0\"\naccompanist = \"0.36.0\"\nemoji2 = \"1.3.0\" # transitive; fine\nhaze = \"1.5.3\"\nhiddenapibypass = \"6.1\"\nannotations = \"1.7.1\"\n\n[libraries]\nandroidx-core-ktx = { module = \"androidx.core:core-ktx\", version.ref = \"coreKtx\" }\n\nandroidx-lifecycle-runtime-ktx = { module = \"androidx.lifecycle:lifecycle-runtime-ktx\", version.ref = \"lifecycle\" }\nandroidx-activity-compose = { module = \"androidx.activity:activity-compose\", version.ref = \"activity\" }\n\n# Compose (use BOM)\nandroidx-compose-bom = { module = \"androidx.compose:compose-bom\", version.ref = \"compose-bom\" }\nandroidx-ui = { module = \"androidx.compose.ui:ui\" }\nandroidx-ui-graphics = { module = \"androidx.compose.ui:ui-graphics\" }\nandroidx-ui-tooling-preview = { module = \"androidx.compose.ui:ui-tooling-preview\" }\nandroidx-material3 = { module = \"androidx.compose.material3:material3\" }\n\nandroidx-navigation-compose = { module = \"androidx.navigation:navigation-compose\", version.ref = \"navigation\" }\nandroidx-constraintlayout = { module = \"androidx.constraintlayout:constraintlayout\", version.ref = \"constraintlayout\" }\nandroidx-dynamicanimation = { module = \"androidx.dynamicanimation:dynamicanimation\", version.ref = \"dynamicanimation\" }\n\naccompanist-permissions = { module = \"com.google.accompanist:accompanist-permissions\", version.ref = \"accompanist\" }\nhaze = { module = \"dev.chrisbanes.haze:haze-android\", version.ref = \"haze\" }\nhaze-materials = { module = \"dev.chrisbanes.haze:haze-materials-android\", version.ref = \"haze\" }\n\nhiddenapibypass = { module = \"org.lsposed.hiddenapibypass:hiddenapibypass\", version.ref = \"hiddenapibypass\" }\nannotations = { module = \"org.jetbrains:annotations\", version.ref = \"annotations\" }\n\n[plugins]\nandroid-application = { id = \"com.android.application\", version = \"8.4.0\" }\nkotlin-android = { id = \"org.jetbrains.kotlin.android\", version = \"1.9.0\" }\nkotlin-compose = { id = \"org.jetbrains.kotlin.plugin.compose\", version = \"1.9.0\" }\n"
        }
      ]
    },
    {
      "dir": "android/gradle/wrapper",
      "files": [
        {
          "name": "gradle-wrapper.properties",
          "ext": ".properties",
          "size": 199
        }
      ]
    },
    {
      "dir": "android/imgs",
      "files": [
        {
          "name": "customizations-2.png",
          "ext": ".png",
          "size": 166381
        },
        {
          "name": "settings-2.png",
          "ext": ".png",
          "size": 157290
        },
        {
          "name": "long-press.png",
          "ext": ".png",
          "size": 61440
        },
        {
          "name": "cd-moved-to-phone-island.png",
          "ext": ".png",
          "size": 71450
        },
        {
          "name": "debug.png",
          "ext": ".png",
          "size": 135029
        },
        {
          "name": "head-tracking-and-gestures.png",
          "ext": ".png",
          "size": 134208
        },
        {
          "name": "notification-and-qs.png",
          "ext": ".png",
          "size": 468826
        },
        {
          "name": "cd-connected-remotely-island.png",
          "ext": ".png",
          "size": 70877
        },
        {
          "name": "widget.png",
          "ext": ".png",
          "size": 1440589
        },
        {
          "name": "customizations-1.png",
          "ext": ".png",
          "size": 166744
        },
        {
          "name": "audio-connected-island.png",
          "ext": ".png",
          "size": 70548
        },
        {
          "name": "settings-1.png",
          "ext": ".png",
          "size": 176217
        },
        {
          "name": "popup.png",
          "ext": ".png",
          "size": 1253359
        }
      ]
    },
    {
      "dir": "android/app",
      "files": [
        {
          "name": "proguard-rules.pro",
          "ext": ".pro",
          "size": 750
        },
        {
          "name": "build.gradle.kts",
          "ext": ".kts",
          "size": 2252,
          "preview": "plugins {\n    alias(cat.plugins.android.application)\n    alias(cat.plugins.kotlin.android)\n    alias(cat.plugins.kotlin.compose)\n    id(\"kotlin-parcelize\")\n}\n// \u2026and in dependencies: implementation(cat.androidx.core.ktx) etc.\n\nandroid {\n    namespace = \"me.kavishdevar.librepods\"\n    compileSdk = 35\n\n    defaultConfig {\n        applicationId = \"me.kavishdevar.librepods\"\n        minSdk = 28\n        targetSdk = 35\n        versionCode = 7\n        versionName = \"0.1.0-rc.4\"\n    }\n\n    buildTypes {\n        release {\n            isMinifyEnabled = false\n            proguardFiles(\n                getDefaultProguardFile(\"proguard-android-optimize.txt\"),\n                \"proguard-rules.pro\"\n            )\n        }\n        debug { isMinifyEnabled = false }\n    }\n\n    compileOptions {\n        sourceCompatibility = JavaVersion.VERSION_17\n        targetCompatibility = JavaVersion.VERSION_17\n    }\n    kotlinOptions { jvmTarget = \"17\" }\n\n    buildFeatures {\n        compose = true\n        viewBinding = true\n    }\n\n    // Keep if you actually have CMakeLists.txt\n    externalNativeBuild {\n        cmake {\n            path = file(\"src/main/cpp/CMakeLists.txt\")\n            version = \"3.22.1\"\n        }\n    }\n\n    packaging {\n        // Helpful defaults\n        resources.excludes += setOf(\n            \"META-INF/AL2.0\", \"META-INF/LGPL2.1\",\n            \"META-INF/*.kotlin_module\"\n        )\n    }\n}\n\ndependencies {\n    implementation(cat.accompanist.permissions)\n    implementation(cat.hiddenapibypass)\n    implementation(cat.androidx.core.ktx)\n    implementation(cat.androidx.lifecycle.runtime.ktx)\n    implementation(cat.androidx.activity.compose)\n\n    implementation(platform(cat.androidx.compose.bom))\n    implementation(cat.androidx.ui)\n    implementation(cat.androidx.ui.graphics)\n    implementation(cat.androidx.ui.tooling.preview)\n    implementation(cat.androidx.material3)\n\n    implementation(cat.annotations)\n    implementation(cat.androidx.navigation.compose)\n\n    implementation(cat.androidx.constraintlayout)\n    implementation(cat.haze)\n    implementation(cat.haze.materials)\n    implementation(cat.androidx.dynamicanimation)\n\n    // Local AARs if any present\n    compileOnly(fileTree(mapOf(\"dir\" to \"libs\", \"include\" to listOf(\"*.aar\"))))\n}\n"
        },
        {
          "name": ".gitignore",
          "ext": "",
          "size": 6
        }
      ]
    },
    {
      "dir": "android/app/src",
      "files": []
    },
    {
      "dir": "android/app/src/main",
      "files": [
        {
          "name": "AndroidManifest.xml",
          "ext": ".xml",
          "size": 794,
          "preview": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"me.kavishdevar.librepods\">\n\n    <application\n        android:label=\"@string/app_name\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:allowBackup=\"true\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.Material3.DayNight.NoActionBar\">\n\n        <activity\n            android:name=\".MainActivity\"\n            android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n    </application>\n</manifest>\n"
        }
      ]
    },
    {
      "dir": "android/app/src/main/cpp",
      "files": [
        {
          "name": "CMakeLists.txt",
          "ext": ".txt",
          "size": 259,
          "preview": "cmake_minimum_required(VERSION 3.22)\nproject(airpods_core LANGUAGES CXX)\nset(CMAKE_CXX_STANDARD 20)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\nadd_library(airpods_core SHARED jni_bridge.cpp)\ntarget_include_directories(airpods_core PRIVATE ${CMAKE_CURRENT_LIST_DIR})\n"
        },
        {
          "name": "l2c_fcr_hook.h",
          "ext": ".h",
          "size": 795,
          "preview": "#pragma once\n\n#include <cstdint>\n#include <vector>\n\ntypedef int (*HookFunType)(void *func, void *replace, void **backup);\n\ntypedef int (*UnhookFunType)(void *func);\n\ntypedef void (*NativeOnModuleLoaded)(const char *name, void *handle);\n\ntypedef struct {\n    uint32_t version;\n    HookFunType hook_func;\n    UnhookFunType unhook_func;\n} NativeAPIEntries;\n\n[[maybe_unused]] typedef NativeOnModuleLoaded (*NativeInit)(const NativeAPIEntries *entries);\n\ntypedef struct t_l2c_ccb tL2C_CCB;\ntypedef struct t_l2c_lcb tL2C_LCB;\n\nuintptr_t loadHookOffset(const char* package_name);\nuintptr_t getModuleBase(const char *module_name);\nuintptr_t loadL2cuProcessCfgReqOffset();\nuintptr_t loadL2cCsmConfigOffset();\nuintptr_t loadL2cuSendPeerInfoReqOffset();\nbool findAndHookFunction(const char *library_path);\n"
        },
        {
          "name": "l2c_fcr_hook.cpp",
          "ext": ".cpp",
          "size": 14858,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n *\n * Copyright (C) 2025 LibrePods contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\n#include <cstdint>\n#include <cstring>\n#include <dlfcn.h>\n#include <android/log.h>\n#include <fstream>\n#include <string>\n#include <sys/system_properties.h>\n#include \"l2c_fcr_hook.h\"\n\n#define LOG_TAG \"AirPodsHook\"\n#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)\n#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)\n\nstatic HookFunType hook_func = nullptr;\n#define L2CEVT_L2CAP_CONFIG_REQ     4\n#define L2CEVT_L2CAP_CONFIG_RSP 15\n\nstruct t_l2c_lcb;\ntypedef struct _BT_HDR {\n    uint16_t event;\n    uint16_t len;\n    uint16_t offset;\n    uint16_t layer_specific;\n    uint8_t data[];\n} BT_HDR;\n\ntypedef struct {\n    uint8_t mode;\n    uint8_t tx_win_sz;\n    uint8_t max_transmit;\n    uint16_t rtrans_tout;\n    uint16_t mon_tout;\n    uint16_t mps;\n} tL2CAP_FCR;\n\n// Flow spec structure\ntypedef struct {\n    uint8_t  qos_present;\n    uint8_t  flow_direction;\n    uint8_t  service_type;\n    uint32_t token_rate;\n    uint32_t token_bucket_size;\n    uint32_t peak_bandwidth;\n    uint32_t latency;\n    uint32_t delay_variation;\n} FLOW_SPEC;\n\n// Configuration info structure\ntypedef struct {\n    uint16_t result;\n    uint16_t mtu_present;\n    uint16_t mtu;\n    uint16_t flush_to_present;\n    uint16_t flush_to;\n    uint16_t qos_present;\n    FLOW_SPEC qos;\n    uint16_t fcr_present;\n    tL2CAP_FCR fcr;\n    uint16_t fcs_present;\n    uint16_t fcs;\n    uint16_t ext_flow_spec_present;\n    FLOW_SPEC ext_flow_spec;\n} tL2CAP_CFG_INFO;\n\n// Basic L2CAP link control block\ntypedef struct {\n    bool wait_ack;\n    // Other FCR fields - not needed for our specific hook\n} tL2C_FCRB;\n\n// Forward declarations for needed types\nstruct t_l2c_rcb;\nstruct t_l2c_lcb;\n\ntypedef struct t_l2c_ccb {\n    struct t_l2c_ccb* p_next_ccb;  // Next CCB in the chain\n    struct t_l2c_ccb* p_prev_ccb;  // Previous CCB in the chain\n    struct t_l2c_lcb* p_lcb;       // Link this CCB belongs to\n    struct t_l2c_rcb* p_rcb;       // Registration CB for this Channel\n    uint16_t local_cid;            // Local CID\n    uint16_t remote_cid;           // Remote CID\n    uint16_t p_lcb_next;           // For linking CCBs to an LCB\n    uint8_t ccb_priority;          // Channel priority\n    uint16_t tx_mps;               // MPS for outgoing messages\n    uint16_t max_rx_mtu;           // Max MTU we will receive\n    // State variables\n    bool in_use;                   // True when channel active\n    uint8_t chnl_state;            // Channel state\n    uint8_t local_id;              // Transaction ID for local trans\n    uint8_t remote_id;             // Transaction ID for remote\n    uint8_t timer_entry;           // Timer entry\n    uint8_t is_flushable;          // True if flushable\n    // Configuration variables\n    uint16_t our_cfg_bits;         // Bitmap of local config bits\n    uint16_t peer_cfg_bits;        // Bitmap of peer config bits\n    uint16_t config_done;          // Configuration bitmask\n    uint16_t remote_config_rsp_result; // Remote config response result\n    tL2CAP_CFG_INFO our_cfg;       // Our saved configuration options\n    tL2CAP_CFG_INFO peer_cfg;      // Peer's saved configuration options\n    // Additional control fields\n    uint8_t remote_credit_count;   // Credits sent to peer\n    tL2C_FCRB fcrb;                // FCR info\n    bool ecoc;                     // Enhanced Credit-based mode\n} tL2C_CCB;\n\nstatic uint8_t (*original_l2c_fcr_chk_chan_modes)(void* p_ccb) = nullptr;\nstatic void (*original_l2cu_process_our_cfg_req)(tL2C_CCB* p_ccb, tL2CAP_CFG_INFO* p_cfg) = nullptr;\nstatic void (*original_l2c_csm_config)(tL2C_CCB* p_ccb, uint8_t event, void* p_data) = nullptr;\nstatic void (*original_l2cu_send_peer_info_req)(tL2C_LCB* p_lcb, uint16_t info_type) = nullptr;\n\nuint8_t fake_l2c_fcr_chk_chan_modes(void* p_ccb) {\n    LOGI(\"l2c_fcr_chk_chan_modes hooked, returning true.\");\n    return 1;\n}\n\nvoid fake_l2cu_process_our_cfg_req(tL2C_CCB* p_ccb, tL2CAP_CFG_INFO* p_cfg) {\n    original_l2cu_process_our_cfg_req(p_ccb, p_cfg);\n    p_ccb->our_cfg.fcr.mode = 0x00;\n    LOGI(\"Set FCR mode to Basic Mode in outgoing config request\");\n}\n\nvoid fake_l2c_csm_config(tL2C_CCB* p_ccb, uint8_t event, void* p_data) {\n    // Call the original function first to handle the specific code path where the FCR mode is checked\n    original_l2c_csm_config(p_ccb, event, p_data);\n\n    // Check if this happens during CONFIG_RSP event handling\n    if (event == L2CEVT_L2CAP_CONFIG_RSP) {\n        p_ccb->our_cfg.fcr.mode = p_ccb->peer_cfg.fcr.mode;\n        LOGI(\"Forced compatibility in l2c_csm_config: set our_mode=%d to match peer_mode=%d\",\n             p_ccb->our_cfg.fcr.mode, p_ccb->peer_cfg.fcr.mode);\n    }\n}\n\n// Replacement function that does nothing\nvoid fake_l2cu_send_peer_info_req(tL2C_LCB* p_lcb, uint16_t info_type) {\n    LOGI(\"Intercepted l2cu_send_peer_info_req for info_type 0x%04x - doing nothing\", info_type);\n    // Just return without doing anything\n    return;\n}\n\nuintptr_t loadHookOffset([[maybe_unused]] const char* package_name) {\n    const char* property_name = \"persist.librepods.hook_offset\";\n    char value[PROP_VALUE_MAX] = {0};\n\n    int len = __system_property_get(property_name, value);\n    if (len > 0) {\n        LOGI(\"Read hook offset from property: %s\", value);\n        uintptr_t offset;\n        char* endptr = nullptr;\n\n        const char* parse_start = value;\n        if (value[0] == '0' && (value[1] == 'x' || value[1] == 'X')) {\n            parse_start = value + 2;\n        }\n\n        errno = 0;\n        offset = strtoul(parse_start, &endptr, 16);\n\n        if (errno == 0 && endptr != parse_start && *endptr == '\\0' && offset > 0) {\n            LOGI(\"Parsed offset: 0x%x\", offset);\n            return offset;\n        }\n\n        LOGE(\"Failed to parse offset from property value: %s\", value);\n    }\n\n    LOGI(\"Using hardcoded fallback offset\");\n    return 0x00a55e30;\n}\n\nuintptr_t loadL2cuProcessCfgReqOffset() {\n    const char* property_name = \"persist.librepods.cfg_req_offset\";\n    char value[PROP_VALUE_MAX] = {0};\n\n    int len = __system_property_get(property_name, value);\n    if (len > 0) {\n        LOGI(\"Read l2cu_process_our_cfg_req offset from property: %s\", value);\n        uintptr_t offset;\n        char* endptr = nullptr;\n\n        const char* parse_start = value;\n        if (value[0] == '0' && (value[1] == 'x' || value[1] == 'X')) {\n            parse_start = value + 2;\n        }\n\n        errno = 0;\n        offset = strtoul(parse_start, &endptr, 16);\n\n        if (errno == 0 && endptr != parse_start && *endptr == '\\0' && offset > 0) {\n            LOGI(\"Parsed l2cu_process_our_cfg_req offset: 0x%x\", offset);\n            return offset;\n        }\n\n        LOGE(\"Failed to parse l2cu_process_our_cfg_req offset from property value: %s\", value);\n    }\n\n    // Return 0 if not found - we'll skip this hook\n    return 0;\n}\n\nuintptr_t loadL2cCsmConfigOffset() {\n    const char* property_name = \"persist.librepods.csm_config_offset\";\n    char value[PROP_VALUE_MAX] = {0};\n\n    int len = __system_property_get(property_name, value);\n    if (len > 0) {\n        LOGI(\"Read l2c_csm_config offset from property: %s\", value);\n        uintptr_t offset;\n        char* endptr = nullptr;\n\n        const char* parse_start = value;\n        if (value[0] == '0' && (value[1] == 'x' || value[1] == 'X')) {\n            parse_start = value + 2;\n        }\n\n        errno = 0;\n        offset = strtoul(parse_start, &endptr, 16);\n\n        if (errno == 0 && endptr != parse_start && *endptr == '\\0' && offset > 0) {\n            LOGI(\"Parsed l2c_csm_config offset: 0x%x\", offset);\n            return offset;\n        }\n\n        LOGE(\"Failed to parse l2c_csm_config offset from property value: %s\", value);\n    }\n\n    // Return 0 if not found - we'll skip this hook\n    return 0;\n}\n\nuintptr_t loadL2cuSendPeerInfoReqOffset() {\n    const char* property_name = \"persist.librepods.peer_info_req_offset\";\n    char value[PROP_VALUE_MAX] = {0};\n\n    int len = __system_property_get(property_name, value);\n    if (len > 0) {\n        LOGI(\"Read l2cu_send_peer_info_req offset from property: %s\", value);\n        uintptr_t offset;\n        char* endptr = nullptr;\n\n        const char* parse_start = value;\n        if (value[0] == '0' && (value[1] == 'x' || value[1] == 'X')) {\n            parse_start = value + 2;\n        }\n\n        errno = 0;\n        offset = strtoul(parse_start, &endptr, 16);\n\n        if (errno == 0 && endptr != parse_start && *endptr == '\\0' && offset > 0) {\n            LOGI(\"Parsed l2cu_send_peer_info_req offset: 0x%x\", offset);\n            return offset;\n        }\n\n        LOGE(\"Failed to parse l2cu_send_peer_info_req offset from property value: %s\", value);\n    }\n\n    // Return 0 if not found - we'll skip this hook\n    return 0;\n}\n\nuintptr_t getModuleBase(const char *module_name) {\n    FILE *fp;\n    char line[1024];\n    uintptr_t base_addr = 0;\n\n    fp = fopen(\"/proc/self/maps\", \"r\");\n    if (!fp) {\n        LOGE(\"Failed to open /proc/self/maps\");\n        return 0;\n    }\n\n    while (fgets(line, sizeof(line), fp)) {\n        if (strstr(line, module_name)) {\n            char *start_addr_str = line;\n            char *end_addr_str = strchr(line, '-');\n            if (end_addr_str) {\n                *end_addr_str = '\\0';\n                base_addr = strtoull(start_addr_str, nullptr, 16);\n                break;\n            }\n        }\n    }\n\n    fclose(fp);\n    return base_addr;\n}\n\nbool findAndHookFunction(const char *library_name) {\n    if (!hook_func) {\n        LOGE(\"Hook function not initialized\");\n        return false;\n    }\n\n    uintptr_t base_addr = getModuleBase(library_name);\n    if (!base_addr) {\n        LOGE(\"Failed to get base address of %s\", library_name);\n        return false;\n    }\n\n    // Load all offsets from system properties - no hardcoding\n    uintptr_t l2c_fcr_offset = loadHookOffset(nullptr);\n    uintptr_t l2cu_process_our_cfg_req_offset = loadL2cuProcessCfgReqOffset();\n    uintptr_t l2c_csm_config_offset = loadL2cCsmConfigOffset();\n    uintptr_t l2cu_send_peer_info_req_offset = loadL2cuSendPeerInfoReqOffset();\n\n    bool success = false;\n\n    // Hook l2c_fcr_chk_chan_modes - this is our primary hook\n    if (l2c_fcr_offset > 0) {\n        void* target = reinterpret_cast<void*>(base_addr + l2c_fcr_offset);\n        LOGI(\"Hooking l2c_fcr_chk_chan_modes at offset: 0x%x, base: %p, target: %p\",\n             l2c_fcr_offset, (void*)base_addr, target);\n\n        int result = hook_func(target, (void*)fake_l2c_fcr_chk_chan_modes, (void**)&original_l2c_fcr_chk_chan_modes);\n        if (result != 0) {\n            LOGE(\"Failed to hook l2c_fcr_chk_chan_modes, error: %d\", result);\n            return false;\n        }\n        LOGI(\"Successfully hooked l2c_fcr_chk_chan_modes\");\n        success = true;\n    } else {\n        LOGE(\"No valid offset for l2c_fcr_chk_chan_modes found, cannot proceed\");\n        return false;\n    }\n\n    // Hook l2cu_process_our_cfg_req if offset is available\n    if (l2cu_process_our_cfg_req_offset > 0) {\n        void* target = reinterpret_cast<void*>(base_addr + l2cu_process_our_cfg_req_offset);\n        LOGI(\"Hooking l2cu_process_our_cfg_req at offset: 0x%x, base: %p, target: %p\",\n             l2cu_process_our_cfg_req_offset, (void*)base_addr, target);\n\n        int result = hook_func(target, (void*)fake_l2cu_process_our_cfg_req, (void**)&original_l2cu_process_our_cfg_req);\n        if (result != 0) {\n            LOGE(\"Failed to hook l2cu_process_our_cfg_req, error: %d\", result);\n            // Continue even if this hook fails\n        } else {\n            LOGI(\"Successfully hooked l2cu_process_our_cfg_req\");\n        }\n    } else {\n        LOGI(\"Skipping l2cu_process_our_cfg_req hook as offset is not available\");\n    }\n\n    // Hook l2c_csm_config if offset is available\n    if (l2c_csm_config_offset > 0) {\n        void* target = reinterpret_cast<void*>(base_addr + l2c_csm_config_offset);\n        LOGI(\"Hooking l2c_csm_config at offset: 0x%x, base: %p, target: %p\",\n             l2c_csm_config_offset, (void*)base_addr, target);\n\n        int result = hook_func(target, (void*)fake_l2c_csm_config, (void**)&original_l2c_csm_config);\n        if (result != 0) {\n            LOGE(\"Failed to hook l2c_csm_config, error: %d\", result);\n            // Continue even if this hook fails\n        } else {\n            LOGI(\"Successfully hooked l2c_csm_config\");\n        }\n    } else {\n        LOGI(\"Skipping l2c_csm_config hook as offset is not available\");\n    }\n\n    // Hook l2cu_send_peer_info_req if offset is available\n    if (l2cu_send_peer_info_req_offset > 0) {\n        void* target = reinterpret_cast<void*>(base_addr + l2cu_send_peer_info_req_offset);\n        LOGI(\"Hooking l2cu_send_peer_info_req at offset: 0x%x, base: %p, target: %p\",\n             l2cu_send_peer_info_req_offset, (void*)base_addr, target);\n\n        int result = hook_func(target, (void*)fake_l2cu_send_peer_info_req, (void**)&original_l2cu_send_peer_info_req);\n        if (result != 0) {\n            LOGE(\"Failed to hook l2cu_send_peer_info_req, error: %d\", result);\n            // Continue even if this hook fails\n        } else {\n            LOGI(\"Successfully hooked l2cu_send_peer_info_req\");\n        }\n    } else {\n        LOGI(\"Skipping l2cu_send_peer_info_req hook as offset is not available\");\n    }\n\n    return success;\n}\n\nvoid on_library_loaded(const char *name, [[maybe_unused]] void *handle) {\n    if (strstr(name, \"libbluetooth_jni.so\")) {\n        LOGI(\"Detected Bluetooth JNI library: %s\", name);\n\n        bool hooked = findAndHookFunction(\"libbluetooth_jni.so\");\n        if (!hooked) {\n            LOGE(\"Failed to hook Bluetooth JNI library function\");\n        }\n    } else if (strstr(name, \"libbluetooth_qti.so\")) {\n        LOGI(\"Detected Bluetooth QTI library: %s\", name);\n\n        bool hooked = findAndHookFunction(\"libbluetooth_qti.so\");\n        if (!hooked) {\n            LOGE(\"Failed to hook Bluetooth QTI library function\");\n        }\n    }\n}\n\nextern \"C\" [[gnu::visibility(\"default\")]] [[gnu::used]]\nNativeOnModuleLoaded native_init(const NativeAPIEntries* entries) {\n    LOGI(\"L2C FCR Hook module initialized\");\n\n    hook_func = entries->hook_func;\n\n    return on_library_loaded;\n}"
        },
        {
          "name": "jni_bridge.cpp",
          "ext": ".cpp",
          "size": 1300,
          "preview": "#include <jni.h>\n#include <string>\n#include <cstdio>\n\nstatic const char* NameForModel(uint16_t id) {\n  switch (id) {\n    case 0x2002: return \"AirPods (1st gen)\";\n    case 0x2008: return \"AirPods (2nd gen)\";\n    case 0x2015: return \"AirPods (3rd gen)\";\n    case 0x2019: return \"AirPods 4\";\n    case 0x201B: return \"AirPods 4 (ANC)\";\n    case 0x2101: return \"AirPods Pro\";\n    case 0x2201: return \"AirPods Pro (2nd gen)\";\n    case 0x2301: return \"AirPods Max\";\n    default:     return nullptr;\n  }\n}\n\nstatic std::string FallbackName(uint16_t id) {\n  char buf[64];\n  std::snprintf(buf, sizeof(buf), \"AirPods (0x%04X)\", id);\n  return std::string(buf);\n}\n\nextern \"C\" JNIEXPORT jstring JNICALL\nJava_com_yourco_airpods_NativeBridge_parseAirPodsPayload(\n    JNIEnv* env, jobject, jbyteArray payload) {\n  const jsize n = env->GetArrayLength(payload);\n  if (n < 2) return env->NewStringUTF(\"AirPods (Unknown model)\");\n  std::string buf(n, '\\0');\n  env->GetByteArrayRegion(payload, 0, n, reinterpret_cast<jbyte*>(&buf[0]));\n  uint16_t model_id = static_cast<uint8_t>(buf[0]) | (static_cast<uint16_t>(static_cast<uint8_t>(buf[1]))<<8);\n  if (const char* known = NameForModel(model_id)) return env->NewStringUTF(known);\n  std::string pretty = FallbackName(model_id);\n  return env->NewStringUTF(pretty.c_str());\n}\n"
        }
      ]
    },
    {
      "dir": "android/app/src/main/res",
      "files": []
    },
    {
      "dir": "android/app/src/main/res/xml",
      "files": [
        {
          "name": "backup_rules.xml",
          "ext": ".xml",
          "size": 478,
          "preview": "<?xml version=\"1.0\" encoding=\"utf-8\"?><!--\n   Sample backup rules file; uncomment and customize as necessary.\n   See https://developer.android.com/guide/topics/data/autobackup\n   for details.\n   Note: This file is ignored for devices older that API 31\n   See https://developer.android.com/about/versions/12/backup-restore\n-->\n<full-backup-content>\n    <!--\n   <include domain=\"sharedpref\" path=\".\"/>\n   <exclude domain=\"sharedpref\" path=\"device.xml\"/>\n-->\n</full-backup-content>"
        },
        {
          "name": "noise_control_widget_info.xml",
          "ext": ".xml",
          "size": 764,
          "preview": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<appwidget-provider xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:description=\"@string/noise_control_widget_description\"\n    android:initialKeyguardLayout=\"@layout/noise_control_widget\"\n    android:initialLayout=\"@layout/noise_control_widget\"\n    android:minWidth=\"180dp\"\n    android:minHeight=\"40dp\"\n    android:previewImage=\"@drawable/example_appwidget_preview\"\n    android:previewLayout=\"@layout/noise_control_widget\"\n    android:resizeMode=\"horizontal\"\n    android:targetCellWidth=\"3\"\n    android:targetCellHeight=\"1\"\n    android:updatePeriodMillis=\"30000\"\n    android:widgetCategory=\"home_screen|keyguard\"\n    tools:ignore=\"UnusedAttribute\" />\n"
        },
        {
          "name": "data_extraction_rules.xml",
          "ext": ".xml",
          "size": 551,
          "preview": "<?xml version=\"1.0\" encoding=\"utf-8\"?><!--\n   Sample data extraction rules file; uncomment and customize as necessary.\n   See https://developer.android.com/about/versions/12/backup-restore#xml-changes\n   for details.\n-->\n<data-extraction-rules>\n    <cloud-backup>\n        <!-- TODO: Use <include> and <exclude> to control what is backed up.\n        <include .../>\n        <exclude .../>\n        -->\n    </cloud-backup>\n    <!--\n    <device-transfer>\n        <include .../>\n        <exclude .../>\n    </device-transfer>\n    -->\n</data-extraction-rules>"
        },
        {
          "name": "file_paths.xml",
          "ext": ".xml",
          "size": 99,
          "preview": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<paths>\n    <files-path name=\"logs\" path=\"logs/\"/>\n</paths>\n"
        },
        {
          "name": "battery_widget_info.xml",
          "ext": ".xml",
          "size": 745,
          "preview": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<appwidget-provider xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:description=\"@string/app_widget_description\"\n    android:initialKeyguardLayout=\"@layout/battery_widget\"\n    android:initialLayout=\"@layout/battery_widget\"\n    android:minWidth=\"180dp\"\n    android:minHeight=\"40dp\"\n    android:previewImage=\"@drawable/example_appwidget_preview\"\n    android:previewLayout=\"@layout/battery_widget\"\n    android:resizeMode=\"horizontal|vertical\"\n    android:targetCellWidth=\"3\"\n    android:targetCellHeight=\"1\"\n    android:updatePeriodMillis=\"30000\"\n    android:widgetCategory=\"home_screen|keyguard\"\n    tools:ignore=\"UnusedAttribute\" />\n"
        }
      ]
    },
    {
      "dir": "android/app/src/main/res/mipmap-xxxhdpi",
      "files": [
        {
          "name": "ic_launcher.png",
          "ext": ".png",
          "size": 8
        },
        {
          "name": "ic_launcher_round.png",
          "ext": ".png",
          "size": 8
        }
      ]
    },
    {
      "dir": "android/app/src/main/res/values-v21",
      "files": [
        {
          "name": "styles.xml",
          "ext": ".xml",
          "size": 623,
          "preview": "<resources>\n\n  <style name=\"Widget.LibrePods.AppWidget.Container\" parent=\"android:Widget\">\n    <item name=\"android:id\">@android:id/background</item>\n    <item name=\"android:padding\">?attr/appWidgetPadding</item>\n    <item name=\"android:background\">@drawable/app_widget_background</item>\n  </style>\n\n  <style name=\"Widget.LibrePods.AppWidget.InnerView\" parent=\"android:Widget\">\n    <item name=\"android:padding\">?attr/appWidgetPadding</item>\n    <item name=\"android:background\">@drawable/app_widget_inner_view_background</item>\n    <item name=\"android:textColor\">?android:attr/textColorPrimary</item>\n  </style>\n</resources>\n"
        }
      ]
    },
    {
      "dir": "android/app/src/main/res/font",
      "files": [
        {
          "name": "sf_pro.otf",
          "ext": ".otf",
          "size": 5405848
        },
        {
          "name": "hack.otf",
          "ext": ".otf",
          "size": 93944
        }
      ]
    },
    {
      "dir": "android/app/src/main/res/values-v31",
      "files": [
        {
          "name": "themes.xml",
          "ext": ".xml",
          "size": 561,
          "preview": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n  <!--\n    Having themes.xml for v31 variant because @android:dimen/system_app_widget_background_radius\n     and @android:dimen/system_app_widget_internal_padding requires API level 31\n    -->\n  <style name=\"Theme.LibrePods.AppWidgetContainerParent\" parent=\"@android:style/Theme.DeviceDefault.DayNight\">\n    <item name=\"appWidgetRadius\">@android:dimen/system_app_widget_background_radius</item>\n    <item name=\"appWidgetInnerRadius\">@android:dimen/system_app_widget_inner_radius</item>\n  </style>\n</resources>\n"
        },
        {
          "name": "styles.xml",
          "ext": ".xml",
          "size": 725,
          "preview": "<resources>\n\n  <style name=\"Widget.LibrePods.AppWidget.Container\" parent=\"android:Widget\">\n    <item name=\"android:id\">@android:id/background</item>\n    <item name=\"android:padding\">?attr/appWidgetPadding</item>\n    <item name=\"android:background\">@drawable/app_widget_background</item>\n    <item name=\"android:clipToOutline\">true</item>\n  </style>\n\n  <style name=\"Widget.LibrePods.AppWidget.InnerView\" parent=\"android:Widget\">\n    <item name=\"android:padding\">?attr/appWidgetPadding</item>\n    <item name=\"android:background\">@drawable/app_widget_inner_view_background</item>\n    <item name=\"android:textColor\">?android:attr/textColorPrimary</item>\n    <item name=\"android:clipToOutline\">true</item>\n  </style>\n</resources>\n"
        }
      ]
    },
    {
      "dir": "android/app/src/main/res/layout",
      "files": [
        {
          "name": "notification_expanded.xml",
          "ext": ".xml",
          "size": 1793,
          "preview": "<LinearLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:orientation=\"vertical\">\n\n    <TextView\n        android:id=\"@+id/notification_title\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:textSize=\"16sp\"\n        android:textColor=\"?android:attr/textColorPrimary\"\n        android:fontFamily=\"@font/sf_pro\" />\n\n    <LinearLayout\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:orientation=\"horizontal\"\n        android:paddingTop=\"8dp\"\n        android:gravity=\"center\">\n        <TextView\n            android:id=\"@+id/left_battery_notification\"\n            android:layout_width=\"0dp\"\n            android:layout_height=\"wrap_content\"\n            android:fontFamily=\"@font/sf_pro\"\n            android:textSize=\"15sp\"\n            android:paddingEnd=\"16dp\"\n            android:layout_weight=\"1\"\n            tools:ignore=\"RtlSymmetry\" />\n        <TextView\n            android:id=\"@+id/right_battery_notification\"\n            android:layout_width=\"0dp\"\n            android:layout_height=\"wrap_content\"\n            android:fontFamily=\"@font/sf_pro\"\n            android:textSize=\"15sp\"\n            android:layout_weight=\"1\"\n            android:paddingEnd=\"16dp\"\n            tools:ignore=\"RtlSymmetry\" />\n        <TextView\n            android:id=\"@+id/case_battery_notification\"\n            android:layout_width=\"0dp\"\n            android:layout_height=\"wrap_content\"\n            android:fontFamily=\"@font/sf_pro\"\n            android:layout_weight=\"1\"\n            android:textSize=\"15sp\" />\n    </LinearLayout>\n\n</LinearLayout>\n"
        },
        {
          "name": "notification.xml",
          "ext": ".xml",
          "size": 402,
          "preview": "<LinearLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:orientation=\"vertical\">\n\n    <TextView\n        android:id=\"@+id/notification_title\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:textSize=\"16sp\"\n        />\n</LinearLayout>\n"
        },
        {
          "name": "popup_window.xml",
          "ext": ".xml",
          "size": 4148,
          "preview": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:layout_margin=\"16.dp\"\n    android:id=\"@+id/linear_layout\"\n    android:orientation=\"vertical\"\n    android:background=\"@drawable/popup_shape\">\n\n    <androidx.constraintlayout.widget.ConstraintLayout\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:gravity=\"end\"\n        android:id=\"@+id/constraint_layout\"\n        android:paddingBottom=\"48dp\"\n        android:orientation=\"horizontal\">\n\n        <TextView\n            android:id=\"@+id/name\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:layout_marginTop=\"16dp\"\n            android:fontFamily=\"@font/sf_pro\"\n            android:gravity=\"center\"\n            android:text=\"Kavish's AirPods Pro\"\n            android:textColor=\"@color/popup_text\"\n\n            android:textSize=\"28sp\"\n            app:layout_constraintTop_toTopOf=\"parent\"\n            tools:ignore=\"HardcodedText\" />\n\n        <ImageButton\n            android:id=\"@+id/close_button\"\n            android:layout_width=\"28dp\"\n            android:layout_height=\"28dp\"\n            android:layout_marginTop=\"12dp\"\n            android:layout_marginEnd=\"24dp\"\n            android:background=\"@drawable/popup_button_shape\"\n            android:contentDescription=\"Close Button\"\n            android:src=\"@drawable/close\"\n            app:layout_constraintEnd_toEndOf=\"parent\"\n            app:layout_constraintTop_toTopOf=\"parent\"\n            tools:ignore=\"HardcodedText\" />\n    </androidx.constraintlayout.widget.ConstraintLayout>\n    <VideoView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:id=\"@+id/video\"\n        android:contentDescription=\"AirPods\"\n        android:src=\"@raw/connected\"\n        tools:ignore=\"HardcodedText\" />\n\n    <LinearLayout\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:orientation=\"horizontal\">\n\n        <!-- Left Half -->\n        <LinearLayout\n            android:layout_width=\"0dp\"\n            android:layout_height=\"wrap_content\"\n            android:layout_weight=\"1\"\n            android:orientation=\"horizontal\">\n\n            <TextView\n                android:layout_width=\"0dp\"\n                android:layout_height=\"match_parent\"\n                android:layout_weight=\"1\"\n                android:textAlignment=\"center\"\n                android:layout_marginTop=\"16dp\"\n                android:fontFamily=\"@font/sf_pro\"\n                android:text=\"\"\n                android:textColor=\"@color/popup_text\"\n                android:textSize=\"20sp\"\n                android:id=\"@+id/left_battery\"\n                android:gravity=\"center\"\n                tools:ignore=\"NestedWeights\" />\n\n            <TextView\n                android:layout_width=\"0dp\"\n                android:layout_height=\"match_parent\"\n                android:layout_weight=\"1\"\n                android:textAlignment=\"center\"\n                android:layout_marginTop=\"16dp\"\n                android:fontFamily=\"@font/sf_pro\"\n                android:gravity=\"center\"\n                android:text=\"\"\n                android:id=\"@+id/right_battery\"\n                android:textColor=\"@color/popup_text\"\n                android:textSize=\"20sp\" />\n        </LinearLayout>\n\n        <!-- Right Half -->\n        <TextView\n            android:layout_width=\"0dp\"\n            android:layout_height=\"match_parent\"\n            android:layout_weight=\"1\"\n            android:textAlignment=\"center\"\n            android:id=\"@+id/case_battery\"\n            android:layout_marginTop=\"16dp\"\n            android:fontFamily=\"@font/sf_pro\"\n            android:gravity=\"center\"\n            android:text=\"\"\n            android:textColor=\"@color/popup_text\"\n            android:textSize=\"20sp\" />\n    </LinearLayout>\n</LinearLayout>\n"
        },
        {
          "name": "island_window.xml",
          "ext": ".xml",
          "size": 3913,
          "preview": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:id=\"@+id/island_window_layout\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:layout_margin=\"16dp\"\n    android:background=\"@drawable/island_background\"\n    android:elevation=\"4dp\"\n    android:gravity=\"center\"\n    android:minHeight=\"115dp\"\n    android:orientation=\"horizontal\"\n    android:outlineAmbientShadowColor=\"#4EFFFFFF\"\n    android:outlineSpotShadowColor=\"#4EFFFFFF\"\n    android:padding=\"8dp\">\n\n    <VideoView\n        android:id=\"@+id/island_video_view\"\n        android:layout_width=\"80dp\"\n        android:layout_height=\"80dp\"\n        android:layout_marginStart=\"8dp\"\n        android:importantForAccessibility=\"no\" />\n\n    <LinearLayout\n        android:layout_width=\"0dp\"\n        android:layout_height=\"wrap_content\"\n        android:layout_margin=\"0dp\"\n        android:layout_weight=\"1\"\n        android:gravity=\"bottom\"\n        android:orientation=\"vertical\"\n        android:padding=\"12dp\">\n\n        <TextView\n            android:id=\"@+id/island_connected_text\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:layout_margin=\"0dp\"\n            android:fontFamily=\"@font/sf_pro\"\n            android:gravity=\"bottom\"\n            android:includeFontPadding=\"false\"\n            android:lineSpacingExtra=\"0dp\"\n            android:lineSpacingMultiplier=\"1\"\n            android:padding=\"0dp\"\n            android:text=\"@string/island_connected_text\"\n            android:textColor=\"#707072\"\n            android:textSize=\"16sp\" />\n\n        <TextView\n            android:id=\"@+id/island_device_name\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:layout_margin=\"0dp\"\n            android:fontFamily=\"@font/sf_pro\"\n            android:gravity=\"bottom\"\n            android:includeFontPadding=\"false\"\n            android:lineSpacingExtra=\"0dp\"\n            android:lineSpacingMultiplier=\"1\"\n            android:padding=\"0dp\"\n            android:text=\"AirPods Pro\"\n            android:textColor=\"@color/white\"\n            android:textSize=\"24sp\"\n            tools:ignore=\"HardcodedText\" />\n    </LinearLayout>\n\n    <FrameLayout\n        android:id=\"@+id/island_battery_container\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:gravity=\"center\">\n\n        <ProgressBar\n            style=\"@style/Widget.AppCompat.ProgressBar.Horizontal\"\n            android:layout_width=\"84dp\"\n            android:layout_height=\"84dp\"\n            android:layout_gravity=\"center\"\n            android:indeterminate=\"false\"\n            android:max=\"100\"\n            android:progress=\"100\"\n            android:progressDrawable=\"@drawable/island_battery_background\" />\n\n        <ProgressBar\n            android:id=\"@+id/island_battery_progress\"\n            style=\"@style/Widget.AppCompat.ProgressBar.Horizontal\"\n            android:layout_width=\"84dp\"\n            android:layout_height=\"84dp\"\n            android:layout_gravity=\"center\"\n            android:indeterminate=\"false\"\n            android:max=\"100\"\n            android:progress=\"50\"\n            android:progressDrawable=\"@drawable/island_battery_progress\" />\n\n        <TextView\n            android:id=\"@+id/island_battery_text\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:layout_gravity=\"center\"\n            android:fontFamily=\"@font/sf_pro\"\n            android:gravity=\"center\"\n            android:text=\"50%\"\n            android:textColor=\"#1ceb72\"\n            android:textSize=\"16sp\"\n            android:textStyle=\"bold\"\n            tools:ignore=\"HardcodedText\" />\n    </FrameLayout>\n</LinearLayout>"
        },
        {
          "name": "battery_widget.xml",
          "ext": ".xml",
          "size": 12482,
          "preview": "<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    style=\"@style/Widget.LibrePods.AppWidget.Container\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:layout_margin=\"0dp\"\n    android:padding=\"0dp\"\n    android:id=\"@+id/battery_widget\"\n    android:theme=\"@style/Theme.LibrePods.AppWidgetContainer\"\n    android:background=\"@drawable/widget_background\">\n\n    <LinearLayout\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:baselineAligned=\"false\"\n        android:orientation=\"horizontal\"\n        android:layout_margin=\"0dp\"\n        android:id=\"@android:id/background\"\n        android:layout_gravity=\"center\">\n\n        <LinearLayout\n            android:layout_width=\"0dp\"\n            android:layout_weight=\"1\"\n            android:layout_height=\"match_parent\"\n            android:gravity=\"center\"\n            android:id=\"@+id/phone_battery_widget_container\"\n            android:orientation=\"vertical\">\n            <FrameLayout\n                android:layout_width=\"90dp\"\n                android:layout_height=\"90dp\"\n                android:layout_margin=\"0dp\"\n                android:padding=\"6dp\"\n                android:layout_gravity=\"center\">\n                <ProgressBar\n                    android:id=\"@+id/phone_battery_progress_background\"\n                    style=\"@style/Widget.AppCompat.ProgressBar.Horizontal\"\n                    android:layout_width=\"match_parent\"\n                    android:layout_height=\"match_parent\"\n                    android:indeterminate=\"false\"\n                    android:max=\"100\"\n                    android:progress=\"100\"\n                    android:progressDrawable=\"@drawable/progress_bar_background\" />\n                <ProgressBar\n                    android:id=\"@+id/phone_battery_progress\"\n                    style=\"@style/Widget.AppCompat.ProgressBar.Horizontal\"\n                    android:layout_width=\"match_parent\"\n                    android:layout_height=\"match_parent\"\n                    android:indeterminate=\"false\"\n                    android:max=\"100\"\n                    android:progress=\"50\"\n                    android:progressDrawable=\"@drawable/circular_progress_bar\" />\n                <ImageView\n                    android:id=\"@+id/phone_charging_icon\"\n                    android:layout_width=\"20dp\"\n                    android:layout_height=\"20dp\"\n                    android:layout_gravity=\"top|center_horizontal\"\n                    android:importantForAccessibility=\"no\"\n                    android:src=\"@drawable/ic_power\"\n                    android:visibility=\"gone\"\n                    android:tint=\"@color/white\"\n                    tools:ignore=\"HardcodedText\" />\n                <ImageView\n                    android:layout_width=\"28dp\"\n                    android:layout_height=\"28dp\"\n                    android:src=\"@drawable/smartphone\"\n                    android:tint=\"@color/white\"\n                    android:layout_gravity=\"center\"\n                    android:importantForAccessibility=\"no\"\n                    tools:ignore=\"HardcodedText\" />\n            </FrameLayout>\n            <TextView\n                android:id=\"@+id/phone_battery_widget\"\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:textSize=\"24sp\"\n                android:textColor=\"@color/white\"\n                android:fontFamily=\"@font/sf_pro\"\n                android:gravity=\"center\"\n                android:textFontWeight=\"300\"\n                android:text=\"Phone\"\n                tools:ignore=\"HardcodedText\" />\n        </LinearLayout>\n\n        <LinearLayout\n            android:layout_width=\"0dp\"\n            android:layout_weight=\"1\"\n            android:layout_height=\"match_parent\"\n            android:gravity=\"center\"\n            android:orientation=\"vertical\">\n            <FrameLayout\n                android:layout_width=\"90dp\"\n                android:layout_height=\"90dp\"\n                android:layout_margin=\"0dp\"\n                android:padding=\"6dp\"\n                android:layout_gravity=\"center\">\n                <ProgressBar\n                    android:id=\"@+id/left_battery_progress_background\"\n                    style=\"@style/Widget.AppCompat.ProgressBar.Horizontal\"\n                    android:layout_width=\"match_parent\"\n                    android:layout_height=\"match_parent\"\n                    android:indeterminate=\"false\"\n                    android:max=\"100\"\n                    android:progress=\"100\"\n                    android:progressDrawable=\"@drawable/progress_bar_background\" />\n                <ProgressBar\n                    android:id=\"@+id/left_battery_progress\"\n                    style=\"@style/Widget.AppCompat.ProgressBar.Horizontal\"\n                    android:layout_width=\"match_parent\"\n                    android:layout_height=\"match_parent\"\n                    android:indeterminate=\"false\"\n                    android:max=\"100\"\n                    android:progress=\"50\"\n                    android:progressDrawable=\"@drawable/circular_progress_bar\" />\n                <ImageView\n                    android:id=\"@+id/left_charging_icon\"\n                    android:layout_width=\"20dp\"\n                    android:layout_height=\"20dp\"\n                    android:layout_gravity=\"top|center_horizontal\"\n                    android:importantForAccessibility=\"no\"\n                    android:src=\"@drawable/ic_power\"\n                    android:visibility=\"gone\"\n                    android:tint=\"@color/white\"\n                    tools:ignore=\"HardcodedText\" />\n                <ImageView\n                    android:layout_width=\"28dp\"\n                    android:layout_height=\"28dp\"\n                    android:src=\"@drawable/airpods_pro_left_notification\"\n                    android:tint=\"@color/white\"\n                    android:layout_gravity=\"center\"\n                    android:importantForAccessibility=\"no\"\n                    tools:ignore=\"HardcodedText\" />\n            </FrameLayout>\n            <TextView\n                android:id=\"@+id/left_battery_widget\"\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:textSize=\"24sp\"\n                android:textColor=\"@color/white\"\n                android:fontFamily=\"@font/sf_pro\"\n                android:gravity=\"center\"\n                android:textFontWeight=\"300\"\n                android:text=\"Left\"\n                tools:ignore=\"HardcodedText\" />\n        </LinearLayout>\n\n        <LinearLayout\n            android:layout_width=\"0dp\"\n            android:layout_weight=\"1\"\n            android:layout_height=\"match_parent\"\n            android:gravity=\"center\"\n            android:orientation=\"vertical\">\n            <FrameLayout\n                android:layout_width=\"90dp\"\n                android:layout_height=\"90dp\"\n                android:layout_margin=\"0dp\"\n                android:padding=\"6dp\"\n                android:layout_gravity=\"center\">\n                <ProgressBar\n                    android:id=\"@+id/right_battery_progress_background\"\n                    style=\"@style/Widget.AppCompat.ProgressBar.Horizontal\"\n                    android:layout_width=\"match_parent\"\n                    android:layout_height=\"match_parent\"\n                    android:indeterminate=\"false\"\n                    android:max=\"100\"\n                    android:progress=\"100\"\n                    android:progressDrawable=\"@drawable/progress_bar_background\" />\n                <ProgressBar\n                    android:id=\"@+id/right_battery_progress\"\n                    style=\"@style/Widget.AppCompat.ProgressBar.Horizontal\"\n                    android:layout_width=\"match_parent\"\n                    android:layout_height=\"match_parent\"\n                    android:indeterminate=\"false\"\n                    android:max=\"100\"\n                    android:progressDrawable=\"@drawable/circular_progress_bar\" />\n                <ImageView\n                    android:id=\"@+id/right_charging_icon\"\n                    android:layout_width=\"20dp\"\n                    android:layout_height=\"20dp\"\n                    android:layout_gravity=\"top|center_horizontal\"\n                    android:importantForAccessibility=\"no\"\n                    android:src=\"@drawable/ic_power\"\n                    android:visibility=\"gone\"\n                    android:tint=\"@color/white\"\n                    tools:ignore=\"HardcodedText\" />\n                <ImageView\n                    android:layout_width=\"28dp\"\n                    android:layout_height=\"28dp\"\n                    android:importantForAccessibility=\"no\"\n                    android:src=\"@drawable/airpods_pro_right_notification\"\n                    android:tint=\"@color/white\"\n                    android:layout_gravity=\"center\"\n                    tools:ignore=\"HardcodedText\" />\n            </FrameLayout>\n            <TextView\n                android:id=\"@+id/right_battery_widget\"\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:textSize=\"24sp\"\n                android:textFontWeight=\"300\"\n                android:textColor=\"@color/white\"\n                android:fontFamily=\"@font/sf_pro\"\n                android:gravity=\"center\"\n                android:text=\"Right\"\n                tools:ignore=\"HardcodedText\" />\n        </LinearLayout>\n\n        <LinearLayout\n            android:layout_width=\"0dp\"\n            android:layout_weight=\"1\"\n            android:layout_height=\"match_parent\"\n            android:gravity=\"center\"\n            android:orientation=\"vertical\">\n            <FrameLayout\n                android:layout_width=\"90dp\"\n                android:layout_height=\"90dp\"\n                android:layout_margin=\"0dp\"\n                android:padding=\"6dp\"\n                android:layout_gravity=\"center\">\n                <ProgressBar\n                    android:id=\"@+id/case_battery_progress_background\"\n                    style=\"@style/Widget.AppCompat.ProgressBar.Horizontal\"\n                    android:layout_width=\"match_parent\"\n                    android:layout_height=\"match_parent\"\n                    android:indeterminate=\"false\"\n                    android:max=\"100\"\n                    android:progress=\"100\"\n                    android:progressDrawable=\"@drawable/progress_bar_background\" />\n                <ProgressBar\n                    android:id=\"@+id/case_battery_progress\"\n                    style=\"@style/Widget.AppCompat.ProgressBar.Horizontal\"\n                    android:layout_width=\"match_parent\"\n                    android:layout_height=\"match_parent\"\n                    android:indeterminate=\"false\"\n                    android:max=\"100\"\n                    android:progressDrawable=\"@drawable/circular_progress_bar\" />\n                <ImageView\n                    android:id=\"@+id/case_charging_icon\"\n                    android:layout_width=\"20dp\"\n                    android:layout_height=\"20dp\"\n                    android:importantForAccessibility=\"no\"\n                    android:layout_gravity=\"top|center_horizontal\"\n                    android:src=\"@drawable/ic_power\"\n                    android:visibility=\"gone\"\n                    android:tint=\"@color/white\"\n                    tools:ignore=\"HardcodedText\" />\n                <ImageView\n                    android:layout_width=\"28dp\"\n                    android:layout_height=\"28dp\"\n                    android:importantForAccessibility=\"no\"\n                    android:src=\"@drawable/airpods_pro_case_notification\"\n                    android:tint=\"@color/white\"\n                    android:layout_gravity=\"center\"\n                    tools:ignore=\"HardcodedText\" />\n            </FrameLayout>\n            <TextView\n                android:id=\"@+id/case_battery_widget\"\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:textSize=\"24sp\"\n                android:textColor=\"@color/white\"\n                android:gravity=\"center\"\n                android:fontFamily=\"@font/sf_pro\"\n                android:textFontWeight=\"300\"\n                android:text=\"Case\"\n                tools:ignore=\"HardcodedText\" />\n        </LinearLayout>\n    </LinearLayout>\n</RelativeLayout>"
        },
        {
          "name": "activity_main.xml",
          "ext": ".xml",
          "size": 814,
          "preview": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\".MainActivity\">\n\n    <TextView\n        android:id=\"@+id/hello\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"@string/app_hello\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"/>\n</androidx.constraintlayout.widget.ConstraintLayout>\n"
        },
        {
          "name": "noise_control_widget.xml",
          "ext": ".xml",
          "size": 5446,
          "preview": "<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    style=\"@style/Widget.LibrePods.AppWidget.Container\"\n    android:id=\"@+id/noise_control_widget\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:theme=\"@style/Theme.LibrePods.AppWidgetContainer\">\n\n    <LinearLayout\n        android:id=\"@android:id/background\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"horizontal\">\n\n        <LinearLayout\n            android:id=\"@+id/widget_off_button\"\n            android:layout_width=\"0dp\"\n            android:layout_height=\"match_parent\"\n            android:layout_marginVertical=\"12dp\"\n            android:layout_marginStart=\"12dp\"\n            android:layout_marginEnd=\"2dp\"\n            android:layout_weight=\"1\"\n            android:background=\"@drawable/widget_button_shape_start\"\n            android:clickable=\"true\"\n            android:gravity=\"center\"\n            android:orientation=\"vertical\">\n\n            <ImageView\n                android:layout_width=\"52dp\"\n                android:layout_height=\"52dp\"\n                android:src=\"@drawable/noise_cancellation\"\n                android:tint=\"@color/white\" />\n\n            <TextView\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"0dp\"\n                android:layout_weight=\"1\"\n                android:gravity=\"center\"\n                android:shadowColor=\"@color/black\"\n                android:shadowRadius=\"12\"\n                android:text=\"@string/off\"\n                android:textColor=\"@color/white\"\n                android:textSize=\"12sp\" />\n        </LinearLayout>\n\n        <LinearLayout\n            android:id=\"@+id/widget_transparency_button\"\n            android:layout_width=\"0dp\"\n            android:layout_height=\"match_parent\"\n            android:layout_marginVertical=\"12dp\"\n            android:layout_marginEnd=\"2dp\"\n            android:layout_weight=\"1\"\n            android:background=\"@drawable/widget_button_shape_middle\"\n            android:clickable=\"true\"\n            android:gravity=\"center\"\n            android:orientation=\"vertical\">\n\n            <ImageView\n                android:layout_width=\"52dp\"\n                android:layout_height=\"52dp\"\n                android:src=\"@drawable/transparency\"\n                android:tint=\"@color/white\" />\n\n            <TextView\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"0dp\"\n                android:layout_weight=\"1\"\n                android:gravity=\"center\"\n                android:shadowColor=\"@color/black\"\n                android:shadowRadius=\"12\"\n                android:text=\"@string/transparency\"\n                android:textColor=\"@color/white\"\n                android:textSize=\"12sp\" />\n        </LinearLayout>\n\n        <LinearLayout\n            android:id=\"@+id/widget_adaptive_button\"\n            android:layout_width=\"0dp\"\n            android:layout_height=\"match_parent\"\n            android:layout_marginVertical=\"12dp\"\n            android:layout_marginStart=\"2dp\"\n            android:layout_marginEnd=\"2dp\"\n            android:layout_weight=\"1\"\n            android:background=\"@drawable/widget_button_shape_middle\"\n            android:clickable=\"true\"\n            android:gravity=\"center\"\n            android:orientation=\"vertical\">\n\n            <ImageView\n                android:layout_width=\"52dp\"\n                android:layout_height=\"52dp\"\n                android:src=\"@drawable/adaptive\"\n                android:textSize=\"12sp\"\n                android:tint=\"@color/white\" />\n\n            <TextView\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"0dp\"\n                android:layout_weight=\"1\"\n                android:gravity=\"center\"\n                android:shadowColor=\"@color/black\"\n                android:shadowRadius=\"12\"\n                android:text=\"@string/adaptive\"\n                android:textColor=\"@color/white\"\n                android:textSize=\"12sp\" />\n        </LinearLayout>\n\n        <LinearLayout\n            android:id=\"@+id/widget_anc_button\"\n            android:layout_width=\"0dp\"\n            android:layout_height=\"match_parent\"\n            android:layout_marginVertical=\"12dp\"\n            android:layout_marginStart=\"2dp\"\n            android:layout_marginEnd=\"12dp\"\n            android:layout_weight=\"1\"\n            android:background=\"@drawable/widget_button_shape_end\"\n            android:clickable=\"true\"\n            android:gravity=\"center\"\n            android:orientation=\"vertical\">\n\n            <ImageView\n                android:layout_width=\"52dp\"\n                android:layout_height=\"52dp\"\n                android:src=\"@drawable/noise_cancellation\"\n                android:tint=\"@color/white\" />\n\n            <TextView\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"0dp\"\n                android:layout_weight=\"1\"\n                android:gravity=\"center\"\n                android:shadowColor=\"@color/black\"\n                android:shadowRadius=\"12\"\n                android:text=\"@string/noise_cancellation\"\n                android:textColor=\"@color/white\"\n                android:textSize=\"12sp\"\n                tools:ignore=\"NestedWeights\" />\n        </LinearLayout>\n    </LinearLayout>\n</RelativeLayout>\n"
        }
      ]
    },
    {
      "dir": "android/app/src/main/res/raw",
      "files": [
        {
          "name": "island.mp4",
          "ext": ".mp4",
          "size": 409816
        },
        {
          "name": "blip_yes.wav",
          "ext": ".wav",
          "size": 33444
        },
        {
          "name": "blip_no.wav",
          "ext": ".wav",
          "size": 29232
        },
        {
          "name": "confirm_no.wav",
          "ext": ".wav",
          "size": 367180
        },
        {
          "name": "connected.mp4",
          "ext": ".mp4",
          "size": 180522
        },
        {
          "name": "confirm_yes.wav",
          "ext": ".wav",
          "size": 401026
        }
      ]
    },
    {
      "dir": "android/app/src/main/res/mipmap-xxhdpi",
      "files": [
        {
          "name": "ic_launcher.png",
          "ext": ".png",
          "size": 8
        },
        {
          "name": "ic_launcher_round.png",
          "ext": ".png",
          "size": 8
        }
      ]
    },
    {
      "dir": "android/app/src/main/res/values-night",
      "files": [
        {
          "name": "colors.xml",
          "ext": ".xml",
          "size": 318,
          "preview": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n    <color name=\"popup_background\">#1C1B1E</color>\n    <color name=\"popup_text\">@color/white</color>\n    <color name=\"widget_background\">#1C1B1E</color>\n    <color name=\"widget_text\">@color/white</color>\n    <color name=\"colorBackground\">#0B0B0B</color>\n</resources>\n"
        }
      ]
    },
    {
      "dir": "android/app/src/main/res/raw-night",
      "files": [
        {
          "name": "connected.mp4",
          "ext": ".mp4",
          "size": 207140
        }
      ]
    },
    {
      "dir": "android/app/src/main/res/mipmap-hdpi",
      "files": [
        {
          "name": "ic_launcher.png",
          "ext": ".png",
          "size": 8
        },
        {
          "name": "ic_launcher_round.png",
          "ext": ".png",
          "size": 8
        }
      ]
    },
    {
      "dir": "android/app/src/main/res/drawable-v24",
      "files": [
        {
          "name": "ic_launcher_foreground.xml",
          "ext": ".xml",
          "size": 9239,
          "preview": "<vector xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:aapt=\"http://schemas.android.com/aapt\"\n    android:width=\"108dp\"\n    android:height=\"108dp\"\n    android:viewportWidth=\"108\"\n    android:viewportHeight=\"108\">\n    <group\n        android:translateX=\"13.5\"\n        android:translateY=\"13.5\"\n        android:scaleX=\"0.75\"\n        android:scaleY=\"0.75\">\n        <path\n            android:pathData=\"M30.07 66.68l-1.73-1.32c-1.35-1.18-2.58-2.49-3.68-3.9l-0.12-0.17-1.28-1.92-0.72-1.24-1.02-2.3c-0.52-1.4-0.9-2.86-1.1-4.34l-0.06-0.45-0.08-1.13-0.07-1.28 0.03-0.79c0-0.37 0.04-0.75 0.1-1.12l0.02-0.14 0.14-0.52c0.2-0.72 0.8-1.27 1.54-1.4l0.3-0.01c0.2-0.01 0.4 0 0.6 0.07 0.22 0.06 0.43 0.18 0.62 0.33l0.62 0.52L26.1 47c1.61 1.26 3.3 2.4 5.09 3.37 0.6 0.33 1.23 0.66 1.77 0.93 0.87 0.43 1.77 0.82 2.68 1.18l0.9 0.36 0.45 0.14c0.7 0.2 1.42 0.36 2.15 0.46l0.56 0.04h0.14c0.12 0 0.18-0.14 0.1-0.23l-0.04-0.02L39.5 53l-0.76-0.41-1.24-0.64-3.39-1.47-2.78-1.62-1.44-0.87-1.69-1.35-1.96-1.58-1.92-1.89-1.36-1.73-0.1-0.13c-0.88-1.16-1.64-2.42-2.27-3.75l-0.71-2.22-0.57-1.89c-0.12-0.57-0.2-1.16-0.22-1.75l-0.05-1.14L19 25.88l0.01-0.11c0.07-0.78 0.2-1.54 0.4-2.3l0.3-1.01 0.38-1.1 0.4-0.87c0.06-0.15 0.14-0.28 0.23-0.4l0.05-0.07c0.1-0.13 0.22-0.25 0.35-0.34 0.22-0.16 0.47-0.25 0.73-0.29h0.04c0.1-0.01 0.22-0.02 0.33-0.01l0.21 0.01c0.12 0.01 0.25 0.03 0.36 0.06h0.03c0.26 0.07 0.5 0.2 0.72 0.36 0.14 0.1 0.26 0.23 0.36 0.37l0.41 0.54 1.54 1.77 1.81 2.08c0.88 0.9 1.82 1.73 2.83 2.5l0.8 0.6 2.16 1.23c0.15 0.09 0.3 0.15 0.47 0.2l1.66 0.53c0.34 0.11 0.53 0.47 0.44 0.81l-0.05 0.12-0.11 0.23c-0.24 0.47-0.36 0.98-0.36 1.5v2.3c0 1.27 0.18 2.52 0.54 3.73l0.5 1.68c0.63 1.66 1.48 3.23 2.54 4.66l0.48 0.66c0.96 1.3 2.04 2.51 3.22 3.62l3.22 3 1.69 1.27c0.2 0.15 0.44 0.27 0.69 0.34l0.17 0.04c0.3 0.09 0.55 0.25 0.75 0.49 0.22 0.27 0.34 0.6 0.34 0.95v33c0 0.18 0.13 0.33 0.31 0.36h0.07-0.07l-5.87-0.51-2.37-0.45C40 87.1 38.32 86.63 36.7 86l-2.44-1.3-1.01-0.73c-0.87-0.62-1.67-1.31-2.41-2.07-0.71-0.72-1.36-1.5-1.93-2.32l-0.66-0.94-0.98-1.39c-0.48-0.67-0.84-1.4-1.1-2.18-0.17-0.56-0.28-1.14-0.33-1.72l-0.01-0.08c-0.04-0.46-0.04-0.92 0-1.38l0.06-0.97V70.9c0-0.71 0.08-1.41 0.23-2.1l0.23-0.68c0.09-0.24 0.23-0.45 0.41-0.62 0.17-0.16 0.38-0.28 0.6-0.34l0.18-0.05c0.37-0.11 0.76-0.1 1.12 0.03 0.14 0.05 0.28 0.11 0.4 0.2l1.04 0.69 2.21 1.62 2.67 1.86 1.94 1.17 1.77 0.95c0.5 0.27 1.04 0.5 1.58 0.7l1.97 0.73 0.12 0.02h0.1c0.11 0 0.21-0.1 0.23-0.21 0-0.1-0.04-0.19-0.12-0.23l-0.94-0.57-1.68-1.05-3.72-2.05-2.88-2.13-3.28-2.16Z\">\n            <aapt:attr name=\"android:fillColor\">\n                <gradient\n                    android:type=\"linear\"\n                    android:startX=\"34.51\"\n                    android:startY=\"19.37\"\n                    android:endX=\"34.51\"\n                    android:endY=\"88.4\">\n                    <item\n                        android:color=\"#FF64AB5D\"\n                        android:offset=\"0\"/>\n                    <item\n                        android:color=\"#FF21395B\"\n                        android:offset=\"1\"/>\n                </gradient>\n            </aapt:attr>\n        </path>\n        <path\n            android:strokeColor=\"@color/popup_text\"\n            android:strokeWidth=\"0.5\"\n            android:pathData=\"M30.07 66.68l-1.73-1.32c-1.35-1.18-2.58-2.49-3.68-3.9l-0.12-0.17-1.28-1.92-0.72-1.24-1.02-2.3c-0.52-1.4-0.9-2.86-1.1-4.34l-0.06-0.45-0.08-1.13-0.07-1.28 0.03-0.79c0-0.37 0.04-0.75 0.1-1.12l0.02-0.14 0.14-0.52c0.2-0.72 0.8-1.27 1.54-1.4l0.3-0.01c0.2-0.01 0.4 0 0.6 0.07 0.22 0.06 0.43 0.18 0.62 0.33l0.62 0.52L26.1 47c1.61 1.26 3.3 2.4 5.09 3.37 0.6 0.33 1.23 0.66 1.77 0.93 0.87 0.43 1.77 0.82 2.68 1.18l0.9 0.36 0.45 0.14c0.7 0.2 1.42 0.36 2.15 0.46l0.56 0.04h0.14c0.12 0 0.18-0.14 0.1-0.23l-0.04-0.02L39.5 53l-0.76-0.41-1.24-0.64-3.39-1.47-2.78-1.62-1.44-0.87-1.69-1.35-1.96-1.58-1.92-1.89-1.36-1.73-0.1-0.13c-0.88-1.16-1.64-2.42-2.27-3.75l-0.71-2.22-0.57-1.89c-0.12-0.57-0.2-1.16-0.22-1.75l-0.05-1.14L19 25.88l0.01-0.11c0.07-0.78 0.2-1.54 0.4-2.3l0.3-1.01 0.38-1.1 0.4-0.87c0.06-0.15 0.14-0.28 0.23-0.4l0.05-0.07c0.1-0.13 0.22-0.25 0.35-0.34 0.22-0.16 0.47-0.25 0.73-0.29h0.04c0.1-0.01 0.22-0.02 0.33-0.01l0.21 0.01c0.12 0.01 0.25 0.03 0.36 0.06h0.03c0.26 0.07 0.5 0.2 0.72 0.36 0.14 0.1 0.26 0.23 0.36 0.37l0.41 0.54 1.54 1.77 1.81 2.08c0.88 0.9 1.82 1.73 2.83 2.5l0.8 0.6 2.16 1.23c0.15 0.09 0.3 0.15 0.47 0.2l1.66 0.53c0.34 0.11 0.53 0.47 0.44 0.81l-0.05 0.12-0.11 0.23c-0.24 0.47-0.36 0.98-0.36 1.5v2.3c0 1.27 0.18 2.52 0.54 3.73l0.5 1.68c0.63 1.66 1.48 3.23 2.54 4.66l0.48 0.66c0.96 1.3 2.04 2.51 3.22 3.62l3.22 3 1.69 1.27c0.2 0.15 0.44 0.27 0.69 0.34l0.17 0.04c0.3 0.09 0.55 0.25 0.75 0.49 0.22 0.27 0.34 0.6 0.34 0.95v33c0 0.18 0.13 0.33 0.31 0.36h0.07-0.07l-5.87-0.51-2.37-0.45C40 87.1 38.32 86.63 36.7 86l-2.44-1.3-1.01-0.73c-0.87-0.62-1.67-1.31-2.41-2.07-0.71-0.72-1.36-1.5-1.93-2.32l-0.66-0.94-0.98-1.39c-0.48-0.67-0.84-1.4-1.1-2.18-0.17-0.56-0.28-1.14-0.33-1.72l-0.01-0.08c-0.04-0.46-0.04-0.92 0-1.38l0.06-0.97V70.9c0-0.71 0.08-1.41 0.23-2.1l0.23-0.68c0.09-0.24 0.23-0.45 0.41-0.62 0.17-0.16 0.38-0.28 0.6-0.34l0.18-0.05c0.37-0.11 0.76-0.1 1.12 0.03 0.14 0.05 0.28 0.11 0.4 0.2l1.04 0.69 2.21 1.62 2.67 1.86 1.94 1.17 1.77 0.95c0.5 0.27 1.04 0.5 1.58 0.7l1.97 0.73 0.12 0.02h0.1c0.11 0 0.21-0.1 0.23-0.21 0-0.1-0.04-0.19-0.12-0.23l-0.94-0.57-1.68-1.05-3.72-2.05-2.88-2.13-3.28-2.16Z\"/>\n        <path\n            android:strokeColor=\"@color/popup_text\"\n            android:strokeWidth=\"2\"\n            android:pathData=\"M49.59 54.33v33.15 0.04c0 0.62 0.14 1.23 0.42 1.78m-0.42-34.97l-2.1-1.4-0.29-0.2c-1.67-1.17-3.26-2.46-4.75-3.86l-0.35-0.35c-1.54-1.53-2.88-3.24-4-5.1l-0.86-1.57c-0.45-0.82-0.82-1.68-1.1-2.57-0.46-1.43-0.7-2.92-0.7-4.42v-0.54-0.74c0-1.27 0.16-2.53 0.47-3.77 0.25-1 0.6-1.97 1.04-2.9l0.74-1.54 0.4-0.67c0.85-1.41 1.84-2.73 2.96-3.94l0.84-0.78c0.56-0.5 1.17-0.95 1.82-1.32l0.98-0.56 1.1-0.56 1.28-0.56 1-0.36c0.63-0.23 1.3-0.4 1.97-0.5 0.54-0.08 1.08-0.12 1.63-0.12h1.7 0.61c0.62 0 1.23 0.04 1.85 0.13 0.69 0.1 1.37 0.25 2.04 0.46l1.24 0.39 2.24 0.56 2.1 0.84 1.54 0.84 1.96 1.12 1.82 1.26 1.68 1.25 0.23 0.2c0.87 0.7 1.68 1.48 2.43 2.32l1.12 1.12 1.26 1.54 1.12 1.54 0.84 1.4 0.59 1.3M49.59 54.34l0.06 0.04c0.33 0.25 0.68 0.47 1.06 0.66l1.54 0.7 1.68 0.7 1.68 0.56 1.54 0.42 1.54 0.42 1.54 0.28 0.84 0.14 1.12 0.04 0.56-0.04h0.56m14.73-25.97l-1.01-0.05h-1.54-0.06c-0.8 0-1.58 0.14-2.32 0.42l-1.12 0.42-0.55 0.3c-0.66 0.35-1.28 0.78-1.86 1.26-0.54 0.45-1.04 0.94-1.49 1.48l-0.72 0.87-0.16 0.19c-0.83 1-1.57 2.05-2.22 3.17l-0.84 1.4-0.84 1.4-0.84 1.82-0.7 1.95-0.42 1.96-0.28 2.1v0.11c0 0.95 0.1 1.9 0.28 2.83l0.42 1.4c0.28 0.92 0.7 1.8 1.28 2.58l0.26 0.36m14.73-25.97l1.65 0.37c0.84 0.18 1.65 0.46 2.43 0.82l0.14 0.07c0.52 0.24 1.03 0.53 1.52 0.85l0.11 0.08c0.56 0.37 1.08 0.8 1.55 1.26 0.37 0.37 0.7 0.76 1 1.18l1.09 1.47c0.65 0.93 1.17 1.94 1.55 3l0.13 0.36 0.02 0.06c0.36 1.17 0.62 2.37 0.77 3.58v0.8c0 0.78-0.06 1.55-0.18 2.32-0.22 1.45-0.65 2.87-1.27 4.2l-0.13 0.27-0.89 1.64-1.54 2.1-0.42 0.5c-0.56 0.69-1.17 1.33-1.84 1.92l-0.06 0.05c-0.88 0.77-1.84 1.44-2.86 2l-0.25 0.11c-1.14 0.5-2.32 0.88-3.53 1.15l-0.17 0.04c-0.72 0.16-1.47 0.24-2.21 0.24h-0.79c-1.15 0-2.3-0.14-3.41-0.42l-1.82-0.7-1.68-0.7-0.62-0.33c-0.61-0.34-1.17-0.76-1.67-1.25-0.34-0.34-0.71-0.65-1.12-0.92l-0.23-0.15m0 0v1.81 0.84 1.4l-0.42 24.9v0.43c0 0.55-0.1 1.1-0.28 1.61M50 89.3l0.3 0.52c0.17 0.3 0.38 0.58 0.63 0.83 0.4 0.4 0.88 0.71 1.4 0.9l0.33 0.13 0.1 0.04c0.29 0.11 0.58 0.2 0.88 0.26 0.37 0.08 0.75 0.12 1.13 0.12h0.55 0.84H57h0.7c0.37 0 0.75-0.05 1.11-0.14l0.3-0.07c0.56-0.14 1.1-0.35 1.62-0.6l0.05-0.03 0.42-0.28 0.28-0.18c0.18-0.12 0.35-0.26 0.5-0.42 0.22-0.25 0.4-0.54 0.51-0.86l0.1-0.28M50 89.3l12.6-0.06M48.9 31.81l-0.86-0.65c-0.17-0.13-0.32-0.28-0.45-0.47-0.06-0.1-0.12-0.2-0.16-0.3l-0.14-0.32c-0.14-0.33-0.21-0.69-0.21-1.05 0-0.28 0.04-0.57 0.13-0.84L47.26 28l0.2-0.5 0.16-0.3c0.1-0.2 0.23-0.38 0.39-0.54 0.12-0.12 0.25-0.22 0.4-0.31l0.29-0.17c0.12-0.08 0.26-0.15 0.4-0.2l0.11-0.05c0.25-0.1 0.51-0.15 0.78-0.15 0.2 0 0.4 0.03 0.58 0.08l0.26 0.08c0.3 0.08 0.57 0.2 0.83 0.34l1.15 0.62 1.4 0.84 1.12 0.84 1.4 0.98 1.17 0.89 0.3 0.28c0.14 0.15 0.25 0.32 0.34 0.5l0.02 0.03c0.18 0.35 0.27 0.74 0.27 1.13v0.25 0.19c0 0.42-0.1 0.84-0.3 1.22-0.08 0.18-0.18 0.34-0.3 0.5l-0.1 0.12c-0.19 0.23-0.42 0.41-0.68 0.54-0.1 0.06-0.22 0.1-0.34 0.14l-0.21 0.06c-0.4 0.1-0.8 0.16-1.2 0.16h-0.37c-0.28 0-0.55-0.05-0.81-0.15l-0.12-0.05c-0.13-0.05-0.25-0.11-0.37-0.18l-1.5-0.88-1.82-1.25-1.82-1.26Zm36.96 17.06l0.06-0.42c0.05-0.37 0.05-0.74-0.01-1.11l-0.01-0.07c-0.03-0.14-0.06-0.29-0.11-0.43l-0.1-0.28c-0.07-0.23-0.2-0.43-0.37-0.6l-0.07-0.07c-0.15-0.15-0.34-0.26-0.55-0.31-0.16-0.04-0.32-0.05-0.48-0.02l-0.25 0.04c-0.23 0.04-0.46 0.1-0.67 0.22l-0.14 0.07c-0.25 0.12-0.49 0.28-0.7 0.46l-0.26 0.22c-0.27 0.23-0.51 0.48-0.74 0.75l-0.36 0.43-0.56 0.84-0.84 1.26-0.14 0.21c-0.28 0.42-0.51 0.87-0.7 1.33l-0.56 1.54-0.1 0.36c-0.12 0.4-0.18 0.84-0.18 1.27v0.39c0 0.24 0.04 0.47 0.11 0.7l0.08 0.22c0.06 0.18 0.16 0.35 0.3 0.49l0.05 0.05c0.1 0.1 0.23 0.18 0.37 0.23 0.14 0.04 0.28 0.06 0.43 0.04l0.36-0.06c0.26-0.03 0.52-0.11 0.76-0.23l0.44-0.22c0.4-0.2 0.77-0.45 1.11-0.74l0.47-0.4 0.03-0.04c0.73-0.81 1.37-1.69 1.93-2.62 0.37-0.65 0.69-1.33 0.95-2.04l0.17-0.48 0.28-0.98Z\"/>\n    </group>\n</vector>\n"
        },
        {
          "name": "ic_launcher_monochrome.xml",
          "ext": ".xml",
          "size": 6176,
          "preview": "<vector xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:width=\"108dp\"\n    android:height=\"108dp\"\n    android:viewportWidth=\"108\"\n    android:viewportHeight=\"108\">\n    <group\n        android:translateX=\"21.6\"\n        android:translateY=\"21.6\"\n        android:scaleX=\"0.6\"\n        android:scaleY=\"0.6\">\n        <group>\n            <path\n                android:strokeColor=\"@color/popup_text\"\n                android:strokeWidth=\"3.25\"\n                android:pathData=\"M49.64 54.5v33.52c0 0.21 0.17 0.38 0.38 0.38l-5.94-0.52-2.37-0.45C40 87.1 38.32 86.63 36.7 86l-2.44-1.3-1.01-0.73c-0.87-0.62-1.67-1.31-2.41-2.07-0.71-0.72-1.36-1.5-1.93-2.32l-0.66-0.94-0.98-1.39c-0.48-0.67-0.84-1.4-1.1-2.18-0.17-0.56-0.28-1.14-0.33-1.72l-0.01-0.08c-0.04-0.46-0.04-0.92 0-1.38l0.06-0.97V70.9c0-0.71 0.08-1.41 0.23-2.1l0.23-0.68c0.09-0.24 0.23-0.45 0.41-0.62 0.17-0.16 0.38-0.28 0.6-0.34l0.18-0.05c0.37-0.11 0.76-0.1 1.12 0.03 0.14 0.05 0.28 0.11 0.4 0.2l1.04 0.69 2.21 1.62 2.67 1.86 1.94 1.17 1.77 0.95c0.5 0.27 1.04 0.5 1.58 0.7l1.97 0.73 0.12 0.02h0.1c0.11 0 0.21-0.1 0.23-0.21 0-0.1-0.04-0.19-0.12-0.23l-0.94-0.57-1.68-1.05-3.72-2.05-2.88-2.13-3.28-2.16-1.73-1.32c-1.35-1.18-2.58-2.49-3.68-3.9l-0.12-0.17-1.28-1.92-0.72-1.24-1.02-2.3c-0.52-1.4-0.9-2.86-1.1-4.34l-0.06-0.45-0.08-1.13-0.07-1.28 0.03-0.79c0-0.37 0.04-0.75 0.1-1.12l0.02-0.14 0.14-0.52c0.2-0.72 0.8-1.27 1.54-1.4l0.3-0.01c0.2-0.01 0.4 0 0.6 0.07 0.22 0.06 0.43 0.18 0.62 0.33l0.62 0.52L26.1 47c1.61 1.26 3.3 2.4 5.09 3.37 0.6 0.33 1.23 0.66 1.77 0.93 0.87 0.43 1.77 0.82 2.68 1.18l0.9 0.36 0.45 0.14c0.7 0.2 1.42 0.36 2.15 0.46l0.56 0.04h0.14c0.12 0 0.18-0.14 0.1-0.23l-0.04-0.02L39.5 53l-0.76-0.41-1.24-0.64-3.39-1.47-2.78-1.62-1.44-0.87-1.69-1.35-1.96-1.58-1.92-1.89-1.36-1.73-0.1-0.13c-0.88-1.16-1.64-2.42-2.27-3.75l-0.71-2.22-0.57-1.89c-0.12-0.57-0.2-1.16-0.22-1.75l-0.05-1.14L19 25.88l0.01-0.11c0.07-0.78 0.2-1.54 0.4-2.3l0.3-1.01 0.38-1.1 0.4-0.87c0.06-0.15 0.14-0.28 0.23-0.4l0.05-0.07c0.1-0.13 0.22-0.25 0.35-0.34 0.22-0.16 0.47-0.25 0.73-0.29h0.04c0.1-0.01 0.22-0.02 0.33-0.01l0.21 0.01c0.12 0.01 0.25 0.03 0.36 0.06h0.03c0.26 0.07 0.5 0.2 0.72 0.36 0.14 0.1 0.26 0.23 0.36 0.37l0.41 0.54 1.54 1.77 1.81 2.08c0.88 0.9 1.82 1.73 2.83 2.5l0.8 0.6 0.09 0.05c1.53 0.87 3.14 1.58 4.8 2.1\"/>\n        </group>\n        <path\n            android:strokeColor=\"@color/popup_text\"\n            android:strokeWidth=\"3.75\"\n            android:pathData=\"M49.59 54.33v33.15 0.04c0 0.62 0.14 1.23 0.42 1.78m-0.42-34.97l-2.1-1.4-0.29-0.2c-1.67-1.17-3.26-2.46-4.75-3.86l-0.35-0.35c-1.54-1.53-2.88-3.24-4-5.1l-0.86-1.57c-0.45-0.82-0.82-1.68-1.1-2.57-0.46-1.43-0.7-2.92-0.7-4.42v-0.54-0.74c0-1.27 0.16-2.53 0.47-3.77 0.25-1 0.6-1.97 1.04-2.9l0.74-1.54 0.4-0.67c0.85-1.41 1.84-2.73 2.96-3.94l0.84-0.78c0.56-0.5 1.17-0.95 1.82-1.32l0.98-0.56 1.1-0.56 1.28-0.56 1-0.36c0.63-0.23 1.3-0.4 1.97-0.5 0.54-0.08 1.08-0.12 1.63-0.12h1.7 0.61c0.62 0 1.23 0.04 1.85 0.13 0.69 0.1 1.37 0.25 2.04 0.46l1.24 0.39 2.24 0.56 2.1 0.84 1.54 0.84 1.96 1.12 1.82 1.26 1.68 1.25 0.23 0.2c0.87 0.7 1.68 1.48 2.43 2.32l1.12 1.12 1.26 1.54 1.12 1.54 0.84 1.4 0.59 1.3M49.59 54.34l0.06 0.04c0.33 0.25 0.68 0.47 1.06 0.66l1.54 0.7 1.68 0.7 1.68 0.56 1.54 0.42 1.54 0.42 1.54 0.28 0.84 0.14 1.12 0.04 0.56-0.04h0.56m14.73-25.97l-1.01-0.05h-1.54-0.06c-0.8 0-1.58 0.14-2.32 0.42l-1.12 0.42-0.55 0.3c-0.66 0.35-1.28 0.78-1.86 1.26-0.54 0.45-1.04 0.94-1.49 1.48l-0.72 0.87-0.16 0.19c-0.83 1-1.57 2.05-2.22 3.17l-0.84 1.4-0.84 1.4-0.84 1.82-0.7 1.95-0.42 1.96-0.28 2.1v0.11c0 0.95 0.1 1.9 0.28 2.83l0.42 1.4c0.28 0.92 0.7 1.8 1.28 2.58l0.26 0.36m14.73-25.97l1.65 0.37c0.84 0.18 1.65 0.46 2.43 0.82l0.14 0.07c0.52 0.24 1.03 0.53 1.52 0.85l0.11 0.08c0.56 0.37 1.08 0.8 1.55 1.26 0.37 0.37 0.7 0.76 1 1.18l1.09 1.47c0.65 0.93 1.17 1.94 1.55 3l0.13 0.36 0.02 0.06c0.36 1.17 0.62 2.37 0.77 3.58v0.8c0 0.78-0.06 1.55-0.18 2.32-0.22 1.45-0.65 2.87-1.27 4.2l-0.13 0.27-0.89 1.64-1.54 2.1-0.42 0.5c-0.56 0.69-1.17 1.33-1.84 1.92l-0.06 0.05c-0.88 0.77-1.84 1.44-2.86 2l-0.25 0.11c-1.14 0.5-2.32 0.88-3.53 1.15l-0.17 0.04c-0.72 0.16-1.47 0.24-2.21 0.24h-0.79c-1.15 0-2.3-0.14-3.41-0.42l-1.82-0.7-1.68-0.7-0.62-0.33c-0.61-0.34-1.17-0.76-1.67-1.25-0.34-0.34-0.71-0.65-1.12-0.92l-0.23-0.15m0 0v1.81 0.84 1.4l-0.42 24.9v0.43c0 0.55-0.1 1.1-0.28 1.61M50 89.3l0.3 0.52c0.17 0.3 0.38 0.58 0.63 0.83 0.4 0.4 0.88 0.71 1.4 0.9l0.33 0.13 0.1 0.04c0.29 0.11 0.58 0.2 0.88 0.26 0.37 0.08 0.75 0.12 1.13 0.12h0.55 0.84H57h0.7c0.37 0 0.75-0.05 1.11-0.14l0.3-0.07c0.56-0.14 1.1-0.35 1.62-0.6l0.05-0.03 0.42-0.28 0.28-0.18c0.18-0.12 0.35-0.26 0.5-0.42 0.22-0.25 0.4-0.54 0.51-0.86l0.1-0.28M50 89.3l12.6-0.06M48.9 31.81l-0.86-0.65c-0.17-0.13-0.32-0.28-0.45-0.47-0.06-0.1-0.12-0.2-0.16-0.3l-0.14-0.32c-0.14-0.33-0.21-0.69-0.21-1.05 0-0.28 0.04-0.57 0.13-0.84L47.26 28l0.2-0.5 0.16-0.3c0.1-0.2 0.23-0.38 0.39-0.54 0.12-0.12 0.25-0.22 0.4-0.31l0.29-0.17c0.12-0.08 0.26-0.15 0.4-0.2l0.11-0.05c0.25-0.1 0.51-0.15 0.78-0.15 0.2 0 0.4 0.03 0.58 0.08l0.26 0.08c0.3 0.08 0.57 0.2 0.83 0.34l1.15 0.62 1.4 0.84 1.12 0.84 1.4 0.98 1.17 0.89 0.3 0.28c0.14 0.15 0.25 0.32 0.34 0.5l0.02 0.03c0.18 0.35 0.27 0.74 0.27 1.13v0.25 0.19c0 0.42-0.1 0.84-0.3 1.22-0.08 0.18-0.18 0.34-0.3 0.5l-0.1 0.12c-0.19 0.23-0.42 0.41-0.68 0.54-0.1 0.06-0.22 0.1-0.34 0.14l-0.21 0.06c-0.4 0.1-0.8 0.16-1.2 0.16h-0.37c-0.28 0-0.55-0.05-0.81-0.15l-0.12-0.05c-0.13-0.05-0.25-0.11-0.37-0.18l-1.5-0.88-1.82-1.25-1.82-1.26Zm36.96 17.06l0.06-0.42c0.05-0.37 0.05-0.74-0.01-1.11l-0.01-0.07c-0.03-0.14-0.06-0.29-0.11-0.43l-0.1-0.28c-0.07-0.23-0.2-0.43-0.37-0.6l-0.07-0.07c-0.15-0.15-0.34-0.26-0.55-0.31-0.16-0.04-0.32-0.05-0.48-0.02l-0.25 0.04c-0.23 0.04-0.46 0.1-0.67 0.22l-0.14 0.07c-0.25 0.12-0.49 0.28-0.7 0.46l-0.26 0.22c-0.27 0.23-0.51 0.48-0.74 0.75l-0.36 0.43-0.56 0.84-0.84 1.26-0.14 0.21c-0.28 0.42-0.51 0.87-0.7 1.33l-0.56 1.54-0.1 0.36c-0.12 0.4-0.18 0.84-0.18 1.27v0.39c0 0.24 0.04 0.47 0.11 0.7l0.08 0.22c0.06 0.18 0.16 0.35 0.3 0.49l0.05 0.05c0.1 0.1 0.23 0.18 0.37 0.23 0.14 0.04 0.28 0.06 0.43 0.04l0.36-0.06c0.26-0.03 0.52-0.11 0.76-0.23l0.44-0.22c0.4-0.2 0.77-0.45 1.11-0.74l0.47-0.4 0.03-0.04c0.73-0.81 1.37-1.69 1.93-2.62 0.37-0.65 0.69-1.33 0.95-2.04l0.17-0.48 0.28-0.98Z\"/>\n    </group>\n</vector>\n"
        },
        {
          "name": "ic_launcher_background.xml",
          "ext": ".xml",
          "size": 345,
          "preview": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<vector xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:width=\"108dp\"\n    android:height=\"108dp\"\n    android:viewportWidth=\"108\"\n    android:viewportHeight=\"108\">\n    <path\n        android:fillColor=\"@color/colorBackground\"\n        android:pathData=\"M0,0h108v108h-108z\" />\n</vector>\n"
        }
      ]
    },
    {
      "dir": "android/app/src/main/res/values-night-v31",
      "files": [
        {
          "name": "themes.xml",
          "ext": ".xml",
          "size": 477,
          "preview": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n  <!--\n    Having themes.xml for night-v31 because of the priority order of the resource qualifiers.\n    -->\n  <style name=\"Theme.LibrePods.AppWidgetContainerParent\" parent=\"@android:style/Theme.DeviceDefault.DayNight\">\n    <item name=\"appWidgetRadius\">@android:dimen/system_app_widget_background_radius</item>\n    <item name=\"appWidgetInnerRadius\">@android:dimen/system_app_widget_inner_radius</item>\n  </style>\n</resources>\n"
        }
      ]
    },
    {
      "dir": "android/app/src/main/res/mipmap-xhdpi",
      "files": [
        {
          "name": "ic_launcher.png",
          "ext": ".png",
          "size": 8
        },
        {
          "name": "ic_launcher_round.png",
          "ext": ".png",
          "size": 8
        }
      ]
    },
    {
      "dir": "android/app/src/main/res/drawable-v21",
      "files": [
        {
          "name": "app_widget_background.xml",
          "ext": ".xml",
          "size": 364,
          "preview": "<?xml version=\"1.0\" encoding=\"utf-8\"?><!--\nBackground for widgets to make the rounded corners based on the\nappWidgetRadius attribute value\n-->\n<shape xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:shape=\"rectangle\">\n\n    <corners android:radius=\"?attr/appWidgetRadius\" />\n    <solid android:color=\"?android:attr/colorBackground\" />\n</shape>"
        },
        {
          "name": "app_widget_inner_view_background.xml",
          "ext": ".xml",
          "size": 382,
          "preview": "<?xml version=\"1.0\" encoding=\"utf-8\"?><!--\nBackground for views inside widgets to make the rounded corners based on the\nappWidgetInnerRadius attribute value\n-->\n<shape xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:shape=\"rectangle\">\n    <corners android:radius=\"?attr/appWidgetInnerRadius\" />\n    <solid android:color=\"?android:attr/colorAccent\" />\n</shape>"
        }
      ]
    },
    {
      "dir": "android/app/src/main/res/mipmap-anydpi-v26",
      "files": [
        {
          "name": "ic_launcher_round.xml",
          "ext": ".xml",
          "size": 341,
          "preview": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<adaptive-icon xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <background android:drawable=\"@drawable/ic_launcher_background\"/>\n    <foreground android:drawable=\"@drawable/ic_launcher_foreground\"/>\n    <monochrome android:drawable=\"@drawable/ic_launcher_foreground\"/>\n</adaptive-icon>\n"
        },
        {
          "name": "ic_launcher.xml",
          "ext": ".xml",
          "size": 341,
          "preview": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<adaptive-icon xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <background android:drawable=\"@drawable/ic_launcher_background\"/>\n    <foreground android:drawable=\"@drawable/ic_launcher_foreground\"/>\n    <monochrome android:drawable=\"@drawable/ic_launcher_foreground\"/>\n</adaptive-icon>\n"
        }
      ]
    },
    {
      "dir": "android/app/src/main/res/drawable-nodpi",
      "files": [
        {
          "name": "example_appwidget_preview.png",
          "ext": ".png",
          "size": 3363
        }
      ]
    },
    {
      "dir": "android/app/src/main/res/values",
      "files": [
        {
          "name": "attrs.xml",
          "ext": ".xml",
          "size": 263,
          "preview": "<resources>\n  <declare-styleable name=\"AppWidgetAttrs\">\n    <attr name=\"appWidgetPadding\" format=\"dimension\" />\n    <attr name=\"appWidgetInnerRadius\" format=\"dimension\" />\n    <attr name=\"appWidgetRadius\" format=\"dimension\" />\n  </declare-styleable>\n</resources>\n"
        },
        {
          "name": "dimens.xml",
          "ext": ".xml",
          "size": 259,
          "preview": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n\n  <!--\nRefer to App Widget Documentation for margin information\nhttp://developer.android.com/guide/topics/appwidgets/index.html#CreatingLayout\n    -->\n  <dimen name=\"widget_margin\">0dp</dimen>\n\n</resources>\n"
        },
        {
          "name": "themes.xml",
          "ext": ".xml",
          "size": 2137,
          "preview": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources xmlns:tools=\"http://schemas.android.com/tools\">\n\n    <!-- Base application theme. -->\n    <style name=\"Theme.LibrePods\" parent=\"Theme.AppCompat.DayNight\">\n        <!-- Customize your light theme here. -->\n        <!-- <item name=\"colorPrimary\">@color/my_light_primary</item> -->\n         <item name=\"android:windowLightStatusBar\" >true</item>\n         <item name=\"android:windowLightNavigationBar\" >true</item>\n         <item name=\"android:statusBarColor\">@android:color/transparent</item>\n         <item name=\"android:navigationBarColor\">@android:color/transparent</item>\n    </style>\n\n    <!-- Theme for the transparent dialog activity -->\n    <style name=\"Theme.TransparentDialog\" parent=\"Theme.AppCompat.Dialog\">\n        <item name=\"android:windowIsTranslucent\">true</item>\n        <item name=\"android:windowBackground\">@android:color/transparent</item>\n        <item name=\"android:windowContentOverlay\">@null</item>\n        <item name=\"android:windowNoTitle\">true</item>\n        <item name=\"android:windowIsFloating\">false</item> <!-- Set to false for full width -->\n        <item name=\"android:backgroundDimEnabled\">true</item> <!-- Dim background -->\n        <item name=\"android:windowAnimationStyle\">@android:style/Animation.Translucent</item> <!-- Optional: Add animation -->\n        <item name=\"android:statusBarColor\">@android:color/transparent</item>\n        <item name=\"android:navigationBarColor\">@android:color/transparent</item>\n        <!-- Request blur behind (Android 12+) -->\n        <item name=\"android:windowBlurBehindEnabled\" tools:targetApi=\"s\">true</item>\n        <item name=\"android:windowBlurBehindRadius\" tools:targetApi=\"s\">32dp</item> <!-- Optional: Adjust radius -->\n    </style>\n\n  <style name=\"Theme.LibrePods.AppWidgetContainerParent\" parent=\"@android:style/Theme.DeviceDefault\">\n    <item name=\"appWidgetRadius\">32dp</item>\n    <item name=\"appWidgetPadding\">0dp</item>\n  </style>\n\n  <style name=\"Theme.LibrePods.AppWidgetContainer\" parent=\"Theme.LibrePods.AppWidgetContainerParent\">\n    <item name=\"appWidgetPadding\">0dp</item>\n  </style>\n</resources>\n"
        },
        {
          "name": "styles.xml",
          "ext": ".xml",
          "size": 482,
          "preview": "<resources>\n\n  <style name=\"Widget.LibrePods.AppWidget.Container\" parent=\"android:Widget\">\n    <item name=\"android:id\">@android:id/background</item>\n    <item name=\"android:background\">?android:attr/colorBackground</item>\n  </style>\n\n  <style name=\"Widget.LibrePods.AppWidget.InnerView\" parent=\"android:Widget\">\n    <item name=\"android:background\">?android:attr/colorBackground</item>\n    <item name=\"android:textColor\">?android:attr/textColorPrimary</item>\n  </style>\n</resources>\n"
        },
        {
          "name": "strings.xml",
          "ext": ".xml",
          "size": 140,
          "preview": "<resources>\n    <string name=\"app_name\">LibrePods</string>\n    <string name=\"app_hello\">Hello from LibrePods Android!</string>\n</resources>\n"
        },
        {
          "name": "colors.xml",
          "ext": ".xml",
          "size": 607,
          "preview": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n    <color name=\"black\">#FF000000</color>\n    <color name=\"white\">#FFFFFFFF</color>\n    <color name=\"popup_background\">#FFFFFF</color>\n    <color name=\"popup_text\">@color/black</color>\n    <color name=\"widget_background\">#87FFFFFF</color>\n    <color name=\"widget_text\">@color/black</color>\n    <color name=\"light_blue_50\">#FFE1F5FE</color>\n    <color name=\"light_blue_200\">#FF81D4FA</color>\n    <color name=\"light_blue_600\">#FF039BE5</color>\n    <color name=\"light_blue_900\">#FF01579B</color>\n    <color name=\"colorBackground\">#FFFFFF</color>\n</resources>\n"
        }
      ]
    },
    {
      "dir": "android/app/src/main/res/mipmap-mdpi",
      "files": [
        {
          "name": "ic_launcher.png",
          "ext": ".png",
          "size": 8
        },
        {
          "name": "ic_launcher_round.png",
          "ext": ".png",
          "size": 8
        }
      ]
    },
    {
      "dir": "android/app/src/main/res/drawable",
      "files": [
        {
          "name": "ic_launcher_foreground.xml",
          "ext": ".xml",
          "size": 706,
          "preview": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<vector xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:width=\"108dp\"\n    android:height=\"108dp\"\n    android:viewportWidth=\"108\"\n    android:viewportHeight=\"108\">\n    <group android:scaleX=\"0.65\" android:scaleY=\"0.65\" android:translateX=\"19\" android:translateY=\"19\">\n        <path\n            android:fillColor=\"#FFFFFF\"\n            android:pathData=\"M54,8a8,8 0,0 1,8 8v20a8,8 0,0 1,-8 8h-8v8h-8v-8h-8a8,8 0,0 1,-8 -8V16a8,8 0,0 1,8 -8z\"/>\n        <path\n            android:fillColor=\"#000000\"\n            android:fillAlpha=\"0.1\"\n            android:pathData=\"M54,8c4.4,0 8,3.6 8,8v20c0,4.4 -3.6,8 -8,8h-8v8h-4V8h12z\"/>\n    </group>\n</vector>\n"
        },
        {
          "name": "noise_cancellation.png",
          "ext": ".png",
          "size": 8681
        },
        {
          "name": "ic_save.xml",
          "ext": ".xml",
          "size": 507,
          "preview": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<vector xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:width=\"24dp\"\n    android:height=\"24dp\"\n    android:viewportWidth=\"24\"\n    android:viewportHeight=\"24\">\n    <path\n        android:fillColor=\"#FFFFFF\"\n        android:pathData=\"M17,3L5,3c-1.11,0 -2,0.9 -2,2v14c0,1.1 0.89,2 2,2h14c1.1,0 2,-0.9 2,-2L21,7l-4,-4zM19,19L5,19L5,5h11.17L19,7.83L19,19zM12,12c-1.66,0 -3,1.34 -3,3s1.34,3 3,3 3,-1.34 3,-3 -1.34,-3 -3,-3zM6,6h9v4L6,10z\" />\n</vector>\n"
        },
        {
          "name": "popup_shape.xml",
          "ext": ".xml",
          "size": 370,
          "preview": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<shape\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:shape=\"rectangle\">\n\n    <solid\n        android:color=\"@color/popup_background\">\n    </solid>\n\n    <padding\n        android:bottom=\"56dp\"\n        android:top=\"16dp\">\n    </padding>\n\n    <corners\n        android:radius=\"56dp\">\n    </corners>\n\n</shape>"
        },
        {
          "name": "island_battery_progress.xml",
          "ext": ".xml",
          "size": 308,
          "preview": "<rotate\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:fromDegrees=\"270\"\n    android:toDegrees=\"270\">\n    <shape\n        android:shape=\"ring\"\n        android:innerRadiusRatio=\"3.0\"\n        android:thickness=\"4dp\" >\n        <solid android:color=\"#1ceb72\" />\n    </shape>\n</rotate>\n"
        },
        {
          "name": "close.xml",
          "ext": ".xml",
          "size": 382,
          "preview": "<vector xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:width=\"24dp\"\n    android:height=\"24dp\"\n    android:viewportWidth=\"960\"\n    android:viewportHeight=\"960\">\n  <path\n      android:fillColor=\"@android:color/white\"\n      android:pathData=\"M256,760L200,704L424,480L200,256L256,200L480,424L704,200L760,256L536,480L760,704L704,760L480,536L256,760Z\"/>\n</vector>\n"
        },
        {
          "name": "ic_bluetooth.xml",
          "ext": ".xml",
          "size": 433,
          "preview": "<vector xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:width=\"24dp\"\n    android:height=\"24dp\"\n    android:viewportWidth=\"960\"\n    android:viewportHeight=\"960\">\n  <path\n      android:pathData=\"M440,880v-304L256,760l-56,-56 224,-224 -224,-224 56,-56 184,184v-304h40l228,228 -172,172 172,172L480,880h-40ZM520,384 L596,308 520,234v150ZM520,726 L596,652 520,576v150Z\"\n      android:fillColor=\"#e8eaed\"/>\n</vector>\n"
        },
        {
          "name": "airpods_pro_left_notification.xml",
          "ext": ".xml",
          "size": 1554,
          "preview": "<vector xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:width=\"94.19dp\"\n    android:height=\"123.31dp\"\n    android:viewportWidth=\"94.19\"\n    android:viewportHeight=\"123.31\">\n  <path\n      android:fillColor=\"#FF000000\"\n      android:pathData=\"M0,0h94.19v123.31h-94.19z\"\n      android:strokeAlpha=\"0\"\n      android:fillAlpha=\"0\"/>\n  <path\n      android:pathData=\"M46.81,73.29L46.81,111.06C46.81,114.94 44.25,116.94 40.38,116.94L35.5,116.94C31.63,116.94 29.06,114.94 29.06,111.06L29.06,69.82C33.68,71.55 39.25,72.79 46.81,73.29Z\"\n      android:fillColor=\"#ffffff\"\n      android:fillAlpha=\"0.85\"/>\n  <path\n      android:pathData=\"M62,22.63C62.94,23.8 64.28,25.84 65.55,28.29C51.19,30.59 40.75,43.46 40.75,56.13C40.75,60.05 41.47,63.51 42.75,66.49C34.56,65.53 29.44,63.52 24.75,60.88C14.44,54.94 6.31,45.31 6.31,31.5C6.31,15.56 17.56,6.5 31.38,6.38C42.06,6.25 54,11.5 62,22.63ZM19.44,21.25C18.31,22.5 18.38,24.38 19.69,25.44L29,33.19C30.19,34.25 32.13,34.13 33.19,32.81C34.25,31.5 34.13,29.63 32.75,28.56L23.63,20.81C22.31,19.75 20.44,19.94 19.44,21.25Z\"\n      android:fillColor=\"#ffffff\"\n      android:fillAlpha=\"0.85\"/>\n  <path\n      android:pathData=\"M65.13,74.25C76.31,74.25 87.81,65.38 87.81,51.81C87.81,42.75 81.44,33.88 70.19,33.88C57,33.88 46.81,45.31 46.81,56.13C46.81,68.25 55.38,74.25 65.13,74.25ZM68.19,64.75C66.44,63.25 67.44,60.25 71,55.69C74.69,51.19 77.63,49.69 79.5,51.31C81.19,52.81 80.25,55.88 76.69,60.31C72.94,64.75 70,66.31 68.19,64.75Z\"\n      android:fillColor=\"#ffffff\"\n      android:fillAlpha=\"0.85\"/>\n</vector>\n"
        },
        {
          "name": "pro_2_right.png",
          "ext": ".png",
          "size": 35634
        },
        {
          "name": "pro_2_buds.png",
          "ext": ".png",
          "size": 619325
        },
        {
          "name": "circular_progress_bar.xml",
          "ext": ".xml",
          "size": 381,
          "preview": "<rotate\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:fromDegrees=\"270\"\n    android:toDegrees=\"270\">\n    <shape\n        android:shape=\"ring\"\n        android:innerRadiusRatio=\"3.0\"\n        android:thickness=\"6dp\"\n        android:useLevel=\"true\">\n        <solid android:color=\"#00D85B\" />\n        <corners android:radius=\"10dp\" />\n    </shape>\n</rotate>\n"
        },
        {
          "name": "progress_bar_background.xml",
          "ext": ".xml",
          "size": 334,
          "preview": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<selector xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <item>\n        <shape\n            android:shape=\"ring\"\n            android:innerRadiusRatio=\"3.0\"\n            android:thickness=\"6dp\">\n            <solid android:color=\"#49474E\" />\n        </shape>\n    </item>\n</selector>"
        },
        {
          "name": "airpods_pro_right_notification.xml",
          "ext": ".xml",
          "size": 1548,
          "preview": "<vector xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:width=\"94.19dp\"\n    android:height=\"123.31dp\"\n    android:viewportWidth=\"94.19\"\n    android:viewportHeight=\"123.31\">\n  <path\n      android:fillColor=\"#FF000000\"\n      android:pathData=\"M0,0h94.19v123.31h-94.19z\"\n      android:strokeAlpha=\"0\"\n      android:fillAlpha=\"0\"/>\n  <path\n      android:pathData=\"M65.06,111.06C65.06,114.94 62.56,116.94 58.69,116.94L53.81,116.94C49.88,116.94 47.31,114.94 47.31,111.06L47.31,73.29C54.87,72.79 60.44,71.56 65.06,69.84Z\"\n      android:fillColor=\"#ffffff\"\n      android:fillAlpha=\"0.85\"/>\n  <path\n      android:pathData=\"M87.81,31.5C87.81,45.31 79.69,54.94 69.44,60.88C64.74,63.52 59.6,65.54 51.37,66.5C52.65,63.51 53.38,60.05 53.38,56.13C53.38,43.47 43,30.6 28.61,28.29C29.89,25.84 31.25,23.8 32.19,22.63C40.19,11.5 52.06,6.25 62.81,6.38C76.56,6.5 87.81,15.56 87.81,31.5ZM70.56,20.81L61.38,28.56C60.06,29.63 59.94,31.5 61,32.81C62.06,34.13 63.94,34.25 65.19,33.19L74.44,25.44C75.75,24.38 75.81,22.5 74.75,21.25C73.75,19.94 71.81,19.75 70.56,20.81Z\"\n      android:fillColor=\"#ffffff\"\n      android:fillAlpha=\"0.85\"/>\n  <path\n      android:pathData=\"M29.06,74.25C38.81,74.25 47.38,68.25 47.38,56.13C47.38,45.31 37.19,33.88 23.94,33.88C12.75,33.88 6.31,42.75 6.31,51.81C6.31,65.38 17.88,74.25 29.06,74.25ZM26,64.75C24.19,66.31 21.25,64.75 17.5,60.31C13.88,55.88 12.94,52.81 14.69,51.31C16.56,49.69 19.44,51.19 23.19,55.69C26.75,60.25 27.75,63.25 26,64.75Z\"\n      android:fillColor=\"#ffffff\"\n      android:fillAlpha=\"0.85\"/>\n</vector>\n"
        },
        {
          "name": "pro_2.png",
          "ext": ".png",
          "size": 64915
        },
        {
          "name": "widget_button_shape_start.xml",
          "ext": ".xml",
          "size": 863,
          "preview": "<selector xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <item android:state_pressed=\"true\">\n        <shape android:shape=\"rectangle\">\n            <solid android:color=\"#3D3B40\" />\n            <corners android:topLeftRadius=\"24dp\" android:topRightRadius=\"4dp\" android:bottomLeftRadius=\"24dp\" android:bottomRightRadius=\"4dp\" />\n            <padding android:left=\"8dp\" android:top=\"8dp\" android:right=\"8dp\" android:bottom=\"8dp\" />\n        </shape>\n    </item>\n    <item>\n        <shape android:shape=\"rectangle\">\n            <solid android:color=\"#49474E\" />\n            <corners android:topLeftRadius=\"24dp\" android:topRightRadius=\"4dp\" android:bottomLeftRadius=\"24dp\" android:bottomRightRadius=\"4dp\" />\n            <padding android:left=\"8dp\" android:top=\"8dp\" android:right=\"8dp\" android:bottom=\"8dp\" />\n        </shape>\n    </item>\n</selector>\n"
        },
        {
          "name": "pro_2_left.png",
          "ext": ".png",
          "size": 34156
        },
        {
          "name": "widget_button_checked_shape_start.xml",
          "ext": ".xml",
          "size": 458,
          "preview": "<selector xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <item>\n        <shape android:shape=\"rectangle\">\n            <solid android:color=\"#2C2A2F\" />\n            <corners android:topLeftRadius=\"24dp\" android:topRightRadius=\"4dp\" android:bottomLeftRadius=\"24dp\" android:bottomRightRadius=\"4dp\" />\n            <padding android:bottom=\"8dp\" android:left=\"8dp\" android:right=\"8dp\" android:top=\"8dp\" />\n        </shape>\n    </item>\n</selector>\n"
        },
        {
          "name": "adaptive.png",
          "ext": ".png",
          "size": 4255
        },
        {
          "name": "island_battery_background.xml",
          "ext": ".xml",
          "size": 339,
          "preview": "<rotate\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:fromDegrees=\"270\"\n    android:toDegrees=\"270\">\n    <shape\n        android:shape=\"ring\"\n        android:innerRadiusRatio=\"3.0\"\n        android:thickness=\"4dp\"\n        android:useLevel=\"true\">\n        <solid android:color=\"#0f4524\" />\n    </shape>\n</rotate>\n"
        },
        {
          "name": "widget_button_shape_end.xml",
          "ext": ".xml",
          "size": 863,
          "preview": "<selector xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <item android:state_pressed=\"true\">\n        <shape android:shape=\"rectangle\">\n            <solid android:color=\"#3D3B40\" />\n            <corners android:topLeftRadius=\"4dp\" android:topRightRadius=\"24dp\" android:bottomLeftRadius=\"4dp\" android:bottomRightRadius=\"24dp\" />\n            <padding android:left=\"8dp\" android:top=\"8dp\" android:right=\"8dp\" android:bottom=\"8dp\" />\n        </shape>\n    </item>\n    <item>\n        <shape android:shape=\"rectangle\">\n            <solid android:color=\"#49474E\" />\n            <corners android:topLeftRadius=\"4dp\" android:topRightRadius=\"24dp\" android:bottomLeftRadius=\"4dp\" android:bottomRightRadius=\"24dp\" />\n            <padding android:left=\"8dp\" android:top=\"8dp\" android:right=\"8dp\" android:bottom=\"8dp\" />\n        </shape>\n    </item>\n</selector>\n"
        },
        {
          "name": "airpods.xml",
          "ext": ".xml",
          "size": 2655,
          "preview": "<vector xmlns:android=\"http://schemas.android.com/apk/res/android\" android:height=\"43dp\" android:viewportHeight=\"607.69\" android:viewportWidth=\"902.34\" android:width=\"63.849365dp\">\n    <path android:fillAlpha=\"0\" android:fillColor=\"#FF000000\" android:pathData=\"M0,0h902.34v607.69h-902.34z\" android:strokeAlpha=\"0\"/>\n\n    <path android:fillAlpha=\"0.85\" android:fillColor=\"#ffffff\" android:pathData=\"M315.92,550.31C315.92,567.88 304.69,577.41 286.13,577.41L261.48,577.41C242.92,577.41 231.45,567.88 231.45,550.31L231.45,358.73C267.25,355.98 293.73,349.94 315.92,341.64ZM670.9,358.73L670.9,550.31C670.9,567.88 659.42,577.41 640.87,577.41L616.21,577.41C597.66,577.41 586.43,567.88 586.43,550.31L586.43,341.64C608.62,349.94 635.09,355.98 670.9,358.73Z\"/>\n\n    <path android:fillAlpha=\"0.85\" android:fillColor=\"#ffffff\" android:pathData=\"M429.2,153.09C429.2,221.45 388.18,270.28 335.2,299.57C312.69,312 288.17,321.38 249.56,326.11C255.64,311.65 259.03,294.95 259.03,276.14C259.03,213.57 207.98,151 137.53,139.93C143.33,128.37 149.48,118.78 153.81,113.29C192.14,56.65 252.44,29.55 306.64,30.29C375.24,31.02 429.2,76.43 429.2,153.09ZM748.53,113.29C752.86,118.78 759.01,128.37 764.82,139.93C694.36,151 643.31,213.57 643.31,276.14C643.31,294.95 646.71,311.65 652.78,326.11C614.17,321.38 589.66,312 567.14,299.57C514.16,270.28 473.14,221.45 473.14,153.09C473.14,76.43 527.1,31.02 595.7,30.29C649.9,29.55 710.21,56.65 748.53,113.29ZM346.19,100.11L301.51,137.71C295.41,142.84 294.68,151.62 299.56,157.48C304.69,163.83 313.72,164.32 319.34,159.44L364.75,121.84C370.85,116.71 371.09,107.92 365.97,102.06C361.33,95.72 352.3,94.98 346.19,100.11ZM536.38,102.06C531.25,107.92 531.49,116.71 537.6,121.84L583.01,159.44C588.62,164.32 597.66,163.83 602.78,157.48C607.67,151.62 606.93,142.84 600.83,137.71L556.15,100.11C550.05,94.98 541.02,95.72 536.38,102.06Z\"/>\n\n    <path android:fillAlpha=\"0.85\" android:fillColor=\"#ffffff\" android:pathData=\"M140.87,364.76C189.45,364.76 229.98,334.48 229.98,276.14C229.98,222.43 180.18,167.25 114.99,167.25C61.28,167.25 29.05,209.24 29.05,254.65C29.05,320.08 84.72,364.76 140.87,364.76ZM125.98,319.59C117.19,327.16 102.29,319.35 84.23,297.38C66.41,275.89 61.52,260.51 70.07,252.94C79.1,245.37 93.75,252.94 111.82,274.92C129.4,297.13 134.52,312.27 125.98,319.59ZM761.47,364.76C817.63,364.76 873.29,320.08 873.29,254.65C873.29,209.24 841.06,167.25 787.35,167.25C722.17,167.25 672.36,222.43 672.36,276.14C672.36,334.48 712.89,364.76 761.47,364.76ZM776.37,319.59C767.82,312.27 772.95,297.13 790.53,274.92C808.59,252.94 823.24,245.37 832.28,252.94C840.82,260.51 835.94,275.89 818.11,297.38C800.29,319.35 785.16,327.16 776.37,319.59Z\"/>\n\n</vector>"
        },
        {
          "name": "airpods_pro_case_notification.xml",
          "ext": ".xml",
          "size": 1015,
          "preview": "<vector xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:width=\"141.5dp\"\n    android:height=\"109.06dp\"\n    android:viewportWidth=\"141.5\"\n    android:viewportHeight=\"109.06\">\n  <path\n      android:fillColor=\"#FF000000\"\n      android:pathData=\"M0,0h141.5v109.06h-141.5z\"\n      android:strokeAlpha=\"0\"\n      android:fillAlpha=\"0\"/>\n  <path\n      android:pathData=\"M37.88,109L103.63,109C129.19,109 141.5,96.75 141.5,71.31L141.5,41.63L102.81,41.63C101.75,44.44 99.13,46.25 95.81,46.25L45.75,46.25C42.5,46.25 39.75,44.44 38.75,41.63L0,41.63L0,71.31C0,96.75 12.38,109 37.88,109ZM70.75,70.06C67.63,70.13 65.06,67.5 65.06,64.44C65.06,61.31 67.63,58.69 70.75,58.69C73.88,58.69 76.5,61.31 76.5,64.44C76.5,67.38 73.88,70 70.75,70.06ZM0,35.94L38.63,35.94C39.63,33.06 42.38,31.31 45.63,31.31L95.75,31.31C99,31.31 101.69,33.06 102.69,35.94L141.31,35.94L141.31,33.94C141.31,11.13 127.81,0 103.44,0L37.88,0C13.56,0 0,11.13 0,33.94Z\"\n      android:fillColor=\"#ffffff\"\n      android:fillAlpha=\"0.85\"/>\n</vector>\n"
        },
        {
          "name": "popup_button_shape.xml",
          "ext": ".xml",
          "size": 398,
          "preview": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<shape\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:shape=\"rectangle\">\n\n    <solid\n        android:color=\"#902E2E2E\">\n    </solid>\n\n    <padding\n        android:left=\"1dp\"\n        android:top=\"1dp\"\n        android:right=\"1dp\"\n        android:bottom=\"1dp\" />\n\n    <corners\n        android:radius=\"5000dp\">\n    </corners>\n\n</shape>"
        },
        {
          "name": "island_background.xml",
          "ext": ".xml",
          "size": 359,
          "preview": "<layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <item>\n        <shape android:shape=\"rectangle\">\n            <solid android:color=\"#000000\"/>\n            <corners android:radius=\"56dp\"/>\n            <padding android:left=\"4dp\" android:top=\"4dp\" android:right=\"4dp\" android:bottom=\"4dp\"/>\n        </shape>\n    </item>\n</layer-list>\n"
        },
        {
          "name": "ic_layers.xml",
          "ext": ".xml",
          "size": 415,
          "preview": "<vector xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:width=\"24dp\"\n    android:height=\"24dp\"\n    android:viewportWidth=\"960\"\n    android:viewportHeight=\"960\">\n  <path\n      android:pathData=\"M480,842 L120,562l66,-50 294,228 294,-228 66,50 -360,280ZM480,640L120,360l360,-280 360,280 -360,280ZM480,360ZM480,538 L710,360 480,182 250,360 480,538Z\"\n      android:fillColor=\"#e8eaed\"/>\n</vector>\n"
        },
        {
          "name": "widget_button_shape_middle.xml",
          "ext": ".xml",
          "size": 661,
          "preview": "<selector xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <item android:state_pressed=\"true\">\n        <shape android:shape=\"rectangle\">\n            <solid android:color=\"#3D3B40\" />\n            <corners android:radius=\"4dp\" />\n            <padding android:left=\"8dp\" android:top=\"8dp\" android:right=\"8dp\" android:bottom=\"8dp\" />\n        </shape>\n    </item>\n    <item>\n        <shape android:shape=\"rectangle\">\n            <solid android:color=\"#49474E\" />\n            <corners android:radius=\"4dp\" />\n            <padding android:left=\"8dp\" android:top=\"8dp\" android:right=\"8dp\" android:bottom=\"8dp\" />\n        </shape>\n    </item>\n</selector>\n"
        },
        {
          "name": "settings_voice.xml",
          "ext": ".xml",
          "size": 1119,
          "preview": "<vector xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:width=\"24dp\"\n    android:height=\"24dp\"\n    android:viewportWidth=\"960\"\n    android:viewportHeight=\"960\"\n    android:tint=\"?attr/colorControlNormal\">\n  <path\n      android:fillColor=\"@android:color/white\"\n      android:pathData=\"M320,960Q303,960 291.5,948.5Q280,937 280,920Q280,903 291.5,891.5Q303,880 320,880Q337,880 348.5,891.5Q360,903 360,920Q360,937 348.5,948.5Q337,960 320,960ZM480,960Q463,960 451.5,948.5Q440,937 440,920Q440,903 451.5,891.5Q463,880 480,880Q497,880 508.5,891.5Q520,903 520,920Q520,937 508.5,948.5Q497,960 480,960ZM640,960Q623,960 611.5,948.5Q600,937 600,920Q600,903 611.5,891.5Q623,880 640,880Q657,880 668.5,891.5Q680,903 680,920Q680,937 668.5,948.5Q657,960 640,960ZM480,560Q430,560 395,525Q360,490 360,440L360,200Q360,150 395,115Q430,80 480,80Q530,80 565,115Q600,150 600,200L600,440Q600,490 565,525Q530,560 480,560ZM440,840L440,716Q336,702 268,623.5Q200,545 200,440L280,440Q280,523 338.5,581.5Q397,640 480,640Q563,640 621.5,581.5Q680,523 680,440L760,440Q760,545 692,623.5Q624,702 520,716L520,840L440,840Z\"/>\n</vector>\n"
        },
        {
          "name": "widget_button_checked_shape_end.xml",
          "ext": ".xml",
          "size": 458,
          "preview": "<selector xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <item>\n        <shape android:shape=\"rectangle\">\n            <solid android:color=\"#2C2A2F\" />\n            <corners android:topLeftRadius=\"4dp\" android:topRightRadius=\"24dp\" android:bottomLeftRadius=\"4dp\" android:bottomRightRadius=\"24dp\" />\n            <padding android:bottom=\"8dp\" android:left=\"8dp\" android:right=\"8dp\" android:top=\"8dp\" />\n        </shape>\n    </item>\n</selector>\n"
        },
        {
          "name": "pro_2_case.png",
          "ext": ".png",
          "size": 56178
        },
        {
          "name": "widget_button_checked_shape_middle.xml",
          "ext": ".xml",
          "size": 357,
          "preview": "<selector xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <item>\n        <shape android:shape=\"rectangle\">\n            <solid android:color=\"#2C2A2F\" />\n            <corners android:radius=\"4dp\" />\n            <padding android:bottom=\"8dp\" android:left=\"8dp\" android:right=\"8dp\" android:top=\"8dp\" />\n        </shape>\n    </item>\n</selector>\n"
        },
        {
          "name": "ic_launcher_background.xml",
          "ext": ".xml",
          "size": 178,
          "preview": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<shape xmlns:android=\"http://schemas.android.com/apk/res/android\" android:shape=\"rectangle\">\n    <solid android:color=\"#3DDC84\"/>\n</shape>\n"
        },
        {
          "name": "conversational_awareness.xml",
          "ext": ".xml",
          "size": 1640,
          "preview": "<vector xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:width=\"154.38dp\"\n    android:height=\"148.1dp\"\n    android:viewportWidth=\"154.38\"\n    android:viewportHeight=\"148.1\">\n  <path\n      android:fillColor=\"#FF000000\"\n      android:pathData=\"M0,0h154.38v148.1h-154.38z\"\n      android:strokeAlpha=\"0\"\n      android:fillAlpha=\"0\"/>\n  <path\n      android:pathData=\"M134.81,86.77C137.13,88.33 140,87.77 141.69,85.39C149.69,74.39 154.38,59.27 154.38,43.83C154.38,28.39 149.75,13.14 141.69,2.27C140,-0.17 137.13,-0.67 134.81,0.89C132.5,2.46 132.13,5.39 133.94,7.96C140.81,17.58 144.69,30.52 144.69,43.83C144.69,57.14 140.69,69.96 133.94,79.71C132.19,82.27 132.5,85.21 134.81,86.77Z\"\n      android:fillColor=\"#ffffff\"\n      android:fillAlpha=\"0.85\"/>\n  <path\n      android:pathData=\"M111.69,70.46C113.75,71.89 116.69,71.46 118.38,69.02C123.19,62.71 126.06,53.39 126.06,43.83C126.06,34.27 123.19,25.02 118.38,18.58C116.69,16.21 113.75,15.71 111.69,17.21C109.13,18.96 108.75,22.08 110.69,24.64C114.31,29.64 116.38,36.58 116.38,43.83C116.38,51.08 114.25,57.96 110.69,63.02C108.81,65.64 109.13,68.64 111.69,70.46Z\"\n      android:fillColor=\"#ffffff\"\n      android:fillAlpha=\"0.85\"/>\n  <path\n      android:pathData=\"M26.13,130.21L104.63,130.21C114.44,130.21 117.94,127.39 117.94,121.89C117.94,105.77 97.75,83.52 65.38,83.52C32.94,83.52 12.75,105.77 12.75,121.89C12.75,127.39 16.25,130.21 26.13,130.21ZM65.38,72.33C78.81,72.33 90.38,60.33 90.38,44.71C90.38,29.27 78.75,17.83 65.38,17.83C52,17.83 40.38,29.52 40.38,44.83C40.38,60.33 52,72.33 65.38,72.33Z\"\n      android:fillColor=\"#ffffff\"\n      android:fillAlpha=\"0.85\"/>\n</vector>\n"
        },
        {
          "name": "widget_background.xml",
          "ext": ".xml",
          "size": 362,
          "preview": "<layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <item>\n        <shape android:shape=\"rectangle\">\n            <padding android:bottom=\"0dp\" android:left=\"0dp\" android:right=\"0dp\" android:top=\"0dp\" />\n            <solid android:color=\"#222222\" />\n            <corners android:radius=\"32dp\" />\n        </shape>\n    </item>\n</layer-list>\n"
        },
        {
          "name": "smartphone.xml",
          "ext": ".xml",
          "size": 1122,
          "preview": "<vector xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:width=\"80.31dp\"\n    android:height=\"132.44dp\"\n    android:viewportWidth=\"80.31\"\n    android:viewportHeight=\"132.44\">\n  <path\n      android:fillColor=\"#FF000000\"\n      android:pathData=\"M0,0h80.31v132.44h-80.31z\"\n      android:strokeAlpha=\"0\"\n      android:fillAlpha=\"0\"/>\n  <path\n      android:pathData=\"M12.44,114.31C11.06,114.31 10.06,113.31 10.06,111.94L10.06,12.44C10.06,11 11,10.06 12.44,10.06L67.88,10.06C69.31,10.06 70.25,11 70.25,12.44L70.25,111.94C70.25,113.31 69.31,114.31 67.88,114.31Z\"\n      android:fillColor=\"#ffffff\"\n      android:fillAlpha=\"0.2125\"/>\n  <path\n      android:pathData=\"M7.75,132.31L72.56,132.31C77.13,132.31 80.31,129.13 80.31,124.56L80.31,7.75C80.31,3.19 77.13,0 72.56,0L7.75,0C3.19,0 0,3.19 0,7.75L0,124.56C0,129.13 3.25,132.31 7.75,132.31ZM12.44,114.31C11.06,114.31 10.06,113.31 10.06,111.94L10.06,12.44C10.06,11 11,10.06 12.44,10.06L67.88,10.06C69.31,10.06 70.25,11 70.25,12.44L70.25,111.94C70.25,113.31 69.31,114.31 67.88,114.31Z\"\n      android:fillColor=\"#ffffff\"\n      android:fillAlpha=\"0.85\"/>\n</vector>\n"
        },
        {
          "name": "transparency.png",
          "ext": ".png",
          "size": 9219
        },
        {
          "name": "ic_power.xml",
          "ext": ".xml",
          "size": 734,
          "preview": "<vector xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:width=\"88.06dp\"\n    android:height=\"140.66dp\"\n    android:viewportWidth=\"88.06\"\n    android:viewportHeight=\"140.66\">\n  <path\n      android:fillColor=\"#FF000000\"\n      android:pathData=\"M0,0h88.06v140.66h-88.06z\"\n      android:strokeAlpha=\"0\"\n      android:fillAlpha=\"0\"/>\n  <path\n      android:pathData=\"M0,77.55C0,79.99 1.88,81.8 4.5,81.8L39.81,81.8L21.19,132.42C18.75,138.86 25.44,142.3 29.63,137.05L86.44,66.05C87.5,64.74 88.06,63.49 88.06,62.05C88.06,59.67 86.19,57.8 83.56,57.8L48.25,57.8L66.88,7.17C69.31,0.74 62.63,-2.7 58.44,2.61L1.63,73.55C0.56,74.92 0,76.17 0,77.55Z\"\n      android:fillColor=\"#ffffff\"\n      android:fillAlpha=\"0.85\"/>\n</vector>\n"
        }
      ]
    },
    {
      "dir": "android/app/src/main/resources",
      "files": []
    },
    {
      "dir": "android/app/src/main/resources/META-INF",
      "files": []
    },
    {
      "dir": "android/app/src/main/resources/META-INF/xposed",
      "files": [
        {
          "name": "native_init.list",
          "ext": ".list",
          "size": 19
        },
        {
          "name": "java_init.list",
          "ext": ".list",
          "size": 44
        },
        {
          "name": "module.prop",
          "ext": ".prop",
          "size": 56
        },
        {
          "name": "scope.list",
          "ext": ".list",
          "size": 100
        }
      ]
    },
    {
      "dir": "android/app/src/main/java",
      "files": []
    },
    {
      "dir": "android/app/src/main/java/com",
      "files": []
    },
    {
      "dir": "android/app/src/main/java/com/yourco",
      "files": []
    },
    {
      "dir": "android/app/src/main/java/com/yourco/airpods",
      "files": [
        {
          "name": "L2capCocManager.kt",
          "ext": ".kt",
          "size": 1583,
          "preview": "package com.yourco.airpods\n\nimport android.bluetooth.*\nimport android.os.Build\nimport android.util.Log\nimport kotlinx.coroutines.*\nimport java.io.InputStream\nimport java.io.OutputStream\n\n/**\n * Minimal BLE L2CAP CoC helper for API 29+.\n * - Server: listenUsingL2capChannel() \u2192 accept()\n * - Client: device.createL2capChannel(psm)\n * Falls back to GATT when unavailable.\n */\nclass L2capCocManager {\n  data class Channel(val socket: BluetoothSocket, val input: InputStream, val output: OutputStream)\n\n  fun isSupported(): Boolean = Build.VERSION.SDK_INT >= 29\n\n  /** Start a server; returns the assigned PSM. Accept runs on a coroutine and invokes onClient */\n  fun startServer(scope: CoroutineScope, adapter: BluetoothAdapter, onClient: (Channel) -> Unit): Int {\n    require(isSupported()) { \"L2CAP CoC requires API 29+\" }\n    val server: BluetoothServerSocket = adapter.listenUsingL2capChannel()\n    val psm = server.psm\n    scope.launch(Dispatchers.IO) {\n      try {\n        val sock = server.accept()\n        onClient(Channel(sock, sock.inputStream, sock.outputStream))\n      } catch (e: Throwable) {\n        Log.e(\"L2capCoc\", \"Server accept failed: ${e.message}\", e)\n      } finally {\n        try { server.close() } catch (_: Throwable) {}\n      }\n    }\n    return psm\n  }\n\n  /** Connect as a client to a remote PSM */\n  fun connectClient(device: BluetoothDevice, psm: Int): Channel {\n    require(isSupported()) { \"L2CAP CoC requires API 29+\" }\n    val sock = device.createL2capChannel(psm)\n    sock.connect()\n    return Channel(sock, sock.inputStream, sock.outputStream)\n  }\n}\n"
        },
        {
          "name": "MainActivity.kt",
          "ext": ".kt",
          "size": 300,
          "preview": "package com.yourco.airpods\n\nimport android.os.Bundle\nimport androidx.appcompat.app.AppCompatActivity\n\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n    }\n}\n"
        },
        {
          "name": "BleClient.kt",
          "ext": ".kt",
          "size": 3170,
          "preview": "import me.kavishdevar.librepods.utils.SettingsManager\npackage com.yourco.airpods\n\nimport android.bluetooth.*\nimport android.bluetooth.le.*\nimport android.content.Context\nimport android.os.ParcelUuid\nimport java.util.*\n\nprivate val SERVICE_UUID = UUID.fromString(\"D0611E78-BBB4-4591-A5F8-487910AE4366\")\nprivate val CHAR_UUID    = UUID.fromString(\"8667556C-9A37-4C91-84ED-54EE27D90049\")\n\nclass BleClient(private val ctx: Context): BluetoothGattCallback() {\n  private val coc = L2capCocManager()\n  @Volatile private var useCocPreferred = SettingsManager.isUseCoc(ctx) // user setting, defaults true\n  private val adapter = BluetoothAdapter.getDefaultAdapter()\n  private val scanner get() = adapter?.bluetoothLeScanner\n\n  fun startScan() {\n    val filter = ScanFilter.Builder().setServiceUuid(ParcelUuid(SERVICE_UUID)).build()\n    val settings = ScanSettings.Builder().setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY).build()\n    scanner?.startScan(listOf(filter), settings, scanCb)\n  }\n\n  private val scanCb = object: ScanCallback() {\n    override fun onScanResult(type:Int, result:ScanResult) {\n      scanner?.stopScan(this)\n      result.device.connectGatt(ctx, false, this@BleClient, BluetoothDevice.TRANSPORT_LE)\n    }\n  }\n\n  override fun onConnectionStateChange(gatt: BluetoothGatt, status: Int, newState: Int) {\n    if (newState == BluetoothProfile.STATE_CONNECTED) gatt.discoverServices()\n    if (newState == BluetoothProfile.STATE_DISCONNECTED) gatt.close()\n  }\n\n  override fun onServicesDiscovered(gatt: BluetoothGatt, status: Int) {\n    val svc = gatt.getService(SERVICE_UUID) ?: return gatt.disconnect()\n    val chr = svc.getCharacteristic(CHAR_UUID) ?: return gatt.disconnect()\n\n    // Try L2CAP CoC if supported and PSM characteristic present; otherwise read data over GATT\n    val psmChar = try { svc.getCharacteristic(UUID.fromString(\"0000FF01-0000-1000-8000-00805F9B34FB\")) } catch (_: Throwable) { null }\n    if (psmChar != null && coc.isSupported() && useCocPreferred) {\n      // Read PSM\n      gatt.readCharacteristic(psmChar)\n      return\n    }\n    gatt.readCharacteristic(chr)\n  }\n\n  override fun onCharacteristicRead(gatt: BluetoothGatt, chr: BluetoothGattCharacteristic, status: Int) {\n    if (status == BluetoothGatt.GATT_SUCCESS) {\n      val bytes = chr.value\n\n    // If we just read the PSM characteristic, try L2CAP CoC\n    if (chr.uuid == UUID.fromString(\"0000FF01-0000-1000-8000-00805F9B34FB\") && coc.isSupported() && useCocPreferred) {\n      val psm = java.nio.ByteBuffer.wrap(bytes).order(java.nio.ByteOrder.LITTLE_ENDIAN).short.toInt() and 0xFFFF\n      try {\n        val ch = coc.connectClient(gatt.device, psm)\n        // Example: request a simple info packet over CoC then close\n        ch.output.write(byteArrayOf(0x01, 0x00)) // app-specific\n        val tmp = ByteArray(128)\n        val n = ch.input.read(tmp)\n        // parse via JNI if it matches expected payload, else ignore\n        gatt.disconnect()\n        return\n      } catch (e: Throwable) {\n        // Fall back to GATT if CoC connect fails\n        useCocPreferred = false\n      }\n    }\n      val model = NativeBridge.parseAirPodsPayload(bytes)\n    }\n    gatt.disconnect()\n  }\n}\n"
        },
        {
          "name": "NativeBridge.kt",
          "ext": ".kt",
          "size": 161,
          "preview": "package com.yourco.airpods\n\nobject NativeBridge {\n  init { System.loadLibrary(\"airpods_core\") }\n  external fun parseAirPodsPayload(payload: ByteArray): String\n}\n"
        },
        {
          "name": "Prefs.kt",
          "ext": ".kt",
          "size": 549,
          "preview": "package com.yourco.airpods\n\nimport android.content.Context\nimport android.content.SharedPreferences\n\nobject Prefs {\n  private const val FILE = \"airpods_prefs\"\n  private const val KEY_PREFER_COC = \"prefer_coc\"\n\n  private fun prefs(ctx: Context): SharedPreferences =\n    ctx.getSharedPreferences(FILE, Context.MODE_PRIVATE)\n\n  fun setPreferCoc(ctx: Context, value: Boolean) {\n    prefs(ctx).edit().putBoolean(KEY_PREFER_COC, value).apply()\n  }\n\n  fun getPreferCoc(ctx: Context): Boolean =\n    prefs(ctx).getBoolean(KEY_PREFER_COC, /*default=*/true)\n}\n"
        }
      ]
    },
    {
      "dir": "android/app/src/main/java/me",
      "files": []
    },
    {
      "dir": "android/app/src/main/java/me/kavishdevar",
      "files": []
    },
    {
      "dir": "android/app/src/main/java/me/kavishdevar/librepods",
      "files": [
        {
          "name": "MainActivity.kt",
          "ext": ".kt",
          "size": 28056,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n *\n * Copyright (C) 2025 LibrePods contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\n@file:OptIn(ExperimentalEncodingApi::class)\n\npackage me.kavishdevar.librepods\n\nimport android.annotation.SuppressLint\nimport android.content.BroadcastReceiver\nimport android.content.ComponentName\nimport android.content.Context\nimport android.content.Context.MODE_PRIVATE\nimport android.content.Intent\nimport android.content.ServiceConnection\nimport android.content.SharedPreferences\nimport android.net.Uri\nimport android.os.Build\nimport android.os.Bundle\nimport android.os.IBinder\nimport android.provider.Settings\nimport android.util.Log\nimport android.widget.Toast\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.activity.enableEdgeToEdge\nimport androidx.compose.animation.core.RepeatMode\nimport androidx.compose.animation.core.animateFloat\nimport androidx.compose.animation.core.infiniteRepeatable\nimport androidx.compose.animation.core.rememberInfiniteTransition\nimport androidx.compose.animation.core.tween\nimport androidx.compose.animation.fadeIn\nimport androidx.compose.animation.fadeOut\nimport androidx.compose.animation.slideInHorizontally\nimport androidx.compose.animation.slideOutHorizontally\nimport androidx.compose.foundation.Canvas\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.isSystemInDarkTheme\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.Spacer\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.size\nimport androidx.compose.foundation.rememberScrollState\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.foundation.verticalScroll\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.Notifications\nimport androidx.compose.material.icons.filled.Phone\nimport androidx.compose.material3.Button\nimport androidx.compose.material3.ButtonDefaults\nimport androidx.compose.material3.Card\nimport androidx.compose.material3.CardDefaults\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.clip\nimport androidx.compose.ui.draw.scale\nimport androidx.compose.ui.geometry.Offset\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.graphics.drawscope.rotate\nimport androidx.compose.ui.graphics.toArgb\nimport androidx.compose.ui.graphics.vector.ImageVector\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.res.vectorResource\nimport androidx.compose.ui.text.TextStyle\nimport androidx.compose.ui.text.font.Font\nimport androidx.compose.ui.text.font.FontFamily\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.text.style.TextAlign\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport androidx.navigation.compose.NavHost\nimport androidx.navigation.compose.composable\nimport androidx.navigation.compose.rememberNavController\nimport com.google.accompanist.permissions.ExperimentalPermissionsApi\nimport com.google.accompanist.permissions.MultiplePermissionsState\nimport com.google.accompanist.permissions.isGranted\nimport com.google.accompanist.permissions.rememberMultiplePermissionsState\nimport me.kavishdevar.librepods.constants.AirPodsNotifications\nimport me.kavishdevar.librepods.screens.AirPodsSettingsScreen\nimport me.kavishdevar.librepods.screens.AppSettingsScreen\nimport me.kavishdevar.librepods.screens.DebugScreen\nimport me.kavishdevar.librepods.screens.HeadTrackingScreen\nimport me.kavishdevar.librepods.screens.LongPress\nimport me.kavishdevar.librepods.screens.Onboarding\nimport me.kavishdevar.librepods.screens.RenameScreen\nimport me.kavishdevar.librepods.screens.TroubleshootingScreen\nimport me.kavishdevar.librepods.services.AirPodsService\nimport me.kavishdevar.librepods.ui.theme.LibrePodsTheme\nimport me.kavishdevar.librepods.utils.CrossDevice\n// (stock build) RadareOffsetFinder removed\nimport kotlin.io.encoding.Base64\nimport kotlin.io.encoding.ExperimentalEncodingApi\n\nlateinit var serviceConnection: ServiceConnection\nlateinit var connectionStatusReceiver: BroadcastReceiver\n\n@ExperimentalMaterial3Api\nclass MainActivity : ComponentActivity() {\n    companion object {\n        init {\n            // (stock build) no native hook\n        }\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        enableEdgeToEdge()\n\n        setContent {\n            LibrePodsTheme {\n                getSharedPreferences(\"settings\", MODE_PRIVATE).edit().putLong(\"textColor\",\n                    MaterialTheme.colorScheme.onSurface.toArgb().toLong()).apply()\n                Main()\n            }\n        }\n\n        handleIncomingIntent(intent)\n    }\n\n    override fun onDestroy() {\n        try {\n            unbindService(serviceConnection)\n            Log.d(\"MainActivity\", \"Unbound service\")\n        } catch (e: Exception) {\n            Log.e(\"MainActivity\", \"Error while unbinding service: $e\")\n        }\n        try {\n            unregisterReceiver(connectionStatusReceiver)\n            Log.d(\"MainActivity\", \"Unregistered receiver\")\n        } catch (e: Exception) {\n            Log.e(\"MainActivity\", \"Error while unregistering receiver: $e\")\n        }\n        sendBroadcast(Intent(AirPodsNotifications.DISCONNECT_RECEIVERS))\n        super.onDestroy()\n    }\n\n    override fun onStop() {\n        try {\n            unbindService(serviceConnection)\n            Log.d(\"MainActivity\", \"Unbound service\")\n        } catch (e: Exception) {\n            Log.e(\"MainActivity\", \"Error while unbinding service: $e\")\n        }\n        try {\n            unregisterReceiver(connectionStatusReceiver)\n            Log.d(\"MainActivity\", \"Unregistered receiver\")\n        } catch (e: Exception) {\n            Log.e(\"MainActivity\", \"Error while unregistering receiver: $e\")\n        }\n        super.onStop()\n    }\n\n    override fun onNewIntent(intent: Intent) {\n        super.onNewIntent(intent)\n        setIntent(intent)\n        handleIncomingIntent(intent)\n    }\n\n    private fun handleIncomingIntent(intent: Intent) {\n        val data: Uri? = intent.data\n\n        if (data != null && data.scheme == \"librepods\") {\n            when (data.host) {\n                \"add-magic-keys\" -> {\n                    // Extract query parameters\n                    val queryParams = data.queryParameterNames\n                    queryParams.forEach { param ->\n                        val value = data.getQueryParameter(param)\n                        // Handle your parameters here\n                        Log.d(\"LibrePods\", \"Parameter: $param = $value\")\n                    }\n\n                    // Process the magic keys addition\n                    handleAddMagicKeys(data)\n                }\n            }\n        }\n    }\n\n    private fun handleAddMagicKeys(uri: Uri) {\n        val context = this\n        val sharedPreferences = getSharedPreferences(\"settings\", Context.MODE_PRIVATE)\n\n        val irkHex = uri.getQueryParameter(\"irk\")\n        val encKeyHex = uri.getQueryParameter(\"enc_key\")\n\n        try {\n            if (irkHex != null && validateHexInput(irkHex)) {\n                val irkBytes = hexStringToByteArray(irkHex)\n                val irkBase64 = Base64.encode(irkBytes)\n                sharedPreferences.edit().putString(\"IRK\", irkBase64).apply()\n            }\n\n            if (encKeyHex != null && validateHexInput(encKeyHex)) {\n                val encKeyBytes = hexStringToByteArray(encKeyHex)\n                val encKeyBase64 = Base64.encode(encKeyBytes)\n                sharedPreferences.edit().putString(\"ENC_KEY\", encKeyBase64).apply()\n            }\n\n            Toast.makeText(this, \"Magic keys added successfully!\", Toast.LENGTH_SHORT).show()\n        } catch (e: Exception) {\n            Toast.makeText(this, \"Error processing magic keys: ${e.message}\", Toast.LENGTH_LONG).show()\n        }\n    }\n\n    private fun validateHexInput(input: String): Boolean {\n        val hexPattern = Regex(\"^[0-9a-fA-F]{32}$\")\n        return hexPattern.matches(input)\n    }\n\n    private fun hexStringToByteArray(hex: String): ByteArray {\n        val result = ByteArray(16)\n        for (i in 0 until 16) {\n            val hexByte = hex.substring(i * 2, i * 2 + 2)\n            result[i] = hexByte.toInt(16).toByte()\n        }\n        return result\n    }\n}\n\n@SuppressLint(\"MissingPermission\", \"InlinedApi\", \"UnspecifiedRegisterReceiverFlag\")\n@OptIn(ExperimentalPermissionsApi::class)\n@Composable\nfun Main() {\n    val isConnected = remember { mutableStateOf(false) }\n    val isRemotelyConnected = remember { mutableStateOf(false) }\n    val hookAvailable = true // stock build: always proceed without root hook\n    val context = LocalContext.current\n    var canDrawOverlays by remember { mutableStateOf(Settings.canDrawOverlays(context)) }\n    val overlaySkipped = remember { mutableStateOf(context.getSharedPreferences(\"settings\", MODE_PRIVATE).getBoolean(\"overlay_permission_skipped\", false)) }\n\n    val bluetoothPermissions = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {\n        listOf(\n            \"android.permission.BLUETOOTH_CONNECT\",\n            \"android.permission.BLUETOOTH_SCAN\",\n            \"android.permission.BLUETOOTH\",\n            \"android.permission.BLUETOOTH_ADMIN\",\n            \"android.permission.BLUETOOTH_ADVERTISE\"\n        )\n    } else {\n        listOf(\n            \"android.permission.BLUETOOTH\",\n            \"android.permission.BLUETOOTH_ADMIN\",\n            \"android.permission.ACCESS_FINE_LOCATION\"\n        )\n    }\n    val otherPermissions = listOf(\n        \"android.permission.POST_NOTIFICATIONS\",\n        \"android.permission.READ_PHONE_STATE\",\n        \"android.permission.ANSWER_PHONE_CALLS\"\n    )\n    val allPermissions = bluetoothPermissions + otherPermissions\n\n    val permissionState = rememberMultiplePermissionsState(\n        permissions = allPermissions\n    )\n    val airPodsService = remember { mutableStateOf<AirPodsService?>(null) }\n\n    LaunchedEffect(Unit) {\n        canDrawOverlays = Settings.canDrawOverlays(context)\n    }\n\n    if (permissionState.allPermissionsGranted && (canDrawOverlays || overlaySkipped.value)) {\n        val context = LocalContext.current\n        context.startService(Intent(context, AirPodsService::class.java))\n\n        val navController = rememberNavController()\n\n        val sharedPreferences = context.getSharedPreferences(\"settings\", MODE_PRIVATE)\n        val isAvailableChangeListener = SharedPreferences.OnSharedPreferenceChangeListener { _, key ->\n            if (key == \"CrossDeviceIsAvailable\") {\n                Log.d(\"MainActivity\", \"CrossDeviceIsAvailable changed\")\n                isRemotelyConnected.value = sharedPreferences.getBoolean(\"CrossDeviceIsAvailable\", false)\n            }\n        }\n        sharedPreferences.registerOnSharedPreferenceChangeListener(isAvailableChangeListener)\n        Log.d(\"MainActivity\", \"CrossDeviceIsAvailable: ${sharedPreferences.getBoolean(\"CrossDeviceIsAvailable\", false)} | isAvailable: ${CrossDevice.isAvailable}\")\n        isRemotelyConnected.value = sharedPreferences.getBoolean(\"CrossDeviceIsAvailable\", false) || CrossDevice.isAvailable\n        Log.d(\"MainActivity\", \"isRemotelyConnected: ${isRemotelyConnected.value}\")\n        Box (\n            modifier = Modifier\n                .padding(0.dp)\n                .fillMaxSize()\n                .background(if (isSystemInDarkTheme()) Color.Black else Color(0xFFF2F2F7))\n        ) {\n            NavHost(\n                navController = navController,\n                startDestination = if (hookAvailable) \"settings\" else \"onboarding\",\n                enterTransition = {\n                    slideInHorizontally(\n                        initialOffsetX = { it },\n                        animationSpec = tween(durationMillis = 300)\n                    ) + fadeIn(animationSpec = tween(durationMillis = 300))\n                },\n                exitTransition = {\n                    slideOutHorizontally(\n                        targetOffsetX = { -it/4 },\n                        animationSpec = tween(durationMillis = 300)\n                    ) + fadeOut(animationSpec = tween(durationMillis = 150))\n                },\n                popEnterTransition = {\n                    slideInHorizontally(\n                        initialOffsetX = { -it/4 },\n                        animationSpec = tween(durationMillis = 300)\n                    ) + fadeIn(animationSpec = tween(durationMillis = 300))\n                },\n                popExitTransition = {\n                    slideOutHorizontally(\n                        targetOffsetX = { it },\n                        animationSpec = tween(durationMillis = 300)\n                    ) + fadeOut(animationSpec = tween(durationMillis = 150))\n                }\n            ) {\n                composable(\"settings\") {\n                    if (airPodsService.value != null) {\n                        AirPodsSettingsScreen(\n                            dev = airPodsService.value?.device,\n                            service = airPodsService.value!!,\n                            navController = navController,\n                            isConnected = isConnected.value,\n                            isRemotelyConnected = isRemotelyConnected.value\n                        )\n                    }\n                }\n                composable(\"debug\") {\n                    DebugScreen(navController = navController)\n                }\n                composable(\"long_press/{bud}\") { navBackStackEntry ->\n                    LongPress(\n                        navController = navController,\n                        name = navBackStackEntry.arguments?.getString(\"bud\")!!\n                    )\n                }\n                composable(\"rename\") { navBackStackEntry ->\n                    RenameScreen(navController)\n                }\n                composable(\"app_settings\") {\n                    AppSettingsScreen(navController)\n                }\n                composable(\"troubleshooting\") {\n                    TroubleshootingScreen(navController)\n                }\n                composable(\"head_tracking\") {\n                    HeadTrackingScreen(navController)\n                }\n                composable(\"onboarding\") {\n                    Onboarding(navController, context)\n                }\n            }\n        }\n\n         serviceConnection = remember {\n            object : ServiceConnection {\n                override fun onServiceConnected(name: ComponentName?, service: IBinder?) {\n                    val binder = service as AirPodsService.LocalBinder\n                    airPodsService.value = binder.getService()\n                }\n\n                override fun onServiceDisconnected(name: ComponentName?) {\n                    airPodsService.value = null\n                }\n            }\n        }\n\n        context.bindService(Intent(context, AirPodsService::class.java), serviceConnection, Context.BIND_AUTO_CREATE)\n\n        if (airPodsService.value?.isConnectedLocally == true) {\n            isConnected.value = true\n        }\n    } else {\n        PermissionsScreen(\n            permissionState = permissionState,\n            canDrawOverlays = canDrawOverlays,\n            onOverlaySettingsReturn = { canDrawOverlays = Settings.canDrawOverlays(context) }\n        )\n    }\n}\n\n@OptIn(ExperimentalPermissionsApi::class, ExperimentalMaterial3Api::class)\n@Composable\nfun PermissionsScreen(\n    permissionState: MultiplePermissionsState,\n    canDrawOverlays: Boolean,\n    onOverlaySettingsReturn: () -> Unit\n) {\n    val context = LocalContext.current\n    val isDarkTheme = isSystemInDarkTheme()\n    val backgroundColor = if (isDarkTheme) Color(0xFF1C1C1E) else Color.White\n    val textColor = if (isDarkTheme) Color.White else Color.Black\n    val accentColor = if (isDarkTheme) Color(0xFF007AFF) else Color(0xFF3C6DF5)\n\n    val scrollState = rememberScrollState()\n\n    val basicPermissionsGranted = permissionState.permissions.all { it.status.isGranted }\n\n    val infiniteTransition = rememberInfiniteTransition(label = \"pulse\")\n    val pulseScale by infiniteTransition.animateFloat(\n        initialValue = 1f,\n        targetValue = 1.05f,\n        animationSpec = infiniteRepeatable(\n            animation = tween(1000),\n            repeatMode = RepeatMode.Reverse\n        ),\n        label = \"pulse scale\"\n    )\n\n    Column(\n        modifier = Modifier\n            .fillMaxSize()\n            .background(if (isDarkTheme) Color.Black else Color(0xFFF2F2F7))\n            .padding(16.dp)\n            .verticalScroll(scrollState),\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        Box(\n            modifier = Modifier\n                .fillMaxWidth()\n                .height(180.dp),\n            contentAlignment = Alignment.Center\n        ) {\n            Text(\n                text = \"\\uDBC2\\uDEB7\",\n                style = TextStyle(\n                    fontSize = 48.sp,\n                    fontWeight = FontWeight.Bold,\n                    fontFamily = FontFamily(Font(R.font.sf_pro)),\n                    color = textColor,\n                    textAlign = TextAlign.Center\n                )\n            )\n            Canvas(\n                modifier = Modifier\n                    .size(120.dp)\n                    .scale(pulseScale)\n            ) {\n                val radius = size.minDimension / 2.2f\n                val centerX = size.width / 2\n                val centerY = size.height / 2\n\n                rotate(degrees = 45f) {\n                    drawCircle(\n                        color = accentColor.copy(alpha = 0.1f),\n                        radius = radius * 1.3f,\n                        center = Offset(centerX, centerY)\n                    )\n\n                    drawCircle(\n                        color = accentColor.copy(alpha = 0.2f),\n                        radius = radius * 1.1f,\n                        center = Offset(centerX, centerY)\n                    )\n                }\n            }\n        }\n\n        Spacer(modifier = Modifier.height(16.dp))\n\n        Text(\n            text = \"Permission Required\",\n            style = TextStyle(\n                fontSize = 24.sp,\n                fontWeight = FontWeight.Bold,\n                fontFamily = FontFamily(Font(R.font.sf_pro)),\n                color = textColor,\n                textAlign = TextAlign.Center\n            ),\n            modifier = Modifier.fillMaxWidth()\n        )\n\n        Spacer(modifier = Modifier.height(8.dp))\n\n        Text(\n            text = \"The following permissions are required to use the app. Please grant them to continue.\",\n            style = TextStyle(\n                fontSize = 16.sp,\n                fontWeight = FontWeight.Normal,\n                fontFamily = FontFamily(Font(R.font.sf_pro)),\n                color = textColor.copy(alpha = 0.7f),\n                textAlign = TextAlign.Center\n            ),\n            modifier = Modifier.fillMaxWidth()\n        )\n\n        Spacer(modifier = Modifier.height(32.dp))\n\n        PermissionCard(\n            title = \"Bluetooth Permissions\",\n            description = \"Required to communicate with your AirPods\",\n            icon = ImageVector.vectorResource(id = R.drawable.ic_bluetooth),\n            isGranted = permissionState.permissions.filter {\n                it.permission.contains(\"BLUETOOTH\")\n            }.all { it.status.isGranted },\n            backgroundColor = backgroundColor,\n            textColor = textColor,\n            accentColor = accentColor\n        )\n\n        PermissionCard(\n            title = \"Notification Permission\",\n            description = \"To show battery status\",\n            icon = Icons.Default.Notifications,\n            isGranted = permissionState.permissions.find {\n                it.permission == \"android.permission.POST_NOTIFICATIONS\"\n            }?.status?.isGranted == true,\n            backgroundColor = backgroundColor,\n            textColor = textColor,\n            accentColor = accentColor\n        )\n\n        PermissionCard(\n            title = \"Phone Permissions\",\n            description = \"For answering calls with Head Gestures\",\n            icon = Icons.Default.Phone,\n            isGranted = permissionState.permissions.filter {\n                it.permission.contains(\"PHONE\") || it.permission.contains(\"CALLS\")\n            }.all { it.status.isGranted },\n            backgroundColor = backgroundColor,\n            textColor = textColor,\n            accentColor = accentColor\n        )\n\n        PermissionCard(\n            title = \"Display Over Other Apps\",\n            description = \"For popup animations when AirPods connect\",\n            icon = ImageVector.vectorResource(id = R.drawable.ic_layers),\n            isGranted = canDrawOverlays,\n            backgroundColor = backgroundColor,\n            textColor = textColor,\n            accentColor = accentColor\n        )\n\n        Spacer(modifier = Modifier.height(24.dp))\n\n        Button(\n            onClick = { permissionState.launchMultiplePermissionRequest() },\n            modifier = Modifier\n                .fillMaxWidth()\n                .height(55.dp),\n            colors = ButtonDefaults.buttonColors(\n                containerColor = accentColor\n            ),\n            shape = RoundedCornerShape(8.dp)\n        ) {\n            Text(\n                \"Ask for regular permissions\",\n                style = TextStyle(\n                    fontSize = 16.sp,\n                    fontWeight = FontWeight.Medium,\n                    fontFamily = FontFamily(Font(R.font.sf_pro)),\n                    color = Color.White\n                ),\n            )\n        }\n\n        Spacer(modifier = Modifier.height(12.dp))\n\n        Button(\n            onClick = {\n                val intent = Intent(\n                    Settings.ACTION_MANAGE_OVERLAY_PERMISSION,\n                    Uri.parse(\"package:${context.packageName}\")\n                )\n                context.startActivity(intent)\n                onOverlaySettingsReturn()\n            },\n            modifier = Modifier\n                .fillMaxWidth()\n                .height(55.dp),\n            colors = ButtonDefaults.buttonColors(\n                containerColor = if (canDrawOverlays) Color.Gray else accentColor\n            ),\n            enabled = !canDrawOverlays,\n            shape = RoundedCornerShape(8.dp)\n        ) {\n            Text(\n                if (canDrawOverlays) \"Overlay Permission Granted\" else \"Grant Overlay Permission\",\n                style = TextStyle(\n                    fontSize = 16.sp,\n                    fontWeight = FontWeight.Medium,\n                    fontFamily = FontFamily(Font(R.font.sf_pro)),\n                    color = Color.White\n                ),\n            )\n        }\n\n        if (!canDrawOverlays && basicPermissionsGranted) {\n            Spacer(modifier = Modifier.height(12.dp))\n\n            Button(\n                onClick = {\n                    val editor = context.getSharedPreferences(\"settings\", MODE_PRIVATE).edit()\n                    editor.putBoolean(\"overlay_permission_skipped\", true)\n                    editor.apply()\n\n                    val intent = Intent(context, MainActivity::class.java)\n                    intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)\n                    context.startActivity(intent)\n                },\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .height(55.dp),\n                colors = ButtonDefaults.buttonColors(\n                    containerColor = Color(0xFF757575)\n                ),\n                shape = RoundedCornerShape(8.dp)\n            ) {\n                Text(\n                    \"Continue without overlay\",\n                    style = TextStyle(\n                        fontSize = 16.sp,\n                        fontWeight = FontWeight.Medium,\n                        fontFamily = FontFamily(Font(R.font.sf_pro)),\n                        color = Color.White\n                    ),\n                )\n            }\n        }\n    }\n}\n\n@Composable\nfun PermissionCard(\n    title: String,\n    description: String,\n    icon: ImageVector,\n    isGranted: Boolean,\n    backgroundColor: Color,\n    textColor: Color,\n    accentColor: Color\n) {\n    Card(\n        modifier = Modifier\n            .fillMaxWidth()\n            .padding(vertical = 6.dp),\n        colors = CardDefaults.cardColors(\n            containerColor = backgroundColor\n        ),\n        shape = RoundedCornerShape(12.dp)\n    ) {\n        Row(\n            modifier = Modifier\n                .fillMaxWidth()\n                .padding(16.dp),\n            verticalAlignment = Alignment.CenterVertically\n        ) {\n            Box(\n                modifier = Modifier\n                    .size(40.dp)\n                    .clip(RoundedCornerShape(8.dp))\n                    .background(if (isGranted) accentColor.copy(alpha = 0.15f) else Color.Gray.copy(alpha = 0.15f)),\n                contentAlignment = Alignment.Center\n            ) {\n                Icon(\n                    imageVector = icon,\n                    contentDescription = title,\n                    tint = if (isGranted) accentColor else Color.Gray,\n                    modifier = Modifier.size(24.dp)\n                )\n            }\n\n            Column(\n                modifier = Modifier\n                    .weight(1f)\n                    .padding(start = 16.dp)\n            ) {\n                Text(\n                    text = title,\n                    style = TextStyle(\n                        fontSize = 16.sp,\n                        fontWeight = FontWeight.Medium,\n                        fontFamily = FontFamily(Font(R.font.sf_pro)),\n                        color = textColor\n                    )\n                )\n\n                Text(\n                    text = description,\n                    style = TextStyle(\n                        fontSize = 14.sp,\n                        fontWeight = FontWeight.Normal,\n                        fontFamily = FontFamily(Font(R.font.sf_pro)),\n                        color = textColor.copy(alpha = 0.6f)\n                    )\n                )\n            }\n\n            Box(\n                modifier = Modifier\n                    .size(24.dp)\n                    .clip(RoundedCornerShape(12.dp))\n                    .background(if (isGranted) Color(0xFF4CAF50) else Color.Gray),\n                contentAlignment = Alignment.Center\n            ) {\n                Text(\n                    text = if (isGranted) \"\u2713\" else \"!\",\n                    style = TextStyle(\n                        fontSize = 14.sp,\n                        fontWeight = FontWeight.Bold,\n                        color = Color.White\n                    )\n                )\n            }\n        }\n    }\n}"
        },
        {
          "name": "QuickSettingsDialogActivity.kt",
          "ext": ".kt",
          "size": 26737,
          "preview": "@file:OptIn(ExperimentalEncodingApi::class)\n\npackage me.kavishdevar.librepods\n\nimport android.annotation.SuppressLint\nimport android.content.BroadcastReceiver\nimport android.content.ComponentName\nimport android.content.Context\nimport android.content.Intent\nimport android.content.IntentFilter\nimport android.content.ServiceConnection\nimport android.media.AudioManager\nimport android.os.Build\nimport android.os.Bundle\nimport android.os.IBinder\nimport android.util.Log\nimport android.view.Gravity\nimport android.view.WindowManager\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.compose.animation.Crossfade\nimport androidx.compose.animation.animateContentSize\nimport androidx.compose.animation.core.Animatable\nimport androidx.compose.animation.core.FastOutSlowInEasing\nimport androidx.compose.animation.core.Spring\nimport androidx.compose.animation.core.animateFloatAsState\nimport androidx.compose.animation.core.spring\nimport androidx.compose.animation.core.tween\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.clickable\nimport androidx.compose.foundation.gestures.detectVerticalDragGestures\nimport androidx.compose.foundation.interaction.MutableInteractionSource\nimport androidx.compose.foundation.layout.Arrangement\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.Spacer\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.size\nimport androidx.compose.foundation.layout.width\nimport androidx.compose.foundation.shape.CircleShape\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.DisposableEffect\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableFloatStateOf\nimport androidx.compose.runtime.mutableIntStateOf\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.rememberCoroutineScope\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.clip\nimport androidx.compose.ui.graphics.Brush\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.graphics.graphicsLayer\nimport androidx.compose.ui.input.pointer.pointerInput\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.res.painterResource\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport kotlinx.coroutines.launch\nimport me.kavishdevar.librepods.composables.AdaptiveRainbowBrush\nimport me.kavishdevar.librepods.composables.ControlCenterNoiseControlSegmentedButton\nimport me.kavishdevar.librepods.composables.IconAreaSize\nimport me.kavishdevar.librepods.composables.VerticalVolumeSlider\nimport me.kavishdevar.librepods.constants.AirPodsNotifications\nimport me.kavishdevar.librepods.constants.NoiseControlMode\nimport me.kavishdevar.librepods.services.AirPodsService\nimport me.kavishdevar.librepods.ui.theme.LibrePodsTheme\nimport me.kavishdevar.librepods.utils.AACPManager\nimport kotlin.io.encoding.ExperimentalEncodingApi\nimport kotlin.math.abs\n\nclass QuickSettingsDialogActivity : ComponentActivity() {\n\n    private var airPodsService: AirPodsService? = null\n    private var isBound = false\n\n    private var isNoiseControlExpandedState by mutableStateOf(false)\n\n    private val connection = object : ServiceConnection {\n        override fun onServiceConnected(className: ComponentName, service: IBinder) {\n            val binder = service as AirPodsService.LocalBinder\n            airPodsService = binder.getService()\n            isBound = true\n            Log.d(\"QSActivity\", \"Service bound\")\n            setContent {\n                LibrePodsTheme {\n                    DraggableDismissBox(\n                        onDismiss = { finish() },\n                        onlyCollapseWhenClicked = {\n                            if (isNoiseControlExpandedState) {\n                                isNoiseControlExpandedState = false\n                                true\n                            } else {\n                                false\n                            }\n                        }\n                    ) {\n                        if (isBound && airPodsService != null) {\n                            NewControlCenterDialogContent(\n                                service = airPodsService,\n                                isNoiseControlExpanded = isNoiseControlExpandedState,\n                                onNoiseControlExpandedChange = { isNoiseControlExpandedState = it }\n                            )\n                        }\n                    }\n                }\n            }\n        }\n\n        override fun onServiceDisconnected(arg0: ComponentName) {\n            isBound = false\n            airPodsService = null\n            Log.d(\"QSActivity\", \"Service unbound\")\n            finish()\n        }\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        window.addFlags(WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL)\n        window.addFlags(WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH)\n        window.addFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND)\n        window.setGravity(Gravity.BOTTOM)\n\n        Intent(this, AirPodsService::class.java).also { intent ->\n            bindService(intent, connection, Context.BIND_AUTO_CREATE)\n        }\n\n        setContent {\n            LibrePodsTheme {\n                DraggableDismissBox(\n                    onDismiss = { finish() },\n                    onlyCollapseWhenClicked = {\n                        if (isNoiseControlExpandedState) {\n                            isNoiseControlExpandedState = false\n                            true\n                        } else {\n                            false\n                        }\n                    }\n                ) {\n                    if (isBound && airPodsService != null) {\n                        NewControlCenterDialogContent(\n                            service = airPodsService,\n                            isNoiseControlExpanded = isNoiseControlExpandedState,\n                            onNoiseControlExpandedChange = { isNoiseControlExpandedState = it }\n                        )\n                    }\n                }\n            }\n        }\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        if (isBound) {\n            unbindService(connection)\n            isBound = false\n        }\n    }\n}\n\n@Composable\nfun DraggableDismissBox(\n    onDismiss: () -> Unit,\n    onlyCollapseWhenClicked: () -> Boolean,\n    content: @Composable () -> Unit\n) {\n    val coroutineScope = rememberCoroutineScope()\n\n    var dragOffset by remember { mutableFloatStateOf(0f) }\n    var isDragging by remember { mutableStateOf(false) }\n    val dismissThreshold = 400f\n\n    val animatedOffset = remember { Animatable(0f) }\n    val animatedScale = remember { Animatable(1f) }\n    val animatedAlpha = remember { Animatable(1f) }\n\n    val backgroundAlpha by animateFloatAsState(\n        targetValue = if (isDragging) {\n            val dragProgress = (abs(dragOffset) / 800f).coerceIn(0f, 0.8f)\n            1f - dragProgress\n        } else 1f,\n        label = \"BackgroundFade\"\n    )\n\n    LaunchedEffect(isDragging) {\n        if (!isDragging) {\n            if (abs(dragOffset) < dismissThreshold) {\n                val springSpec = spring(\n                    dampingRatio = Spring.DampingRatioLowBouncy,\n                    stiffness = Spring.StiffnessHigh,\n                    visibilityThreshold = 0.1f\n                )\n                launch { animatedOffset.animateTo(0f, springSpec) }\n                launch { animatedScale.animateTo(1f, springSpec) }\n                launch { animatedAlpha.animateTo(1f, tween(100)) }\n                dragOffset = 0f\n            }\n        }\n    }\n\n    LaunchedEffect(dragOffset, isDragging) {\n        if (isDragging) {\n            val dragProgress = (abs(dragOffset) / 1000f).coerceIn(0f, 0.5f)\n\n            animatedOffset.snapTo(dragOffset)\n            animatedScale.snapTo(1f - dragProgress * 0.3f)\n            animatedAlpha.snapTo(1f - dragProgress * 0.7f)\n        }\n    }\n\n    Box(\n        modifier = Modifier\n            .fillMaxSize()\n            .background(Color.Black.copy(alpha = 0.5f * backgroundAlpha))\n            .pointerInput(Unit) {\n                detectVerticalDragGestures(\n                    onDragStart = { isDragging = true },\n                    onDragEnd = {\n                        isDragging = false\n                        if (abs(dragOffset) > dismissThreshold) {\n                            coroutineScope.launch {\n                                val direction = if (dragOffset > 0) 1f else -1f\n\n                                launch {\n                                    animatedOffset.animateTo(\n                                        direction * 1500f,\n                                        tween(350, easing = FastOutSlowInEasing)\n                                    )\n                                }\n                                launch { animatedScale.animateTo(0.7f, tween(350)) }\n                                launch { animatedAlpha.animateTo(0f, tween(250)) }\n\n                                kotlinx.coroutines.delay(350)\n                                onDismiss()\n                            }\n                        }\n                    },\n                    onDragCancel = { isDragging = false },\n                    onVerticalDrag = { change, dragAmount ->\n                        change.consume()\n                        dragOffset += dragAmount\n                    }\n                )\n            }\n            .clickable(\n                interactionSource = remember { MutableInteractionSource() },\n                indication = null\n            ) {\n                onlyCollapseWhenClicked()\n            },\n        contentAlignment = Alignment.BottomCenter\n    ) {\n        Box(\n            modifier = Modifier\n                .fillMaxWidth()\n                .graphicsLayer(\n                    translationY = animatedOffset.value,\n                    scaleX = animatedScale.value,\n                    scaleY = animatedScale.value,\n                    alpha = animatedAlpha.value\n                ),\n            contentAlignment = Alignment.BottomCenter\n        ) {\n            content()\n        }\n    }\n}\n\n@SuppressLint(\"UnspecifiedRegisterReceiverFlag\")\n@Composable\nfun NewControlCenterDialogContent(\n    service: AirPodsService?,\n    isNoiseControlExpanded: Boolean,\n    onNoiseControlExpandedChange: (Boolean) -> Unit\n) {\n    val context = LocalContext.current\n    val sharedPreferences = context.getSharedPreferences(\"settings\", Context.MODE_PRIVATE)\n    val textColor = Color.White\n\n    var currentAncMode by remember { mutableStateOf(NoiseControlMode.TRANSPARENCY) }\n    var isConvAwarenessEnabled by remember { mutableStateOf(false) }\n\n    val isOffModeEnabled = remember { sharedPreferences.getBoolean(\"off_listening_mode\", true) }\n    val availableModes = remember(isOffModeEnabled) {\n        mutableListOf(\n            NoiseControlMode.TRANSPARENCY,\n            NoiseControlMode.ADAPTIVE,\n            NoiseControlMode.NOISE_CANCELLATION\n        ).apply {\n            if (isOffModeEnabled) {\n                add(0, NoiseControlMode.OFF)\n            }\n        }\n    }\n\n    val audioManager = context.getSystemService(Context.AUDIO_SERVICE) as AudioManager\n    val maxVolume = remember { audioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC) }\n    var currentVolumeInt by remember { mutableIntStateOf(audioManager.getStreamVolume(AudioManager.STREAM_MUSIC)) }\n    val animatedVolumeFraction by animateFloatAsState(\n        targetValue = currentVolumeInt.toFloat() / maxVolume.toFloat(),\n        animationSpec = spring(\n            dampingRatio = Spring.DampingRatioLowBouncy,\n            stiffness = Spring.StiffnessMediumLow\n        ),\n        label = \"VolumeAnimation\"\n    )\n    var liveDragFraction by remember { mutableFloatStateOf(animatedVolumeFraction) }\n    var isDraggingVolume by remember { mutableStateOf(false) }\n    LaunchedEffect(animatedVolumeFraction, isDraggingVolume) {\n        if (!isDraggingVolume) {\n            liveDragFraction = animatedVolumeFraction\n        }\n    }\n\n    DisposableEffect(service, availableModes) {\n        val ancReceiver = object : BroadcastReceiver() {\n            override fun onReceive(context: Context, intent: Intent) {\n                if (intent.action == AirPodsNotifications.ANC_DATA && service != null) {\n                    val newModeOrdinal = intent.getIntExtra(\"data\", NoiseControlMode.TRANSPARENCY.ordinal + 1) - 1\n                    val newMode = NoiseControlMode.entries.getOrElse(newModeOrdinal) { NoiseControlMode.TRANSPARENCY }\n                    if (availableModes.contains(newMode)) {\n                         currentAncMode = newMode\n                    } else if (newMode == NoiseControlMode.OFF && !isOffModeEnabled) {\n                        currentAncMode = NoiseControlMode.TRANSPARENCY\n                    }\n                    Log.d(\"QSActivity\", \"ANC Receiver updated mode to: $currentAncMode (available: ${availableModes.joinToString()})\")\n                }\n            }\n        }\n        val filter = IntentFilter(AirPodsNotifications.ANC_DATA)\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\n            context.registerReceiver(ancReceiver, filter, Context.RECEIVER_EXPORTED)\n        } else {\n            context.registerReceiver(ancReceiver, filter)\n        }\n\n        service?.let {\n            val initialModeOrdinal = it.getANC().minus(1)\n            var initialMode = NoiseControlMode.entries.getOrElse(initialModeOrdinal) { NoiseControlMode.TRANSPARENCY }\n            if (!availableModes.contains(initialMode)) {\n                initialMode = NoiseControlMode.TRANSPARENCY\n            }\n            currentAncMode = initialMode\n            isConvAwarenessEnabled = sharedPreferences.getBoolean(\"conversational_awareness\", true)\n            Log.d(\"QSActivity\", \"Initial ANC: $currentAncMode, ConvAware: $isConvAwarenessEnabled\")\n        }\n\n        onDispose {\n            context.unregisterReceiver(ancReceiver)\n        }\n    }\n\n    DisposableEffect(Unit) {\n        val volumeReceiver = object : BroadcastReceiver() {\n            override fun onReceive(context: Context, intent: Intent) {\n                if (intent.action == \"android.media.VOLUME_CHANGED_ACTION\") {\n                    val newVolume = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC)\n                    if (newVolume != currentVolumeInt) {\n                        currentVolumeInt = newVolume\n                        Log.d(\"QSActivity\", \"Volume Receiver updated volume to: $currentVolumeInt\")\n                    }\n                }\n            }\n        }\n        val filter = IntentFilter(\"android.media.VOLUME_CHANGED_ACTION\")\n        context.registerReceiver(volumeReceiver, filter)\n        onDispose {\n            context.unregisterReceiver(volumeReceiver)\n        }\n    }\n\n    val deviceName = remember { sharedPreferences.getString(\"name\", \"AirPods\") ?: \"AirPods\" }\n\n    Column(\n        modifier = Modifier\n            .fillMaxSize()\n            .background(Color.Transparent)\n            .padding(horizontal = 24.dp)\n            .pointerInput(Unit) {\n                awaitPointerEventScope {\n                    while (true) {\n                        awaitPointerEvent()\n                    }\n                }\n            },\n        horizontalAlignment = Alignment.CenterHorizontally,\n        verticalArrangement = Arrangement.SpaceBetween\n    ) {\n        if (service != null) {\n            Spacer(modifier = Modifier.weight(1f))\n\n            Column(\n                modifier = Modifier\n                    .weight(2f)\n                    .fillMaxWidth(),\n                horizontalAlignment = Alignment.CenterHorizontally,\n                verticalArrangement = Arrangement.Center\n            ) {\n                Icon(\n                    painter = painterResource(id = R.drawable.airpods),\n                    contentDescription = \"Device Icon\",\n                    tint = textColor.copy(alpha = 0.8f),\n                    modifier = Modifier.size(48.dp)\n                )\n\n                Spacer(modifier = Modifier.height(4.dp))\n\n                Text(\n                    text = deviceName,\n                    color = textColor,\n                    fontSize = 16.sp,\n                    fontWeight = FontWeight.Medium\n                )\n\n                Spacer(modifier = Modifier.height(32.dp))\n\n                VerticalVolumeSlider(\n                    displayFraction = animatedVolumeFraction,\n                    maxVolume = maxVolume,\n                    onVolumeChange = { newVolume ->\n                        currentVolumeInt = newVolume\n                        try {\n                            audioManager.setStreamVolume(AudioManager.STREAM_MUSIC, newVolume, 0)\n                        } catch (e: Exception) { Log.e(\"QSActivity\", \"Failed to set volume\", e) }\n                    },\n                    initialFraction = animatedVolumeFraction,\n                    onDragStateChange = { dragging -> isDraggingVolume = dragging },\n                    baseSliderHeight = 400.dp,\n                    baseSliderWidth = 145.dp,\n                    baseCornerRadius = 48.dp,\n                    maxStretchFactor = 1.15f,\n                    minCompressionFactor = 0.875f,\n                    stretchSensitivity = 0.3f,\n                    compressionSensitivity = 0.3f,\n                    cornerRadiusChangeFactor = -0.5f,\n                    directionalStretchRatio = 0.75f,\n                    modifier = Modifier\n                        .width(145.dp)\n                        .padding(vertical = 8.dp)\n                )\n            }\n\n            Spacer(modifier = Modifier.weight(1f))\n\n            Box(\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .padding(bottom = 72.dp)\n                    .animateContentSize(\n                        animationSpec = spring(\n                            dampingRatio = Spring.DampingRatioMediumBouncy,\n                            stiffness = Spring.StiffnessMedium\n                        )\n                    ),\n                contentAlignment = Alignment.Center\n            ) {\n                Crossfade(\n                    targetState = isNoiseControlExpanded,\n                    animationSpec = tween(durationMillis = 300),\n                    label = \"NoiseControlCrossfade\"\n                ) { expanded ->\n                    if (expanded) {\n                        ControlCenterNoiseControlSegmentedButton(\n                            availableModes = availableModes,\n                            selectedMode = currentAncMode,\n                            onModeSelected = { newMode ->\n                                service.aacpManager.sendControlCommand(\n                                    identifier = AACPManager.Companion.ControlCommandIdentifiers.LISTENING_MODE.value,\n                                    value = newMode.ordinal + 1\n                                )\n                                currentAncMode = newMode\n                            },\n                            modifier = Modifier.fillMaxWidth(0.8f)\n                        )\n                    } else {\n                        Row(\n                            modifier = Modifier.fillMaxWidth(0.85f),\n                            horizontalArrangement = Arrangement.SpaceBetween,\n                            verticalAlignment = Alignment.Top\n                        ) {\n                            val noiseControlButtonBrush = if (currentAncMode == NoiseControlMode.ADAPTIVE) {\n                                AdaptiveRainbowBrush\n                            } else {\n                                null\n                            }\n\n                            Column(\n                                horizontalAlignment = Alignment.CenterHorizontally,\n                                verticalArrangement = Arrangement.Center,\n                                modifier = Modifier.weight(1f)\n                            ) {\n                                Box(\n                                    modifier = Modifier\n                                        .size(IconAreaSize)\n                                        .clip(CircleShape)\n                                        .background(\n                                            brush = noiseControlButtonBrush ?:\n                                                Brush.linearGradient(colors = listOf(Color(0xFF0A84FF), Color(0xFF0A84FF)))\n                                        )\n                                        .clickable(\n                                            onClick = { onNoiseControlExpandedChange(true) },\n                                            indication = null,\n                                            interactionSource = remember { MutableInteractionSource() }\n                                        ),\n                                    contentAlignment = Alignment.Center\n                                ) {\n                                    Icon(\n                                        painter = painterResource(id = getModeIconRes(currentAncMode)),\n                                        contentDescription = getModeLabel(currentAncMode),\n                                        tint = Color.White,\n                                        modifier = Modifier.size(32.dp)\n                                    )\n                                }\n\n                                Spacer(modifier = Modifier.height(8.dp))\n\n                                Text(\n                                    text = getModeLabel(currentAncMode),\n                                    color = Color.White,\n                                    fontSize = 12.sp,\n                                    fontWeight = FontWeight.Medium,\n                                    textAlign = androidx.compose.ui.text.style.TextAlign.Center\n                                )\n                            }\n\n                            Spacer(modifier = Modifier.width(24.dp))\n\n                            Column(\n                                horizontalAlignment = Alignment.CenterHorizontally,\n                                verticalArrangement = Arrangement.Center,\n                                modifier = Modifier.weight(1f)\n                            ) {\n                                Box(\n                                    modifier = Modifier\n                                        .size(IconAreaSize)\n                                        .clip(CircleShape)\n                                        .background(\n                                            Brush.linearGradient(\n                                                colors = listOf(\n                                                    if (isConvAwarenessEnabled) Color(0xFF0A84FF) else Color(0x593C3C3E),\n                                                    if (isConvAwarenessEnabled) Color(0xFF0A84FF) else Color(0x593C3C3E)\n                                                )\n                                            )\n                                        )\n                                        .clickable(\n                                            onClick = {\n                                                val newState = !isConvAwarenessEnabled\n                                                service.aacpManager.sendControlCommand(\n                                                    identifier = AACPManager.Companion.ControlCommandIdentifiers.CONVERSATION_DETECT_CONFIG.value,\n                                                    value = newState\n                                                )\n                                                isConvAwarenessEnabled = newState\n                                            },\n                                            indication = null,\n                                            interactionSource = remember { MutableInteractionSource() }\n                                        ),\n                                    contentAlignment = Alignment.Center\n                                ) {\n                                    Icon(\n                                        painter = painterResource(id = R.drawable.airpods),\n                                        contentDescription = \"Conversational Awareness\",\n                                        tint = Color.White,\n                                        modifier = Modifier.size(32.dp)\n                                    )\n                                }\n\n                                Spacer(modifier = Modifier.height(8.dp))\n\n                                Text(\n                                    text = \"Conversational\\nAwareness\",\n                                    color = Color.White,\n                                    fontSize = 12.sp,\n                                    fontWeight = FontWeight.Medium,\n                                    textAlign = androidx.compose.ui.text.style.TextAlign.Center,\n                                    lineHeight = 14.sp\n                                )\n                            }\n                        }\n                    }\n                }\n            }\n\n        } else {\n            Spacer(modifier = Modifier.weight(1f))\n            Box(modifier = Modifier.fillMaxWidth(), contentAlignment = Alignment.Center) {\n                Text(\"Loading...\", color = textColor)\n            }\n            Spacer(modifier = Modifier.weight(1f))\n        }\n    }\n}\n\nprivate fun getModeIconRes(mode: NoiseControlMode): Int {\n    return when (mode) {\n        NoiseControlMode.OFF -> R.drawable.noise_cancellation\n        NoiseControlMode.TRANSPARENCY -> R.drawable.transparency\n        NoiseControlMode.ADAPTIVE -> R.drawable.adaptive\n        NoiseControlMode.NOISE_CANCELLATION -> R.drawable.noise_cancellation\n    }\n}\n\nprivate fun getModeLabel(mode: NoiseControlMode): String {\n    return when (mode) {\n        NoiseControlMode.OFF -> \"Off\"\n        NoiseControlMode.TRANSPARENCY -> \"Transparency\"\n        NoiseControlMode.ADAPTIVE -> \"Adaptive\"\n        NoiseControlMode.NOISE_CANCELLATION -> \"Noise Cancel\"\n    }\n}\n"
        },
        {
          "name": "CustomDeviceActivity.kt",
          "ext": ".kt",
          "size": 8263,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n * \n * Copyright (C) 2025 LibrePods contributors\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n * \n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\npackage me.kavishdevar.librepods\n\nimport android.Manifest\nimport android.annotation.SuppressLint\nimport android.bluetooth.BluetoothDevice\nimport android.bluetooth.BluetoothDevice.TRANSPORT_LE\nimport android.bluetooth.BluetoothGatt\nimport android.bluetooth.BluetoothGattCallback\nimport android.bluetooth.BluetoothGattCharacteristic\nimport android.bluetooth.BluetoothManager\nimport android.os.Build\nimport android.os.Bundle\nimport android.util.Log\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.activity.enableEdgeToEdge\nimport androidx.annotation.RequiresPermission\nimport androidx.compose.foundation.layout.Arrangement\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material3.Button\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.unit.dp\nimport me.kavishdevar.librepods.ui.theme.LibrePodsTheme\nimport org.lsposed.hiddenapibypass.HiddenApiBypass\nimport java.util.UUID\n\nclass CustomDevice : ComponentActivity() {\n    @SuppressLint(\"MissingPermission\", \"CoroutineCreationDuringComposition\")\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        enableEdgeToEdge()\n        setContent {\n            LibrePodsTheme {\n                val connect = remember { mutableStateOf(false) }\n                Scaffold(\n                    modifier = Modifier.fillMaxSize(),\n                    topBar = {\n                        Column(\n                            modifier = Modifier.fillMaxWidth(),\n                            verticalArrangement = Arrangement.Center,\n                            horizontalAlignment = Alignment.CenterHorizontally\n                        ) {\n                            Text(\"Custom Device\", style = MaterialTheme.typography.titleLarge)\n                        }\n                    }\n                ) { innerPadding ->\n                    HiddenApiBypass.addHiddenApiExemptions(\"Landroid/bluetooth/BluetoothSocket;\")\n                    val manager = getSystemService(BLUETOOTH_SERVICE) as BluetoothManager\n//                    val device: BluetoothDevice = manager.adapter.getRemoteDevice(\"EC:D6:F4:3D:89:B8\")\n                    val device: BluetoothDevice = manager.adapter.getRemoteDevice(\"E7:48:92:3B:7D:A5\")\n//                    val socket = device.createInsecureL2capChannel(31)\n\n//                    val batteryLevel = remember { mutableStateOf(\"\") }\n//                    socket.outputStream.write(byteArrayOf(0x12,0x3B,0x00,0x02, 0x00))\n//                    socket.outputStream.write(byteArrayOf(0x12, 0x3A, 0x00, 0x01, 0x00, 0x08,0x01))\n\n                    val gatt = device.connectGatt(this, true, object: BluetoothGattCallback() {\n                        override fun onServicesDiscovered(gatt: BluetoothGatt, status: Int) {\n                            if (status == BluetoothGatt.GATT_SUCCESS) {\n                                // Step 2: Iterate through the services and characteristics\n                                gatt.services.forEach { service ->\n                                    Log.d(\"GATT\", \"Service UUID: ${service.uuid}\")\n                                    service.characteristics.forEach { characteristic ->\n                                        characteristic.descriptors.forEach { descriptor ->\n                                            Log.d(\"GATT\", \"         Descriptor UUID: ${descriptor.uuid}: ${gatt.readDescriptor(descriptor)}\")\n                                        }\n                                    }\n                                }\n\n                            }\n                        }\n\n                        override fun onConnectionStateChange(gatt: BluetoothGatt, status: Int, newState: Int) {\n                            if (newState == BluetoothGatt.STATE_CONNECTED) {\n                                Log.d(\"GATT\", \"Connected to GATT server\")\n                                gatt.discoverServices() // Discover services after connection\n                            }\n                        }\n\n                        override fun onCharacteristicWrite(\n                            gatt: BluetoothGatt,\n                            characteristic: BluetoothGattCharacteristic,\n                            status: Int\n                        ) {\n                            if (status == BluetoothGatt.GATT_SUCCESS) {\n                                Log.d(\"BLE\", \"Write successful for UUID: ${characteristic.uuid}\")\n                            } else {\n                                Log.e(\"BLE\", \"Write failed for UUID: ${characteristic.uuid}, status: $status\")\n                            }\n                        }\n                    }, TRANSPORT_LE, 1)\n\n                    if (connect.value) {\n                        try {\n                            gatt.connect()\n                        }\n                        catch (e: Exception) {\n                            e.printStackTrace()\n                        }\n                        connect.value = false\n                    }\n\n                    Column (\n                        modifier = Modifier.padding(innerPadding),\n                        verticalArrangement = Arrangement.spacedBy(16.dp)\n                    )\n                    {\n                        Button(\n                            onClick = { connect.value = true }\n                        )\n                        {\n                            Text(\"Connect\")\n                        }\n\n                        Button(onClick = {\n                            val characteristicUuid = \"94110001-6D9B-4225-A4F1-6A4A7F01B0DE\"\n                            val value = byteArrayOf(0x01, 0x00, 0x00, 0x00, 0x00 ,0x00 ,0x01)\n                            sendWriteRequest(gatt, characteristicUuid, value)\n                        \n                        }) {\n                            Text(\"batteryLevel.value\")\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n@RequiresPermission(Manifest.permission.BLUETOOTH_CONNECT)\nfun sendWriteRequest(\n    gatt: BluetoothGatt,\n    characteristicUuid: String,\n    value: ByteArray\n) {\n    // Retrieve the service containing the characteristic\n    val service = gatt.services.find { service ->\n        service.characteristics.any { it.uuid.toString() == characteristicUuid }\n    }\n\n    if (service == null) {\n        Log.e(\"GATT\", \"Service containing characteristic UUID $characteristicUuid not found.\")\n        return\n    }\n\n    // Retrieve the characteristic\n    val characteristic = service.getCharacteristic(UUID.fromString(characteristicUuid))\n    if (characteristic == null) {\n        Log.e(\"GATT\", \"Characteristic with UUID $characteristicUuid not found.\")\n        return\n    }\n\n\n    // Send the write request\n    val success = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\n        gatt.writeCharacteristic(characteristic, value, BluetoothGattCharacteristic.WRITE_TYPE_DEFAULT)\n    } else {\n        gatt.writeCharacteristic(characteristic)\n    }\n    Log.d(\"GATT\", \"Write request sent $success to UUID: $characteristicUuid\")\n}"
        }
      ]
    },
    {
      "dir": "android/app/src/main/java/me/kavishdevar/librepods/utils",
      "files": [
        {
          "name": "PopupWindow.kt",
          "ext": ".kt",
          "size": 10443,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n *\n * Copyright (C) 2025 LibrePods contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\n\npackage me.kavishdevar.librepods.utils\n\nimport android.animation.Animator\nimport android.animation.AnimatorListenerAdapter\nimport android.animation.ObjectAnimator\nimport android.animation.PropertyValuesHolder\nimport android.annotation.SuppressLint\nimport android.content.BroadcastReceiver\nimport android.content.Context\nimport android.content.Intent\nimport android.content.IntentFilter\nimport android.graphics.PixelFormat\nimport android.os.Build\nimport android.os.Handler\nimport android.os.Looper\nimport android.util.Log\nimport android.view.Gravity\nimport android.view.LayoutInflater\nimport android.view.MotionEvent\nimport android.view.View\nimport android.view.WindowManager\nimport android.view.animation.AccelerateInterpolator\nimport android.view.animation.DecelerateInterpolator\nimport android.widget.ImageButton\nimport android.widget.LinearLayout\nimport android.widget.TextView\nimport android.widget.VideoView\nimport me.kavishdevar.librepods.R\nimport me.kavishdevar.librepods.constants.AirPodsNotifications\nimport me.kavishdevar.librepods.constants.Battery\nimport me.kavishdevar.librepods.constants.BatteryComponent\nimport me.kavishdevar.librepods.constants.BatteryStatus\nimport kotlin.collections.find\n\n@SuppressLint(\"InflateParams\", \"ClickableViewAccessibility\")\nclass PopupWindow(\n    private val context: Context,\n    private val onCloseCallback: () -> Unit = {}\n) {\n    private val mView: View\n    private var isClosing = false\n    private var autoCloseHandler = Handler(Looper.getMainLooper())\n    private var autoCloseRunnable: Runnable? = null\n    private var batteryUpdateReceiver: BroadcastReceiver? = null\n\n    @Suppress(\"DEPRECATION\")\n    private val mParams: WindowManager.LayoutParams = WindowManager.LayoutParams().apply {\n        height = WindowManager.LayoutParams.WRAP_CONTENT\n        width = WindowManager.LayoutParams.MATCH_PARENT\n        type = WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY\n        format = PixelFormat.TRANSLUCENT\n        gravity = Gravity.BOTTOM\n        dimAmount = 0.3f\n        flags = WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS or\n            WindowManager.LayoutParams.FLAG_FULLSCREEN or\n            WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or\n            WindowManager.LayoutParams.FLAG_DIM_BEHIND or\n            WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH\n    }\n\n    private val mWindowManager: WindowManager\n\n    init {\n        val layoutInflater = context.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater\n        mView = layoutInflater.inflate(R.layout.popup_window, null)\n        mParams.x = 0\n        mParams.y = 0\n\n        mParams.gravity = Gravity.BOTTOM\n        mView.setOnClickListener {\n            close()\n        }\n\n        mView.findViewById<ImageButton>(R.id.close_button).setOnClickListener {\n            close()\n        }\n\n        val ll = mView.findViewById<LinearLayout>(R.id.linear_layout)\n        ll.setOnClickListener {\n            close()\n        }\n\n        @Suppress(\"DEPRECATION\")\n        mView.systemUiVisibility = View.SYSTEM_UI_FLAG_LAYOUT_STABLE or\n            View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION or\n            View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN or\n            View.SYSTEM_UI_FLAG_HIDE_NAVIGATION or\n            View.SYSTEM_UI_FLAG_FULLSCREEN or\n            View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY\n\n        mView.setOnTouchListener { _, event ->\n            if (event.action == MotionEvent.ACTION_DOWN) {\n                val touchY = event.rawY\n                val popupTop = mView.top\n                if (touchY < popupTop) {\n                    close()\n                    true\n                } else {\n                    false\n                }\n            } else {\n                false\n            }\n        }\n        mWindowManager = context.getSystemService(Context.WINDOW_SERVICE) as WindowManager\n    }\n\n    @SuppressLint(\"InlinedApi\", \"SetTextI18s\")\n    fun open(name: String = \"AirPods Pro\", batteryNotification: AirPodsNotifications.BatteryNotification) {\n        try {\n            if (mView.windowToken == null && mView.parent == null && !isClosing) {\n                mView.findViewById<TextView>(R.id.name).text = name\n\n                updateBatteryStatus(batteryNotification)\n\n                val vid = mView.findViewById<VideoView>(R.id.video)\n                vid.setVideoPath(\"android.resource://me.kavishdevar.librepods/\" + R.raw.connected)\n                vid.resolveAdjustedSize(vid.width, vid.height)\n                vid.start()\n                vid.setOnCompletionListener {\n                    vid.start()\n                }\n\n                mWindowManager.addView(mView, mParams)\n\n                val displayMetrics = mView.context.resources.displayMetrics\n                val screenHeight = displayMetrics.heightPixels\n\n                mView.translationY = screenHeight.toFloat()\n                mView.alpha = 1f\n\n                val translationY = PropertyValuesHolder.ofFloat(View.TRANSLATION_Y, screenHeight.toFloat(), 0f)\n\n                ObjectAnimator.ofPropertyValuesHolder(mView, translationY).apply {\n                    duration = 500\n                    interpolator = DecelerateInterpolator()\n                    start()\n                }\n\n                registerBatteryUpdateReceiver()\n\n                autoCloseRunnable = Runnable { close() }\n                autoCloseHandler.postDelayed(autoCloseRunnable!!, 12000)\n            }\n        } catch (e: Exception) {\n            Log.e(\"PopupWindow\", \"Error opening popup: ${e.message}\")\n            onCloseCallback()\n        }\n    }\n\n    @SuppressLint(\"UnspecifiedRegisterReceiverFlag\")\n    private fun registerBatteryUpdateReceiver() {\n        batteryUpdateReceiver = object : BroadcastReceiver() {\n            override fun onReceive(context: Context?, intent: Intent?) {\n                if (intent?.action == AirPodsNotifications.BATTERY_DATA) {\n                    val batteryList = intent.getParcelableArrayListExtra<Battery>(\"data\")\n                    if (batteryList != null) {\n                        updateBatteryStatusFromList(batteryList)\n                    }\n                }\n            }\n        }\n\n        val filter = IntentFilter(AirPodsNotifications.BATTERY_DATA)\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\n            context.registerReceiver(batteryUpdateReceiver, filter, Context.RECEIVER_EXPORTED)\n        } else {\n            context.registerReceiver(batteryUpdateReceiver, filter)\n        }\n    }\n\n    private fun unregisterBatteryUpdateReceiver() {\n        batteryUpdateReceiver?.let {\n            try {\n                context.unregisterReceiver(it)\n                batteryUpdateReceiver = null\n            } catch (e: Exception) {\n                Log.e(\"PopupWindow\", \"Error unregistering battery receiver: ${e.message}\")\n            }\n        }\n    }\n\n    private fun updateBatteryStatusFromList(batteryList: List<Battery>) {\n        val batteryLeftText = mView.findViewById<TextView>(R.id.left_battery)\n        val batteryRightText = mView.findViewById<TextView>(R.id.right_battery)\n        val batteryCaseText = mView.findViewById<TextView>(R.id.case_battery)\n\n        batteryLeftText.text = batteryList.find { it.component == BatteryComponent.LEFT }?.let {\n            if (it.status != BatteryStatus.DISCONNECTED) {\n                \"\\uDBC3\\uDC8E    ${it.level}%\"\n            } else {\n                \"\"\n            }\n        } ?: \"\"\n\n        batteryRightText.text = batteryList.find { it.component == BatteryComponent.RIGHT }?.let {\n            if (it.status != BatteryStatus.DISCONNECTED) {\n                \"\\uDBC3\\uDC8D    ${it.level}%\"\n            } else {\n                \"\"\n            }\n        } ?: \"\"\n\n        batteryCaseText.text = batteryList.find { it.component == BatteryComponent.CASE }?.let {\n            if (it.status != BatteryStatus.DISCONNECTED) {\n                \"\\uDBC3\\uDE6C    ${it.level}%\"\n            } else {\n                \"\"\n            }\n        } ?: \"\"\n    }\n\n    @SuppressLint(\"SetTextI18s\")\n    fun updateBatteryStatus(batteryNotification: AirPodsNotifications.BatteryNotification) {\n        val batteryStatus = batteryNotification.getBattery()\n        updateBatteryStatusFromList(batteryStatus)\n    }\n\n    fun close() {\n        try {\n            if (isClosing) return\n            isClosing = true\n\n            autoCloseRunnable?.let { autoCloseHandler.removeCallbacks(it) }\n            unregisterBatteryUpdateReceiver()\n\n            val vid = mView.findViewById<VideoView>(R.id.video)\n            vid.stopPlayback()\n\n            ObjectAnimator.ofFloat(mView, \"translationY\", mView.height.toFloat()).apply {\n                duration = 500\n                interpolator = AccelerateInterpolator()\n                addListener(object : AnimatorListenerAdapter() {\n                    override fun onAnimationEnd(animation: Animator) {\n                        try {\n                            mView.visibility = View.GONE\n                            if (mView.parent != null) {\n                                mWindowManager.removeView(mView)\n                            }\n                        } catch (e: Exception) {\n                            Log.e(\"PopupWindow\", \"Error removing view: ${e.message}\")\n                        } finally {\n                            isClosing = false\n                            onCloseCallback()\n                        }\n                    }\n                })\n                start()\n            }\n        } catch (e: Exception) {\n            Log.e(\"PopupWindow\", \"Error closing popup: ${e.message}\")\n            isClosing = false\n            onCloseCallback()\n        }\n    }\n\n    val isShowing: Boolean\n        get() = mView.parent != null && !isClosing\n}\n"
        },
        {
          "name": "KotlinModule.kt",
          "ext": ".kt",
          "size": 34833,
          "preview": "package me.kavishdevar.librepods.utils\n\nimport android.content.Context\nimport android.content.Intent\nimport android.content.pm.ApplicationInfo\nimport android.content.res.ColorStateList\nimport android.graphics.Color\nimport android.graphics.drawable.GradientDrawable\nimport android.os.ParcelUuid\nimport android.util.Log\nimport android.view.Gravity\nimport android.view.View\nimport android.view.ViewGroup\nimport android.view.animation.AccelerateInterpolator\nimport android.view.animation.DecelerateInterpolator\nimport android.widget.FrameLayout\nimport android.widget.ImageButton\nimport android.widget.ImageView\nimport android.widget.LinearLayout\nimport io.github.libxposed.api.XposedInterface\nimport io.github.libxposed.api.XposedInterface.AfterHookCallback\nimport io.github.libxposed.api.XposedModule\nimport io.github.libxposed.api.XposedModuleInterface\nimport io.github.libxposed.api.XposedModuleInterface.ModuleLoadedParam\nimport io.github.libxposed.api.annotations.AfterInvocation\nimport io.github.libxposed.api.annotations.XposedHooker\n\nprivate const val TAG = \"AirPodsHook\"\nprivate lateinit var module: KotlinModule\n\nclass KotlinModule(base: XposedInterface, param: ModuleLoadedParam): XposedModule(base, param) {\n    init {\n        Log.i(TAG, \"AirPodsHook module initialized at :: ${param.processName}\")\n        module = this\n    }\n\n    override fun onPackageLoaded(param: XposedModuleInterface.PackageLoadedParam) {\n        super.onPackageLoaded(param)\n        Log.i(TAG, \"onPackageLoaded :: ${param.packageName}\")\n\n        if (param.packageName == \"com.google.android.bluetooth\" || param.packageName == \"com.android.bluetooth\") {\n            Log.i(TAG, \"Bluetooth app detected, hooking l2c_fcr_chk_chan_modes\")\n\n            try {\n                if (param.isFirstPackage) {\n                    Log.i(TAG, \"Loading native library for Bluetooth hook\")\n                    System.loadLibrary(\"l2c_fcr_hook\")\n                    Log.i(TAG, \"Native library loaded successfully\")\n                }\n            } catch (e: Exception) {\n                Log.e(TAG, \"Failed to load native library: ${e.message}\", e)\n            }\n        }\n\n        if (param.packageName == \"com.google.android.settings\") {\n            Log.i(TAG, \"Settings app detected, hooking Bluetooth icon handling\")\n            try {\n                val headerControllerClass = param.classLoader.loadClass(\n                    \"com.google.android.settings.bluetooth.AdvancedBluetoothDetailsHeaderController\")\n\n                val updateIconMethod = headerControllerClass.getDeclaredMethod(\n                    \"updateIcon\",\n                    android.widget.ImageView::class.java,\n                    String::class.java)\n\n                hook(updateIconMethod, BluetoothIconHooker::class.java)\n                Log.i(TAG, \"Successfully hooked updateIcon method in Bluetooth settings\")\n\n                try {\n                    val displayPreferenceMethod = headerControllerClass.getDeclaredMethod(\n                        \"displayPreference\",\n                        param.classLoader.loadClass(\"androidx.preference.PreferenceScreen\"))\n\n                    hook(displayPreferenceMethod, BluetoothSettingsAirPodsHooker::class.java)\n                    Log.i(TAG, \"Successfully hooked displayPreference for AirPods button injection\")\n                } catch (e: Exception) {\n                    Log.e(TAG, \"Failed to hook displayPreference: ${e.message}\", e)\n                }\n            } catch (e: Exception) {\n                Log.e(TAG, \"Failed to hook Bluetooth icon handler: ${e.message}\", e)\n            }\n        }\n\n        if (param.packageName == \"com.android.settings\") {\n            Log.i(TAG, \"Settings app detected, hooking Bluetooth icon handling\")\n            try {\n                val headerControllerClass = param.classLoader.loadClass(\n                    \"com.android.settings.bluetooth.AdvancedBluetoothDetailsHeaderController\")\n\n                val updateIconMethod = headerControllerClass.getDeclaredMethod(\n                    \"updateIcon\",\n                    android.widget.ImageView::class.java,\n                    String::class.java)\n\n                hook(updateIconMethod, BluetoothIconHooker::class.java)\n                Log.i(TAG, \"Successfully hooked updateIcon method in Bluetooth settings\")\n\n                try {\n                    val displayPreferenceMethod = headerControllerClass.getDeclaredMethod(\n                        \"displayPreference\",\n                        param.classLoader.loadClass(\"androidx.preference.PreferenceScreen\"))\n\n                    hook(displayPreferenceMethod, BluetoothSettingsAirPodsHooker::class.java)\n                    Log.i(TAG, \"Successfully hooked displayPreference for AirPods button injection\")\n                } catch (e: Exception) {\n                    Log.e(TAG, \"Failed to hook displayPreference: ${e.message}\", e)\n                }\n            } catch (e: Exception) {\n                Log.e(TAG, \"Failed to hook Bluetooth icon handler: ${e.message}\", e)\n            }\n        }\n    }\n\n    @XposedHooker\n    class BluetoothSettingsAirPodsHooker : XposedInterface.Hooker {\n        companion object {\n            private const val AIRPODS_UUID = \"74ec2172-0bad-4d01-8f77-997b2be0722a\"\n            private const val LIBREPODS_PREFERENCE_KEY = \"librepods_open_preference\"\n            private const val ACTION_SET_ANC_MODE = \"me.kavishdevar.librepods.SET_ANC_MODE\"\n            private const val EXTRA_ANC_MODE = \"anc_mode\"\n\n            private const val ANC_MODE_OFF = 1\n            private const val ANC_MODE_NOISE_CANCELLATION = 2\n            private const val ANC_MODE_TRANSPARENCY = 3\n            private const val ANC_MODE_ADAPTIVE = 4\n\n            private var currentAncMode = ANC_MODE_NOISE_CANCELLATION\n\n            @JvmStatic\n            @AfterInvocation\n            fun afterDisplayPreference(callback: AfterHookCallback) {\n                try {\n                    val controller = callback.thisObject!!\n                    val preferenceScreen = callback.args[0]!!\n\n                    val context = preferenceScreen.javaClass.getMethod(\"getContext\").invoke(preferenceScreen) as Context\n\n                    val deviceField = controller.javaClass.getDeclaredField(\"mCachedDevice\")\n                    deviceField.isAccessible = true\n                    val cachedDevice = deviceField.get(controller) ?: return\n\n                    val getDeviceMethod = cachedDevice.javaClass.getMethod(\"getDevice\")\n                    val bluetoothDevice = getDeviceMethod.invoke(cachedDevice) ?: return\n\n                    val uuidsMethod = bluetoothDevice.javaClass.getMethod(\"getUuids\")\n                    val uuids = uuidsMethod.invoke(bluetoothDevice) as? Array<ParcelUuid>\n\n                    if (uuids != null) {\n                        val isAirPods = uuids.any { it.uuid.toString() == AIRPODS_UUID }\n\n                        if (isAirPods) {\n                            Log.i(TAG, \"AirPods device detected in settings, injecting controls\")\n\n                            val findPreferenceMethod = preferenceScreen.javaClass.getMethod(\"findPreference\", CharSequence::class.java)\n                            val existingPref = findPreferenceMethod.invoke(preferenceScreen, LIBREPODS_PREFERENCE_KEY)\n\n                            if (existingPref != null) {\n                                Log.i(TAG, \"LIBREPODS button already exists, skipping\")\n                                return\n                            }\n\n                            val preferenceClass = preferenceScreen.javaClass.classLoader.loadClass(\"androidx.preference.Preference\")\n                            val preference = preferenceClass.getConstructor(Context::class.java).newInstance(context)\n\n                            val setKeyMethod = preferenceClass.getMethod(\"setKey\", String::class.java)\n                            setKeyMethod.invoke(preference, LIBREPODS_PREFERENCE_KEY)\n\n                            val setTitleMethod = preferenceClass.getMethod(\"setTitle\", CharSequence::class.java)\n                            setTitleMethod.invoke(preference, \"Open LibrePods\")\n\n                            val setSummaryMethod = preferenceClass.getMethod(\"setSummary\", CharSequence::class.java)\n                            setSummaryMethod.invoke(preference, \"Control AirPods features\")\n\n                            val setIconMethod = preferenceClass.getMethod(\"setIcon\", Int::class.java)\n                            setIconMethod.invoke(preference, android.R.drawable.ic_menu_manage)\n\n                            val setOrderMethod = preferenceClass.getMethod(\"setOrder\", Int::class.java)\n                            setOrderMethod.invoke(preference, 1000)\n\n                            val intent = Intent().apply {\n                                setClassName(\"me.kavishdevar.librepods\", \"me.kavishdevar.librepods.MainActivity\")\n                                flags = Intent.FLAG_ACTIVITY_NEW_TASK\n                            }\n                            val setIntentMethod = preferenceClass.getMethod(\"setIntent\", Intent::class.java)\n                            setIntentMethod.invoke(preference, intent)\n\n                            val addPreferenceMethod = preferenceScreen.javaClass.getMethod(\"addPreference\", preferenceClass)\n                            addPreferenceMethod.invoke(preferenceScreen, preference)\n\n                            Log.i(TAG, \"Successfully added Open LIBREPODS button to AirPods settings\")\n                        }\n                    }\n                } catch (e: Exception) {\n                    Log.e(TAG, \"Error in BluetoothSettingsAirPodsHooker: ${e.message}\", e)\n                    e.printStackTrace()\n                }\n            }\n        }\n    }\n\n    @XposedHooker\n    class BluetoothIconHooker : XposedInterface.Hooker {\n        companion object {\n            @JvmStatic\n            @AfterInvocation\n            fun afterUpdateIcon(callback: AfterHookCallback) {\n                Log.i(TAG, \"BluetoothIconHooker called with args: ${callback.args.joinToString(\", \")}\")\n                try {\n                    val imageView = callback.args[0] as ImageView\n                    val iconUri = callback.args[1] as String\n\n                    val uri = android.net.Uri.parse(iconUri)\n                    if (uri.toString().startsWith(\"android.resource://me.kavishdevar.librepods\")) {\n                        Log.i(TAG, \"Handling AirPods icon URI: $uri\")\n\n                        try {\n                            val context = imageView.context\n\n                            android.os.Handler(android.os.Looper.getMainLooper()).post {\n                                try {\n                                    val packageName = uri.authority\n                                    val packageContext = context.createPackageContext(\n                                        packageName,\n                                        Context.CONTEXT_IGNORE_SECURITY\n                                    )\n\n                                    val resPath = uri.pathSegments\n                                    if (resPath.size >= 2 && resPath[0] == \"drawable\") {\n                                        val resourceName = resPath[1]\n                                        val resourceId = packageContext.resources.getIdentifier(\n                                            resourceName, \"drawable\", packageName\n                                        )\n\n                                        if (resourceId != 0) {\n                                            val drawable = packageContext.resources.getDrawable(\n                                                resourceId, packageContext.theme\n                                            )\n\n                                            imageView.setImageDrawable(drawable)\n                                            imageView.alpha = 1.0f\n\n                                            callback.result = null\n\n                                            Log.i(TAG, \"Successfully loaded icon from resource: $resourceName\")\n                                        } else {\n                                            Log.e(TAG, \"Resource not found: $resourceName\")\n                                        }\n                                    }\n                                } catch (e: Exception) {\n                                    Log.e(TAG, \"Error loading resource from URI $uri: ${e.message}\")\n                                }\n                            }\n                        } catch (e: Exception) {\n                            Log.e(TAG, \"Error accessing context: ${e.message}\")\n                        }\n                    }\n                } catch (e: Exception) {\n                    Log.e(TAG, \"Error in BluetoothIconHooker: ${e.message}\")\n                    e.printStackTrace()\n                }\n            }\n        }\n    }\n\n    override fun getApplicationInfo(): ApplicationInfo {\n        return super.applicationInfo\n    }\n\n    companion object {\n        private const val ANC_MODE_OFF = 1\n        private const val ANC_MODE_NOISE_CANCELLATION = 2\n        private const val ANC_MODE_TRANSPARENCY = 3\n        private const val ANC_MODE_ADAPTIVE = 4\n\n        private var currentANCMode = ANC_MODE_NOISE_CANCELLATION\n\n        private const val ACTION_SET_ANC_MODE = \"me.kavishdevar.librepods.SET_ANC_MODE\"\n        private const val EXTRA_ANC_MODE = \"anc_mode\"\n        private const val ANIMATION_DURATION = 250L\n\n        private fun addAirPodsControlsToDialog(volumeDialog: Any) {\n            try {\n                val contextField = volumeDialog.javaClass.getDeclaredField(\"mContext\")\n                contextField.isAccessible = true\n                val context = contextField.get(volumeDialog) as Context\n\n                val dialogViewField = volumeDialog.javaClass.getDeclaredField(\"mDialogView\")\n                dialogViewField.isAccessible = true\n                val dialogView = dialogViewField.get(volumeDialog) as ViewGroup\n\n                val dialogRowsViewField = volumeDialog.javaClass.getDeclaredField(\"mDialogRowsView\")\n                dialogRowsViewField.isAccessible = true\n                val dialogRowsView = dialogRowsViewField.get(volumeDialog) as ViewGroup\n\n                Log.d(TAG, \"Found dialogRowsView: ${dialogRowsView.javaClass.name}\")\n\n                val existingContainer = dialogView.findViewWithTag<View>(\"airpods_container\")\n                if (existingContainer != null) {\n                    Log.d(TAG, \"AirPods container already exists, ensuring visibility state\")\n                    val drawer = existingContainer.findViewWithTag<View>(\"airpods_drawer_container\")\n                    drawer?.visibility = View.GONE\n                    drawer?.alpha = 0f\n                    drawer?.translationY = 0f\n                    val button = existingContainer.findViewWithTag<ImageButton>(\"airpods_button\")\n                    button?.visibility = View.VISIBLE\n                    button?.alpha = 1f\n                    if (button != null) {\n                         updateMainButtonIcon(context, button, currentANCMode)\n                    }\n                    return\n                }\n\n                val newAirPodsButton = ImageButton(context).apply {\n                    tag = \"airpods_button\"\n\n                    try {\n                        val airPodsPackage = context.createPackageContext(\n                            \"me.kavishdevar.librepods\",\n                            Context.CONTEXT_IGNORE_SECURITY\n                        )\n                        val airPodsIconRes = airPodsPackage.resources.getIdentifier(\n                            \"airpods\", \"drawable\", \"me.kavishdevar.librepods\")\n\n                        if (airPodsIconRes != 0) {\n                            val airPodsDrawable = airPodsPackage.resources.getDrawable(\n                                airPodsIconRes, airPodsPackage.theme)\n                            setImageDrawable(airPodsDrawable)\n                        } else {\n                            setImageResource(android.R.drawable.ic_media_play)\n                            Log.d(TAG, \"Using fallback icon because airpods icon resource not found\")\n                        }\n                    } catch (e: Exception) {\n                        setImageResource(android.R.drawable.ic_media_play)\n                        Log.e(TAG, \"Failed to load AirPods icon: ${e.message}\")\n                    }\n\n                    val shape = GradientDrawable()\n                    shape.shape = GradientDrawable.RECTANGLE\n                    shape.setColor(Color.BLACK)\n                    background = shape\n\n                    imageTintList = ColorStateList.valueOf(Color.WHITE)\n                    scaleType = ImageView.ScaleType.CENTER_INSIDE\n\n                    setPadding(24, 24, 24, 24)\n\n                    val params = LinearLayout.LayoutParams(\n                        LinearLayout.LayoutParams.MATCH_PARENT,\n                        90\n                    )\n                    params.gravity = Gravity.CENTER\n                    params.setMargins(0, 0, 0, 0)\n                    layoutParams = params\n\n                    setOnClickListener {\n                        Log.d(TAG, \"AirPods button clicked, toggling drawer\")\n                        val container = findAirPodsContainer(this)\n                        val drawerContainer = container?.findViewWithTag<View>(\"airpods_drawer_container\")\n                        if (drawerContainer != null && container != null) {\n                            if (drawerContainer.visibility == View.VISIBLE) {\n                                hideAirPodsDrawer(container, this, drawerContainer)\n                            } else {\n                                showAirPodsDrawer(container, this, drawerContainer)\n                            }\n                        } else {\n                             Log.e(TAG, \"Could not find container or drawer for toggle\")\n                        }\n                    }\n\n                    contentDescription = \"AirPods Settings\"\n                }\n\n                val airPodsContainer = FrameLayout(context).apply {\n                    layoutParams = LinearLayout.LayoutParams(\n                        LinearLayout.LayoutParams.MATCH_PARENT,\n                        LinearLayout.LayoutParams.WRAP_CONTENT\n                    )\n                    tag = \"airpods_container\"\n                }\n\n                newAirPodsButton.setOnLongClickListener {\n                    Log.d(TAG, \"AirPods button long-pressed, opening QuickSettingsDialogActivity\")\n                    val intent = Intent().apply {\n                        setClassName(\"me.kavishdevar.librepods\", \"me.kavishdevar.librepods.QuickSettingsDialogActivity\")\n                        flags = Intent.FLAG_ACTIVITY_NEW_TASK\n                    }\n                    context.startActivity(intent)\n                    try {\n                        val dismissMethod = volumeDialog.javaClass.getMethod(\"dismissH\")\n                        dismissMethod.invoke(volumeDialog)\n                    } catch (e: Exception) {\n                        Log.w(TAG, \"Could not dismiss volume dialog: ${e.message}\")\n                    }\n                    true\n                }\n\n                val airPodsDrawer = LinearLayout(context).apply {\n                    orientation = LinearLayout.VERTICAL\n                    layoutParams = FrameLayout.LayoutParams(\n                        FrameLayout.LayoutParams.MATCH_PARENT,\n                        FrameLayout.LayoutParams.WRAP_CONTENT\n                    ).apply {\n                        gravity = Gravity.TOP\n                    }\n                    tag = \"airpods_drawer_container\"\n                    visibility = View.GONE\n                    alpha = 0f\n\n                    val drawerShape = GradientDrawable()\n                    drawerShape.shape = GradientDrawable.RECTANGLE\n                    drawerShape.setColor(Color.BLACK)\n                    background = drawerShape\n\n                    setPadding(16, 8, 16, 8)\n                }\n\n                val buttonContainer = LinearLayout(context).apply {\n                    orientation = LinearLayout.VERTICAL\n                    layoutParams = FrameLayout.LayoutParams(\n                        FrameLayout.LayoutParams.MATCH_PARENT,\n                        FrameLayout.LayoutParams.WRAP_CONTENT\n                    ).apply {\n                        gravity = Gravity.TOP\n                    }\n                    tag = \"airpods_button_container\"\n                }\n\n                val modes = listOf(ANC_MODE_OFF, ANC_MODE_TRANSPARENCY, ANC_MODE_ADAPTIVE, ANC_MODE_NOISE_CANCELLATION)\n                for (mode in modes) {\n                    val modeOption = createAncModeOption(context, mode, mode == currentANCMode, newAirPodsButton)\n                    airPodsDrawer.addView(modeOption)\n                }\n\n                buttonContainer.addView(newAirPodsButton)\n\n                airPodsContainer.addView(airPodsDrawer)\n                airPodsContainer.addView(buttonContainer)\n\n                val settingsViewField = try {\n                    val field = volumeDialog.javaClass.getDeclaredField(\"mSettingsView\")\n                    field.isAccessible = true\n                    field.get(volumeDialog) as? View\n                } catch (e: Exception) {\n                    Log.e(TAG, \"Failed to get settings view field: ${e.message}\")\n                    null\n                }\n\n                if (settingsViewField != null && settingsViewField.parent is ViewGroup) {\n                    val settingsParent = settingsViewField.parent as ViewGroup\n                    val settingsIndex = findViewIndexInParent(settingsParent, settingsViewField)\n\n                    if (settingsIndex >= 0) {\n                        settingsParent.addView(airPodsContainer, settingsIndex)\n                        Log.i(TAG, \"Added AirPods controls before settings button\")\n                    } else {\n                        settingsParent.addView(airPodsContainer)\n                        Log.i(TAG, \"Added AirPods controls to the end of settings parent\")\n                    }\n                } else {\n                    dialogView.addView(airPodsContainer)\n                    Log.i(TAG, \"Fallback: Added AirPods controls to dialog view\")\n                }\n\n                updateMainButtonIcon(context, newAirPodsButton, currentANCMode)\n\n                Log.i(TAG, \"Successfully added AirPods button and drawer to volume dialog\")\n            } catch (e: Exception) {\n                Log.e(TAG, \"Error adding AirPods button to volume panel: ${e.message}\")\n                e.printStackTrace()\n            }\n        }\n\n        private fun findViewIndexInParent(parent: ViewGroup, view: View): Int {\n            for (i in 0 until parent.childCount) {\n                if (parent.getChildAt(i) == view) {\n                    return i\n                }\n            }\n            return -1\n        }\n\n        private fun updateMainButtonIcon(context: Context, button: ImageButton, mode: Int) {\n            try {\n                val pkgContext = context.createPackageContext(\n                    \"me.kavishdevar.librepods\",\n                    Context.CONTEXT_IGNORE_SECURITY\n                )\n\n                val resName = when (mode) {\n                    ANC_MODE_OFF -> \"noise_cancellation\"\n                    ANC_MODE_TRANSPARENCY -> \"transparency\"\n                    ANC_MODE_ADAPTIVE -> \"adaptive\"\n                    ANC_MODE_NOISE_CANCELLATION -> \"noise_cancellation\"\n                    else -> \"noise_cancellation\"\n                }\n\n                val resId = pkgContext.resources.getIdentifier(\n                    resName, \"drawable\", \"me.kavishdevar.librepods\"\n                )\n\n                if (resId != 0) {\n                    val drawable = pkgContext.resources.getDrawable(resId, pkgContext.theme)\n                    button.setImageDrawable(drawable)\n                    button.setColorFilter(Color.WHITE)\n                } else {\n                    button.setImageResource(getIconResourceForMode(mode))\n                    button.setColorFilter(Color.WHITE)\n                }\n            } catch (e: Exception) {\n                button.setImageResource(getIconResourceForMode(mode))\n                button.setColorFilter(Color.WHITE)\n            }\n        }\n\n        private fun createAncModeOption(context: Context, mode: Int, isSelected: Boolean, mainButton: ImageButton): LinearLayout {\n            return LinearLayout(context).apply {\n                orientation = LinearLayout.HORIZONTAL\n                layoutParams = LinearLayout.LayoutParams(\n                    LinearLayout.LayoutParams.MATCH_PARENT,\n                    LinearLayout.LayoutParams.WRAP_CONTENT\n                ).apply {\n                    setMargins(0, 6, 0, 6)\n                }\n                gravity = Gravity.CENTER\n                setPadding(24, 16, 24, 16)\n                tag = \"anc_mode_${mode}\"\n\n                val icon = ImageView(context).apply {\n                    layoutParams = LinearLayout.LayoutParams(60, 60).apply {\n                        gravity = Gravity.CENTER\n                    }\n                    tag = \"mode_icon_$mode\"\n\n                    try {\n                        val packageContext = context.createPackageContext(\n                            \"me.kavishdevar.librepods\",\n                            Context.CONTEXT_IGNORE_SECURITY\n                        )\n\n                        val resourceName = when (mode) {\n                            ANC_MODE_OFF -> \"noise_cancellation\"\n                            ANC_MODE_TRANSPARENCY -> \"transparency\"\n                            ANC_MODE_ADAPTIVE -> \"adaptive\"\n                            ANC_MODE_NOISE_CANCELLATION -> \"noise_cancellation\"\n                            else -> \"noise_cancellation\"\n                        }\n\n                        val resourceId = packageContext.resources.getIdentifier(\n                            resourceName, \"drawable\", \"me.kavishdevar.librepods\"\n                        )\n\n                        if (resourceId != 0) {\n                            val drawable = packageContext.resources.getDrawable(\n                                resourceId, packageContext.theme\n                            )\n                            setImageDrawable(drawable)\n                        } else {\n                            setImageResource(getIconResourceForMode(mode))\n                        }\n                    } catch (e: Exception) {\n                        setImageResource(getIconResourceForMode(mode))\n                        Log.e(TAG, \"Failed to load custom drawable for mode $mode: ${e.message}\")\n                    }\n\n                    if (isSelected) {\n                        setColorFilter(Color.BLACK)\n                    } else {\n                        setColorFilter(Color.WHITE)\n                    }\n                }\n\n                addView(icon)\n\n                if (isSelected) {\n                    background = createSelectedBackground(context)\n                } else {\n                    background = null\n                }\n\n                setOnClickListener {\n                    Log.d(TAG, \"ANC mode selected: $mode (was: $currentANCMode)\")\n                    val container = findAirPodsContainer(this)\n                    val drawerContainer = container?.findViewWithTag<View>(\"airpods_drawer_container\")\n\n                    if (currentANCMode == mode) {\n                        if (drawerContainer != null && container != null) {\n                            hideAirPodsDrawer(container, mainButton, drawerContainer)\n                        }\n                        return@setOnClickListener\n                    }\n\n                    currentANCMode = mode\n\n                    val parentDrawer = parent as? ViewGroup\n                    if (parentDrawer != null) {\n                        for (i in 0 until parentDrawer.childCount) {\n                            val child = parentDrawer.getChildAt(i) as? LinearLayout\n                            if (child != null && child.tag.toString().startsWith(\"anc_mode_\")) {\n                                val childModeStr = child.tag.toString().substringAfter(\"anc_mode_\")\n                                val childMode = childModeStr.toIntOrNull() ?: -1\n                                val childIcon = child.findViewWithTag<ImageView>(\"mode_icon_${childMode}\")\n\n                                if (childMode == mode) {\n                                    child.background = createSelectedBackground(context)\n                                    childIcon?.setColorFilter(Color.BLACK)\n                                } else {\n                                    child.background = null\n                                    childIcon?.setColorFilter(Color.WHITE)\n                                }\n                            }\n                        }\n                    }\n\n                    val intent = Intent(ACTION_SET_ANC_MODE).apply {\n                        setPackage(\"me.kavishdevar.librepods\")\n                        putExtra(EXTRA_ANC_MODE, mode)\n                    }\n                    context.sendBroadcast(intent)\n                    Log.d(TAG, \"Sent broadcast to change ANC mode to: ${getLabelForMode(currentANCMode)}\")\n\n\n                    updateMainButtonIcon(context, mainButton, mode)\n\n                    if (drawerContainer != null && container != null) {\n                         android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({\n                             hideAirPodsDrawer(container, mainButton, drawerContainer)\n                         }, 50)\n                    }\n                }\n            }\n        }\n\n        private fun createSelectedBackground(context: Context): GradientDrawable {\n            return GradientDrawable().apply {\n                shape = GradientDrawable.RECTANGLE\n                setColor(Color.WHITE)\n                cornerRadius = 50f\n            }\n        }\n\n        private fun findAirPodsContainer(view: View): ViewGroup? {\n            var current: View? = view\n            while (current != null) {\n                if (current is ViewGroup && current.tag == \"airpods_container\") {\n                    return current\n                }\n                val parent = current.parent\n                if (parent is ViewGroup && parent.tag == \"airpods_container\") {\n                    return parent\n                }\n                current = parent as? View\n            }\n            Log.w(TAG, \"Could not find airpods_container ancestor\")\n            return null\n        }\n\n        private fun showAirPodsDrawer(container: ViewGroup, mainButton: ImageButton, drawerContainer: View) {\n            Log.d(TAG, \"Showing AirPods drawer\")\n            val selectedModeView = drawerContainer.findViewWithTag<View>(\"anc_mode_$currentANCMode\")\n            val selectedModeIcon = selectedModeView?.findViewWithTag<ImageView>(\"mode_icon_$currentANCMode\")\n            val buttonContainer = container.findViewWithTag<View>(\"airpods_button_container\")\n\n            if (selectedModeView == null || selectedModeIcon == null) {\n                Log.e(TAG, \"Cannot find selected mode view or icon for show animation\")\n\n                drawerContainer.alpha = 0f\n                drawerContainer.visibility = View.VISIBLE\n\n                drawerContainer.animate()\n                    .alpha(1f)\n                    .setDuration(ANIMATION_DURATION)\n                    .start()\n\n                buttonContainer?.animate()\n                    ?.alpha(0f)\n                    ?.setDuration(ANIMATION_DURATION / 2)\n                    ?.setStartDelay(ANIMATION_DURATION / 2)\n                    ?.withEndAction {\n                        buttonContainer.visibility = View.GONE\n                    }\n                    ?.start()\n\n                return\n            }\n\n            drawerContainer.measure(\n                View.MeasureSpec.makeMeasureSpec(container.width, View.MeasureSpec.EXACTLY),\n                View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED)\n            )\n\n            val drawerHeight = drawerContainer.measuredHeight\n\n            drawerContainer.alpha = 0f\n            drawerContainer.visibility = View.VISIBLE\n            drawerContainer.translationY = -drawerHeight.toFloat()\n\n            drawerContainer.animate()\n                .translationY(0f)\n                .alpha(1f)\n                .setDuration(ANIMATION_DURATION)\n                .setInterpolator(DecelerateInterpolator())\n                .start()\n\n            buttonContainer?.animate()\n                ?.alpha(0f)\n                ?.setDuration(ANIMATION_DURATION / 2)\n                ?.setStartDelay(ANIMATION_DURATION / 3)\n                ?.withEndAction {\n                    buttonContainer.visibility = View.GONE\n                }\n                ?.start()\n        }\n\n        private fun hideAirPodsDrawer(container: ViewGroup, mainButton: ImageButton, drawerContainer: View) {\n            Log.d(TAG, \"Hiding AirPods drawer\")\n            val buttonContainer = container.findViewWithTag<View>(\"airpods_button_container\")\n\n            if (buttonContainer != null && buttonContainer.visibility != View.VISIBLE) {\n                buttonContainer.alpha = 0f\n                buttonContainer.visibility = View.VISIBLE\n            }\n\n            buttonContainer?.animate()\n                ?.alpha(1f)\n                ?.setDuration(ANIMATION_DURATION / 2)\n                ?.start()\n\n            drawerContainer.animate()\n                .translationY(-drawerContainer.height.toFloat())\n                .alpha(0f)\n                .setDuration(ANIMATION_DURATION)\n                .setInterpolator(AccelerateInterpolator())\n                .setStartDelay(ANIMATION_DURATION / 4)\n                .withEndAction {\n                    drawerContainer.visibility = View.GONE\n                    drawerContainer.translationY = 0f\n                }\n                .start()\n        }\n\n        private fun getIconResourceForMode(mode: Int): Int {\n            return when (mode) {\n                ANC_MODE_OFF -> android.R.drawable.ic_lock_silent_mode\n                ANC_MODE_TRANSPARENCY -> android.R.drawable.ic_lock_silent_mode_off\n                ANC_MODE_ADAPTIVE -> android.R.drawable.ic_menu_compass\n                ANC_MODE_NOISE_CANCELLATION -> android.R.drawable.ic_lock_idle_charging\n                else -> android.R.drawable.ic_lock_silent_mode_off\n            }\n        }\n\n        private fun getLabelForMode(mode: Int): String {\n            return when (mode) {\n                ANC_MODE_OFF -> \"Off\"\n                ANC_MODE_TRANSPARENCY -> \"Transparency\"\n                ANC_MODE_ADAPTIVE -> \"Adaptive\"\n                ANC_MODE_NOISE_CANCELLATION -> \"Noise Cancellation\"\n                else -> \"Unknown\"\n            }\n        }\n    }\n}\n"
        },
        {
          "name": "AACPManager.kt",
          "ext": ".kt",
          "size": 22042,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple's ecosystem\n *\n * Copyright (C) 2025 LibrePods contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\n@file:OptIn(ExperimentalEncodingApi::class)\n\npackage me.kavishdevar.librepods.utils\n\nimport android.util.Log\nimport me.kavishdevar.librepods.utils.AACPManager.Companion.ControlCommandIdentifiers.entries\nimport me.kavishdevar.librepods.utils.AACPManager.Companion.StemPressBudType.entries\nimport me.kavishdevar.librepods.utils.AACPManager.Companion.StemPressType.entries\nimport kotlin.io.encoding.ExperimentalEncodingApi\n\n/**\n * Manager class for Apple Accessory Communication Protocol (AACP)\n * This class is responsible for handling the L2CAP socket management,\n * constructing and parsing packets for communication with AirPods.\n */\nclass AACPManager {\n    companion object {\n        private const val TAG = \"AACPManager\"\n\n        object Opcodes {\n            const val SET_FEATURE_FLAGS: Byte = 0x4d\n            const val REQUEST_NOTIFICATIONS: Byte = 0x0f\n            const val BATTERY_INFO: Byte = 0x04\n            const val CONTROL_COMMAND: Byte = 0x09\n            const val EAR_DETECTION: Byte = 0x06\n            const val CONVERSATION_AWARENESS: Byte = 0x4b\n            const val DEVICE_METADATA: Byte = 0x1d\n            const val RENAME: Byte = 0x1E\n            const val HEADTRACKING: Byte = 0x17\n            const val PROXIMITY_KEYS_REQ: Byte = 0x30\n            const val PROXIMITY_KEYS_RSP: Byte = 0x31\n            const val STEM_PRESS: Byte = 0x19\n        }\n\n        private val HEADER_BYTES = byteArrayOf(0x04, 0x00, 0x04, 0x00)\n\n        data class ControlCommandStatus(\n            val identifier: ControlCommandIdentifiers,\n            val value: ByteArray\n        ) {\n            override fun equals(other: Any?): Boolean {\n                if (this === other) return true\n                if (javaClass != other?.javaClass) return false\n\n                other as ControlCommandStatus\n\n                if (identifier != other.identifier) return false\n                if (!value.contentEquals(other.value)) return false\n\n                return true\n            }\n\n            override fun hashCode(): Int {\n                var result: Int = identifier.hashCode()\n                result = 31 * result + value.contentHashCode()\n                return result\n            }\n        }\n\n//        @Suppress(\"unused\")\n        enum class ControlCommandIdentifiers(val value: Byte) {\n            MIC_MODE(0x01),\n            BUTTON_SEND_MODE(0x05),\n            VOICE_TRIGGER(0x12),\n            SINGLE_CLICK_MODE(0x14),\n            DOUBLE_CLICK_MODE(0x15),\n            CLICK_HOLD_MODE(0x16),\n            DOUBLE_CLICK_INTERVAL(0x17),\n            CLICK_HOLD_INTERVAL(0x18),\n            LISTENING_MODE_CONFIGS(0x1A),\n            ONE_BUD_ANC_MODE(0x1B),\n            CROWN_ROTATION_DIRECTION(0x1C),\n            LISTENING_MODE(0x0D),\n            AUTO_ANSWER_MODE(0x1E),\n            CHIME_VOLUME(0x1F),\n            VOLUME_SWIPE_INTERVAL(0x23),\n            CALL_MANAGEMENT_CONFIG(0x24),\n            VOLUME_SWIPE_MODE(0x25),\n            ADAPTIVE_VOLUME_CONFIG(0x26),\n            SOFTWARE_MUTE_CONFIG(0x27),\n            CONVERSATION_DETECT_CONFIG(0x28),\n            SSL(0x29),\n            HEARING_AID(0x2C),\n            AUTO_ANC_STRENGTH(0x2E),\n            HPS_GAIN_SWIPE(0x2F),\n            HRM_STATE(0x30),\n            IN_CASE_TONE_CONFIG(0x31),\n            SIRI_MULTITONE_CONFIG(0x32),\n            HEARING_ASSIST_CONFIG(0x33),\n            ALLOW_OFF_OPTION(0x34),\n            STEM_CONFIG(0x39);\n            companion object {\n                fun fromByte(byte: Byte): ControlCommandIdentifiers? =\n                    entries.find { it.value == byte }\n            }\n        }\n\n        enum class ProximityKeyType(val value: Byte) {\n            IRK(0x01),\n            ENC_KEY(0x04);\n\n            companion object {\n                fun fromByte(byte: Byte): ProximityKeyType =\n                    ProximityKeyType.entries.find { it.value == byte }?: throw IllegalArgumentException(\"Unknown ProximityKeyType: $byte\")\n            }\n        }\n\n        enum class StemPressType(val value: Byte) {\n            SINGLE_PRESS(0x05),\n            DOUBLE_PRESS(0x06),\n            TRIPLE_PRESS(0x07),\n            LONG_PRESS(0x08);\n\n            companion object {\n                fun fromByte(byte: Byte): StemPressType? =\n                    entries.find { it.value == byte }\n            }\n        }\n\n        enum class StemPressBudType(val value: Byte) {\n            LEFT(0x01),\n            RIGHT(0x02);\n\n            companion object {\n                fun fromByte(byte: Byte): StemPressBudType? =\n                    entries.find { it.value == byte }\n            }\n        }\n    }\n    var controlCommandStatusList: MutableList<ControlCommandStatus> = mutableListOf<ControlCommandStatus>()\n    var controlCommandListeners: MutableMap<ControlCommandIdentifiers, MutableList<ControlCommandListener>> = mutableMapOf()\n\n    fun getControlCommandStatus(identifier: ControlCommandIdentifiers): ControlCommandStatus? {\n        return controlCommandStatusList.find { it.identifier == identifier }\n    }\n\n    private fun setControlCommandStatusValue(identifier: ControlCommandIdentifiers, value: ByteArray) {\n        val existingStatus = getControlCommandStatus(identifier)\n        if (existingStatus == value) {\n            controlCommandStatusList.remove(existingStatus)\n        }\n        if (existingStatus != null) {\n            controlCommandStatusList.remove(existingStatus)\n        }\n        controlCommandListeners[identifier]?.forEach { listener ->\n            listener.onControlCommandReceived(ControlCommand(identifier.value, value))\n        }\n        controlCommandStatusList.add(ControlCommandStatus(identifier, value))\n    }\n\n    interface PacketCallback {\n        fun onBatteryInfoReceived(batteryInfo: ByteArray)\n        fun onEarDetectionReceived(earDetection: ByteArray)\n        fun onConversationAwarenessReceived(conversationAwareness: ByteArray)\n        fun onControlCommandReceived(controlCommand: ByteArray)\n        fun onDeviceMetadataReceived(deviceMetadata: ByteArray)\n        fun onHeadTrackingReceived(headTracking: ByteArray)\n        fun onUnknownPacketReceived(packet: ByteArray)\n        fun onProximityKeysReceived(proximityKeys: ByteArray)\n        fun onStemPressReceived(stemPress: ByteArray)\n    }\n\n    fun parseStemPressResponse(data: ByteArray): Pair<StemPressType, StemPressBudType> {\n        Log.d(TAG, \"Parsing Stem Press Response: ${data.joinToString(\" \") { \"%02X\".format(it) }}\")\n        if (data.size != 8) {\n            throw IllegalArgumentException(\"Data array too short to parse Stem Press Response\")\n        }\n        if (data[4] != Opcodes.STEM_PRESS) {\n            throw IllegalArgumentException(\"Data array does not start with STEM_PRESS opcode\")\n        }\n        val type = StemPressType.fromByte(data[6]) ?: throw IllegalArgumentException(\"Unknown Stem Press Type: ${data[5]}\")\n        val bud = StemPressBudType.fromByte(data[7]) ?: throw IllegalArgumentException(\"Unknown Stem Press Bud Type: ${data[6]}\")\n        return Pair(type, bud)\n    }\n\n    interface ControlCommandListener {\n        fun onControlCommandReceived(controlCommand: ControlCommand)\n    }\n\n    fun registerControlCommandListener(identifier: ControlCommandIdentifiers, callback: ControlCommandListener) {\n        controlCommandListeners.getOrPut(identifier) { mutableListOf() }.add(callback)\n    }\n\n    private var callback: PacketCallback? = null\n\n    fun setPacketCallback(callback: PacketCallback) {\n        this.callback = callback\n    }\n\n    fun createDataPacket(data: ByteArray): ByteArray {\n        return HEADER_BYTES + data\n    }\n\n    fun createControlCommandPacket(identifier: Byte, data: ByteArray): ByteArray {\n        val opcode = byteArrayOf(Opcodes.CONTROL_COMMAND, 0x00)\n        val payload = ByteArray(7)\n\n        System.arraycopy(opcode, 0, payload, 0, 2)\n        payload[2] = identifier\n\n        val dataLength = minOf(data.size, 4)\n        System.arraycopy(data, 0, payload, 3, dataLength)\n\n        return payload\n    }\n\n    fun sendDataPacket(data: ByteArray): Boolean {\n        return sendPacket(createDataPacket(data))\n    }\n\n    fun sendControlCommand(identifier: Byte, value: ByteArray): Boolean {\n        val controlPacket = createControlCommandPacket(identifier, value)\n        setControlCommandStatusValue(\n            ControlCommandIdentifiers.fromByte(identifier) ?: return false,\n            value\n        )\n        return sendDataPacket(controlPacket)\n    }\n\n    @OptIn(ExperimentalStdlibApi::class)\n    fun sendControlCommand(identifier: Byte, value: Byte): Boolean {\n        val controlPacket = createControlCommandPacket(identifier, byteArrayOf(value))\n        setControlCommandStatusValue(\n            ControlCommandIdentifiers.fromByte(identifier) ?: return false,\n            byteArrayOf(value)\n        )\n        return sendDataPacket(controlPacket)\n    }\n\n    fun sendControlCommand(identifier: Byte, value: Boolean): Boolean {\n        val controlPacket = createControlCommandPacket(identifier, if (value) byteArrayOf(0x01) else byteArrayOf(0x02))\n        setControlCommandStatusValue(\n            ControlCommandIdentifiers.fromByte(identifier) ?: return false,\n            if (value) byteArrayOf(0x01) else byteArrayOf(0x02)\n        )\n        return sendDataPacket(controlPacket)\n    }\n\n    fun sendControlCommand(identifier: Byte, value: Int): Boolean {\n        val controlPacket = createControlCommandPacket(identifier, byteArrayOf(value.toByte()))\n        setControlCommandStatusValue(\n            ControlCommandIdentifiers.fromByte(identifier) ?: return false,\n            byteArrayOf(value.toByte())\n        )\n        return sendDataPacket(controlPacket)\n    }\n\n    fun parseProximityKeysResponse(data: ByteArray): Map<ProximityKeyType, ByteArray> {\n        Log.d(TAG, \"Parsing Proximity Keys Response: ${data.joinToString(\" \") { \"%02X\".format(it) }}\")\n        if (data.size < 4) {\n            throw IllegalArgumentException(\"Data array too short to parse Proximity Keys Response\")\n        }\n        if (data[4] != Opcodes.PROXIMITY_KEYS_RSP) {\n            throw IllegalArgumentException(\"Data array does not start with PROXIMITY_KEYS_RSP opcode\")\n        }\n        val keyCount = data[6].toInt()\n        val keys = mutableMapOf<ProximityKeyType, ByteArray>()\n        var offset = 7\n        for (i in 0 until keyCount) {\n            Log.d(TAG, \"Parsing Proximity Key $i\")\n            if (offset + 3 >= data.size) {\n                throw IllegalArgumentException(\"Data array too short to parse Proximity Keys Response\")\n            }\n            val keyType = data[offset]\n            val keyLength = data[offset + 2].toInt()\n            Log.d(TAG, \"Key Type: ${keyType.toString(16)}, Key Length: $keyLength\")\n            offset += 4\n            if (offset + keyLength > data.size) {\n                throw IllegalArgumentException(\"Data array too short to parse Proximity Keys Response\")\n            }\n            val key = ByteArray(keyLength)\n            System.arraycopy(data, offset, key, 0, keyLength)\n            keys[ProximityKeyType.fromByte(keyType)] = key\n            offset += keyLength\n            Log.d(TAG, \"Parsed Proximity Key: Type: ${keyType}, Length: $keyLength, Key: ${key.joinToString(\" \") { \"%02X\".format(it) }}\")\n        }\n        return keys\n    }\n\n    fun sendRequestProximityKeys(type: Byte): Boolean {\n        Log.d(TAG, \"Requesting proximity keys of type: ${type.toString(16)}\")\n        return sendDataPacket(createRequestProximityKeysPacket(type))\n    }\n\n    fun createRequestProximityKeysPacket(type: Byte): ByteArray {\n        val opcode = byteArrayOf(Opcodes.PROXIMITY_KEYS_REQ, 0x00)\n        val data = byteArrayOf(type, 0x00)\n        return opcode + data\n    }\n\n    @OptIn(ExperimentalStdlibApi::class)\n    fun receivePacket(packet: ByteArray) {\n        if (!packet.toHexString().startsWith(\"04000400\")) {\n            Log.w(TAG, \"Received packet does not start with expected header: ${packet.joinToString(\" \") { \"%02X\".format(it) }}\")\n            return\n        }\n        if (packet.size < 6) {\n            Log.w(TAG, \"Received packet too short: ${packet.joinToString(\" \") { \"%02X\".format(it) }}\")\n            return\n        }\n\n        val opcode = packet[4]\n\n        when (opcode) {\n            Opcodes.BATTERY_INFO -> {\n                callback?.onBatteryInfoReceived(packet)\n            }\n            Opcodes.CONTROL_COMMAND -> {\n                val controlCommand = ControlCommand.fromByteArray(packet)\n                setControlCommandStatusValue(\n                    ControlCommandIdentifiers.fromByte(controlCommand.identifier) ?: return,\n                    controlCommand.value\n                )\n                Log.d(TAG, \"Control command received: ${controlCommand.identifier.toHexString()} - ${controlCommand.value.joinToString(\" \") { \"%02X\".format(it) }}\")\n                Log.d(TAG, \"Control command list is now: ${\n                    controlCommandStatusList.joinToString(\", \") { \"${it.identifier.name} (${it.identifier.value.toHexString()}) - ${it.value.joinToString(\" \") { \"%02X\".format(it) }}\" }\n                }\")\n\n                val controlCommandIdentifier = ControlCommandIdentifiers.fromByte(controlCommand.identifier)\n                if (controlCommandIdentifier != null) {\n                    controlCommandListeners[controlCommandIdentifier]?.forEach { listener ->\n                        listener.onControlCommandReceived(controlCommand)\n                    }\n                } else {\n                    Log.w(TAG, \"Unknown control command identifier: ${controlCommand.identifier.toHexString()}\")\n                }\n\n                callback?.onControlCommandReceived(packet)\n            }\n            Opcodes.EAR_DETECTION -> {\n                callback?.onEarDetectionReceived(packet)\n            }\n            Opcodes.CONVERSATION_AWARENESS -> {\n                callback?.onConversationAwarenessReceived(packet)\n            }\n            Opcodes.DEVICE_METADATA -> {\n                callback?.onDeviceMetadataReceived(packet)\n            }\n            Opcodes.HEADTRACKING -> {\n                if (packet.size < 70) {\n                    Log.w(TAG, \"Received HEADTRACKING packet too short: ${packet.joinToString(\" \") { \"%02X\".format(it) }}\")\n                    return\n                }\n                callback?.onHeadTrackingReceived(packet)\n            }\n            Opcodes.PROXIMITY_KEYS_RSP -> {\n                callback?.onProximityKeysReceived(packet)\n            }\n            Opcodes.STEM_PRESS -> {\n                callback?.onStemPressReceived(packet)\n            }\n            else -> {\n                callback?.onUnknownPacketReceived(packet)\n            }\n        }\n    }\n\n    fun sendNotificationRequest(): Boolean {\n        return sendDataPacket(createRequestNotificationPacket())\n    }\n\n    fun createRequestNotificationPacket(): ByteArray {\n        val opcode = byteArrayOf(Opcodes.REQUEST_NOTIFICATIONS, 0x00)\n        val data = byteArrayOf(0xFF.toByte(), 0xFF.toByte(), 0xFF.toByte(), 0xFF.toByte())\n        return opcode + data\n    }\n\n    fun sendSetFeatureFlagsPacket(): Boolean {\n        return sendDataPacket(createSetFeatureFlagsPacket())\n    }\n\n    fun createSetFeatureFlagsPacket(): ByteArray {\n        val opcode = byteArrayOf(Opcodes.SET_FEATURE_FLAGS, 0x00)\n        val data = byteArrayOf(0xD7.toByte(), 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)\n        return opcode + data\n    }\n\n    fun createHandshakePacket(): ByteArray {\n        return byteArrayOf(\n            0x00, 0x00, 0x04, 0x00,\n            0x01, 0x00, 0x02, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00\n        )\n    }\n\n    fun sendStartHeadTracking(): Boolean {\n        return sendDataPacket(createStartHeadTrackingPacket())\n    }\n\n    fun createStartHeadTrackingPacket(): ByteArray {\n        val opcode = byteArrayOf(Opcodes.HEADTRACKING, 0x00)\n        val data = byteArrayOf(\n            0x00, 0x00, 0x10, 0x00, 0x10, 0x00, 0x08, 0xA1.toByte(), 0x02, 0x42, 0x0B, 0x08, 0x0E, 0x10, 0x02, 0x1A, 0x05, 0x01, 0x40, 0x9C.toByte(), 0x00, 0x00,\n        )\n        return opcode + data\n    }\n\n    fun createAlternateStartHeadTrackingPacket(): ByteArray {\n        val opcode = byteArrayOf(Opcodes.HEADTRACKING, 0x00)\n        val data = byteArrayOf(\n            0x00, 0x00, 0x10, 0x00, 0x0F, 0x00, 0x08, 0x73, 0x42, 0x0B, 0x08, 0x10, 0x10, 0x02, 0x1A, 0x05, 0x01, 0x40, 0x9C.toByte(), 0x00, 0x00\n        )\n        return opcode + data\n    }\n\n    fun sendStopHeadTracking(): Boolean {\n        return sendDataPacket(createStopHeadTrackingPacket())\n    }\n\n    fun createStopHeadTrackingPacket(): ByteArray {\n        val opcode = byteArrayOf(Opcodes.HEADTRACKING, 0x00)\n        val data = byteArrayOf(\n            0x00, 0x00, 0x10, 0x00, 0x11, 0x00, 0x08, 0x7E, 0x10, 0x02, 0x42, 0x0B, 0x08, 0x4E, 0x10, 0x02, 0x1A, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00\n        )\n        return opcode + data\n    }\n\n    fun createAlternateStopHeadTrackingPacket(): ByteArray {\n        val opcode = byteArrayOf(Opcodes.HEADTRACKING, 0x00)\n        val data = byteArrayOf(\n            0x00, 0x00, 0x10, 0x00, 0x0F, 0x00, 0x08, 0x75, 0x42, 0x0B, 0x08, 0x10, 0x10, 0x02, 0x1A, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00\n        )\n        return opcode + data\n    }\n\n    fun sendRename(name: String): Boolean {\n        return sendDataPacket(createRenamePacket(name))\n    }\n\n    fun createRenamePacket(name: String): ByteArray {\n        val nameBytes = name.toByteArray()\n        val size = nameBytes.size\n        val packet = ByteArray(5 + size)\n        packet[0] = Opcodes.RENAME\n        packet[1] = 0x00\n        packet[2] = size.toByte()\n        packet[3] = 0x00\n        System.arraycopy(nameBytes, 0, packet, 4, size)\n\n        return packet\n    }\n\n\n    data class ControlCommand(\n        val identifier: Byte,\n        val value: ByteArray\n    ) {\n        override fun equals(other: Any?): Boolean {\n            if (this === other) return true\n            if (javaClass != other?.javaClass) return false\n\n            other as ControlCommand\n\n            if (identifier != other.identifier) return false\n            if (!value.contentEquals(other.value)) return false\n\n            return true\n        }\n\n        override fun hashCode(): Int {\n            var result: Int = identifier.toInt()\n            result = 31 * result + value.contentHashCode()\n            return result\n        }\n\n        companion object {\n            fun fromByteArray(data: ByteArray): ControlCommand {\n                if (data.size < 4) {\n                    throw IllegalArgumentException(\"Data array too short to parse ControlCommand\")\n                }\n                if (data[0] == 0x04.toByte() && data[1] == 0x00.toByte() && data[2] == 0x04.toByte() && data[3] == 0x00.toByte()) {\n                    val newData = ByteArray(data.size - 4)\n                    System.arraycopy(data, 4, newData, 0, data.size - 4)\n                    return fromByteArray(newData)\n                }\n                if (data[0] != Opcodes.CONTROL_COMMAND) {\n                    throw IllegalArgumentException(\"Data array does not start with CONTROL_COMMAND opcode\")\n                }\n                val identifier = data[2]\n\n                val value = ByteArray(4)\n                System.arraycopy(data, 3, value, 0, 4)\n\n                val trimmedValue = value.takeWhile { it != 0x00.toByte() }.toByteArray()\n                return ControlCommand(identifier, trimmedValue)\n            }\n        }\n    }\n\n    @OptIn(ExperimentalStdlibApi::class)\n    fun sendStemConfigPacket(\n        singlePressCustomized: Boolean = false,\n        doublePressCustomized: Boolean = false,\n        triplePressCustomized: Boolean = false,\n        longPressCustomized: Boolean = false\n    ): Boolean {\n        val value = ((if (singlePressCustomized) 0x01 else 0) or\n            (if (doublePressCustomized) 0x02 else 0) or\n            (if (triplePressCustomized) 0x04 else 0) or\n            (if (longPressCustomized) 0x08 else 0)).toByte()\n        Log.d(TAG, \"Sending Stem Config Packet with value: ${value.toHexString()}\")\n        return sendControlCommand(\n            ControlCommandIdentifiers.STEM_CONFIG.value, value\n        )\n    }\n\n   @OptIn(ExperimentalStdlibApi::class)\n   fun sendPacket(packet: ByteArray): Boolean {\n        try {\n            Log.d(TAG, \"Sending packet: ${packet.joinToString(\" \") { \"%02X\".format(it) }}\")\n\n            if (packet[4] == Opcodes.CONTROL_COMMAND) {\n                val controlCommand = ControlCommand.fromByteArray(packet)\n                Log.d(TAG, \"Control command: ${controlCommand.identifier.toHexString()} - ${controlCommand.value.joinToString(\" \") { \"%02X\".format(it) }}\")\n                setControlCommandStatusValue(\n                    ControlCommandIdentifiers.fromByte(controlCommand.identifier) ?: return false,\n                    controlCommand.value\n                )\n            }\n\n            val socket = BluetoothConnectionManager.getCurrentSocket()\n            if (socket?.isConnected == true) {\n                socket.outputStream?.write(packet)\n                socket.outputStream?.flush()\n                return true\n            } else {\n                Log.d(TAG, \"Can't send packet: Socket not initialized or connected\")\n                return false\n            }\n        } catch (e: Exception) {\n            Log.e(TAG, \"Error sending packet: ${e.message}\")\n            return false\n        }\n    }\n}\n"
        },
        {
          "name": "IslandWindow.kt",
          "ext": ".kt",
          "size": 27865,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n *\n * Copyright (C) 2025 LibrePods contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\n@file:OptIn(ExperimentalEncodingApi::class)\n\npackage me.kavishdevar.librepods.utils\n\nimport android.animation.Animator\nimport android.animation.AnimatorListenerAdapter\nimport android.animation.ObjectAnimator\nimport android.animation.PropertyValuesHolder\nimport android.animation.ValueAnimator\nimport android.annotation.SuppressLint\nimport android.content.BroadcastReceiver\nimport android.content.Context\nimport android.content.Intent\nimport android.content.IntentFilter\nimport android.content.res.Resources\nimport android.graphics.PixelFormat\nimport android.graphics.drawable.GradientDrawable\nimport android.net.Uri\nimport android.os.Build\nimport android.os.Handler\nimport android.os.Looper\nimport android.util.Log.e\nimport android.view.Gravity\nimport android.view.LayoutInflater\nimport android.view.MotionEvent\nimport android.view.VelocityTracker\nimport android.view.View\nimport android.view.WindowManager\nimport android.view.animation.AccelerateInterpolator\nimport android.view.animation.AnticipateOvershootInterpolator\nimport android.view.animation.DecelerateInterpolator\nimport android.view.animation.OvershootInterpolator\nimport android.widget.FrameLayout\nimport android.widget.LinearLayout\nimport android.widget.ProgressBar\nimport android.widget.TextView\nimport android.widget.VideoView\nimport androidx.core.content.ContextCompat.getString\nimport androidx.dynamicanimation.animation.DynamicAnimation\nimport androidx.dynamicanimation.animation.SpringAnimation\nimport androidx.dynamicanimation.animation.SpringForce\nimport me.kavishdevar.librepods.R\nimport me.kavishdevar.librepods.constants.AirPodsNotifications\nimport me.kavishdevar.librepods.constants.Battery\nimport me.kavishdevar.librepods.constants.BatteryComponent\nimport me.kavishdevar.librepods.constants.BatteryStatus\nimport me.kavishdevar.librepods.services.ServiceManager\nimport kotlin.io.encoding.ExperimentalEncodingApi\nimport kotlin.math.abs\n\nenum class IslandType {\n    CONNECTED,\n    TAKING_OVER,\n    MOVED_TO_REMOTE,\n}\n\nclass IslandWindow(private val context: Context) {\n    private val windowManager: WindowManager = context.getSystemService(Context.WINDOW_SERVICE) as WindowManager\n    @SuppressLint(\"InflateParams\")\n    private val islandView: View = LayoutInflater.from(context).inflate(R.layout.island_window, null)\n    private var isClosing = false\n    private var params: WindowManager.LayoutParams? = null\n\n    private var initialY = 0f\n    private var initialTouchY = 0f\n    private var lastTouchY = 0f\n    private var velocityTracker: VelocityTracker? = null\n    private var isBeingDragged = false\n    private var autoCloseHandler: Handler? = null\n    private var autoCloseRunnable: Runnable? = null\n    private var initialHeight = 0\n    private var screenHeight = 0\n    private var isDraggingDown = false\n    private var lastMoveTime = 0L\n    private var yMovement = 0f\n    private var dragDistance = 0f\n\n    private var initialConnectedTextY = 0f\n    private var initialDeviceTextY = 0f\n    private var initialBatteryViewY = 0f\n    private var initialVideoViewY = 0f\n    private var initialTextSeparation = 0f\n\n    private val containerView = FrameLayout(context)\n\n    private lateinit var springAnimation: SpringAnimation\n    private val flingAnimator = ValueAnimator()\n\n    private val batteryReceiver = object : BroadcastReceiver() {\n        override fun onReceive(context: Context?, intent: Intent?) {\n            if (intent?.action == AirPodsNotifications.BATTERY_DATA) {\n                val batteryList = intent.getParcelableArrayListExtra<Battery>(\"data\")\n                updateBatteryDisplay(batteryList)\n            } else if (intent?.action == AirPodsNotifications.DISCONNECT_RECEIVERS) {\n                try {\n                    context?.unregisterReceiver(this)\n                } catch (e: Exception) {\n                    e.printStackTrace()\n                }\n            }\n        }\n    }\n\n    val isVisible: Boolean\n        get() = containerView.parent != null && containerView.visibility == View.VISIBLE\n\n    @SuppressLint(\"SetTextI18n\")\n    private fun updateBatteryDisplay(batteryList: ArrayList<Battery>?) {\n        if (batteryList == null || batteryList.isEmpty()) return\n\n        val leftBattery = batteryList.find { it.component == BatteryComponent.LEFT }\n        val rightBattery = batteryList.find { it.component == BatteryComponent.RIGHT }\n\n        val leftLevel = leftBattery?.level ?: 0\n        val rightLevel = rightBattery?.level ?: 0\n        val leftStatus = leftBattery?.status ?: BatteryStatus.DISCONNECTED\n        val rightStatus = rightBattery?.status ?: BatteryStatus.DISCONNECTED\n\n        val batteryText = islandView.findViewById<TextView>(R.id.island_battery_text)\n        val batteryProgressBar = islandView.findViewById<ProgressBar>(R.id.island_battery_progress)\n\n        val displayBatteryLevel = when {\n            leftLevel > 0 && rightLevel > 0 -> minOf(leftLevel, rightLevel)\n            leftLevel > 0 -> leftLevel\n            rightLevel > 0 -> rightLevel\n            else -> null\n        }\n\n        if (displayBatteryLevel != null) {\n            batteryText.text = \"$displayBatteryLevel%\"\n            batteryProgressBar.progress = displayBatteryLevel\n            batteryProgressBar.isIndeterminate = false\n        } else {\n            batteryText.text = \"?\"\n            batteryProgressBar.progress = 0\n            batteryProgressBar.isIndeterminate = false\n        }\n    }\n\n    @SuppressLint(\"SetTextI18s\", \"ClickableViewAccessibility\", \"UnspecifiedRegisterReceiverFlag\")\n    fun show(name: String, batteryPercentage: Int, context: Context, type: IslandType = IslandType.CONNECTED) {\n        if (ServiceManager.getService()?.islandOpen == true) return\n        else ServiceManager.getService()?.islandOpen = true\n\n        val displayMetrics = Resources.getSystem().displayMetrics\n        val width = (displayMetrics.widthPixels * 0.95).toInt()\n        screenHeight = displayMetrics.heightPixels\n\n        val batteryList = ServiceManager.getService()?.getBattery()\n        val batteryText = islandView.findViewById<TextView>(R.id.island_battery_text)\n        val batteryProgressBar = islandView.findViewById<ProgressBar>(R.id.island_battery_progress)\n\n        val displayBatteryLevel = if (batteryList != null) {\n            val leftBattery = batteryList.find { it.component == BatteryComponent.LEFT }\n            val rightBattery = batteryList.find { it.component == BatteryComponent.RIGHT }\n\n            when {\n                leftBattery?.level ?: 0 > 0 && rightBattery?.level ?: 0 > 0 ->\n                    minOf(leftBattery!!.level, rightBattery!!.level)\n                leftBattery?.level ?: 0 > 0 -> leftBattery!!.level\n                rightBattery?.level ?: 0 > 0 -> rightBattery!!.level\n                batteryPercentage > 0 -> batteryPercentage\n                else -> null\n            }\n        } else if (batteryPercentage > 0) {\n            batteryPercentage\n        } else {\n            null\n        }\n\n        if (displayBatteryLevel != null) {\n            batteryText.text = \"$displayBatteryLevel%\"\n            batteryProgressBar.progress = displayBatteryLevel\n        } else {\n            batteryText.text = \"?\"\n            batteryProgressBar.progress = 0\n        }\n\n        batteryProgressBar.isIndeterminate = false\n        islandView.findViewById<TextView>(R.id.island_device_name).text = name\n\n        val batteryIntentFilter = IntentFilter(AirPodsNotifications.BATTERY_DATA)\n        batteryIntentFilter.addAction(AirPodsNotifications.DISCONNECT_RECEIVERS)\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\n            context.registerReceiver(batteryReceiver, batteryIntentFilter, Context.RECEIVER_EXPORTED)\n        } else {\n            context.registerReceiver(batteryReceiver, batteryIntentFilter)\n        }\n\n        ServiceManager.getService()?.sendBatteryBroadcast()\n\n        containerView.removeAllViews()\n        val containerParams = FrameLayout.LayoutParams(\n            FrameLayout.LayoutParams.MATCH_PARENT,\n            FrameLayout.LayoutParams.WRAP_CONTENT\n        )\n        containerView.addView(islandView, containerParams)\n\n        params = WindowManager.LayoutParams(\n            width,\n            WindowManager.LayoutParams.WRAP_CONTENT,\n            WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY,\n            WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL,\n            PixelFormat.TRANSLUCENT\n        ).apply {\n            gravity = Gravity.TOP or Gravity.CENTER_HORIZONTAL\n        }\n\n        islandView.visibility = View.VISIBLE\n        containerView.visibility = View.VISIBLE\n\n        containerView.setOnTouchListener { _, event ->\n            when (event.action) {\n                MotionEvent.ACTION_DOWN -> {\n                    autoCloseHandler?.removeCallbacks(autoCloseRunnable ?: return@setOnTouchListener false)\n                    flingAnimator.cancel()\n\n                    velocityTracker?.recycle()\n                    velocityTracker = VelocityTracker.obtain()\n                    velocityTracker?.addMovement(event)\n\n                    initialY = containerView.translationY\n                    initialTouchY = event.rawY\n                    lastTouchY = event.rawY\n                    initialHeight = islandView.height\n                    isBeingDragged = false\n                    isDraggingDown = false\n                    lastMoveTime = System.currentTimeMillis()\n                    dragDistance = 0f\n\n                    captureInitialPositions()\n\n                    true\n                }\n                MotionEvent.ACTION_MOVE -> {\n                    velocityTracker?.addMovement(event)\n                    val deltaY = event.rawY - initialTouchY\n                    val moveDelta = event.rawY - lastTouchY\n                    dragDistance += abs(moveDelta)\n\n                    isDraggingDown = moveDelta > 0\n\n                    val currentTime = System.currentTimeMillis()\n                    val timeDelta = currentTime - lastMoveTime\n                    if (timeDelta > 0) {\n                        yMovement = moveDelta / timeDelta * 10\n                    }\n                    lastMoveTime = currentTime\n\n                    if (abs(deltaY) > 5 || isBeingDragged) {\n                        isBeingDragged = true\n\n                        // Cancel auto close timer when dragging starts\n                        autoCloseHandler?.removeCallbacks(autoCloseRunnable ?: return@setOnTouchListener false)\n\n                        val dampedDeltaY = if (deltaY > 0) {\n                            initialY + (deltaY * 0.6f)\n                        } else {\n                            initialY + (deltaY * 0.9f)\n                        }\n                        containerView.translationY = dampedDeltaY\n\n                        if (isDraggingDown && deltaY > 0) {\n                            val stretchAmount = (deltaY * 0.5f).coerceAtMost(200f)\n                            applyCustomStretchEffect(stretchAmount, deltaY)\n                        }\n                    }\n\n                    lastTouchY = event.rawY\n                    true\n                }\n                MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -> {\n                    velocityTracker?.addMovement(event)\n                    velocityTracker?.computeCurrentVelocity(1000)\n                    val yVelocity = velocityTracker?.yVelocity ?: 0f\n\n                    if (isBeingDragged) {\n                        val currentTranslationY = containerView.translationY\n                        val significantVelocity = abs(yVelocity) > 800\n                        val significantDrag = abs(dragDistance) > 80\n\n                        when {\n                            yVelocity < -1200 || (currentTranslationY < -80 && !isDraggingDown) -> {\n                                animateDismissWithInertia(yVelocity)\n                            }\n                            yVelocity > 1200 || (isDraggingDown && significantDrag) -> {\n                                animateExpandWithStretch(yVelocity)\n                            }\n                            else -> {\n                                springBackWithInertia(yVelocity)\n                            }\n                        }\n                    } else if (dragDistance < 10) {\n                        resetAutoCloseTimer()\n                    }\n\n                    velocityTracker?.recycle()\n                    velocityTracker = null\n                    isBeingDragged = false\n                    true\n                }\n                else -> false\n            }\n        }\n\n        when (type) {\n            IslandType.CONNECTED -> {\n                islandView.findViewById<TextView>(R.id.island_connected_text).text = getString(context, R.string.island_connected_text)\n            }\n            IslandType.TAKING_OVER -> {\n                islandView.findViewById<TextView>(R.id.island_connected_text).text = getString(context, R.string.island_taking_over_text)\n            }\n            IslandType.MOVED_TO_REMOTE -> {\n                islandView.findViewById<TextView>(R.id.island_connected_text).text = getString(context, R.string.island_moved_to_remote_text)\n            }\n        }\n\n        val videoView = islandView.findViewById<VideoView>(R.id.island_video_view)\n        val videoUri = Uri.parse(\"android.resource://me.kavishdevar.librepods/${R.raw.island}\")\n        videoView.setVideoURI(videoUri)\n        videoView.setOnPreparedListener { mediaPlayer ->\n            mediaPlayer.isLooping = true\n            videoView.start()\n        }\n\n        windowManager.addView(containerView, params)\n\n        islandView.post {\n            initialHeight = islandView.height\n            captureInitialPositions()\n        }\n\n        springAnimation = SpringAnimation(containerView, DynamicAnimation.TRANSLATION_Y, 0f).apply {\n            spring = SpringForce(0f)\n                .setDampingRatio(SpringForce.DAMPING_RATIO_MEDIUM_BOUNCY)\n                .setStiffness(SpringForce.STIFFNESS_MEDIUM)\n        }\n\n        val scaleX = PropertyValuesHolder.ofFloat(View.SCALE_X, 0.5f, 1f)\n        val scaleY = PropertyValuesHolder.ofFloat(View.SCALE_Y, 0.5f, 1f)\n        val translationY = PropertyValuesHolder.ofFloat(View.TRANSLATION_Y, -200f, 0f)\n        ObjectAnimator.ofPropertyValuesHolder(containerView, scaleX, scaleY, translationY).apply {\n            duration = 700\n            interpolator = AnticipateOvershootInterpolator()\n            start()\n        }\n\n        resetAutoCloseTimer()\n    }\n\n    private fun captureInitialPositions() {\n        val connectedText = islandView.findViewById<TextView>(R.id.island_connected_text)\n        val deviceText = islandView.findViewById<TextView>(R.id.island_device_name)\n        val batteryView = islandView.findViewById<FrameLayout>(R.id.island_battery_container)\n        val videoView = islandView.findViewById<VideoView>(R.id.island_video_view)\n\n        connectedText.post {\n            initialConnectedTextY = connectedText.y\n            initialDeviceTextY = deviceText.y\n            initialTextSeparation = deviceText.y - (connectedText.y + connectedText.height)\n\n            if (batteryView != null) initialBatteryViewY = batteryView.y\n            initialVideoViewY = videoView.y\n        }\n    }\n\n    private fun applyCustomStretchEffect(stretchAmount: Float, dragY: Float) {\n        try {\n            val mainLayout = islandView.findViewById<LinearLayout>(R.id.island_window_layout)\n            val connectedText = islandView.findViewById<TextView>(R.id.island_connected_text)\n            val deviceText = islandView.findViewById<TextView>(R.id.island_device_name)\n            val batteryView = islandView.findViewById<FrameLayout>(R.id.island_battery_container)\n            val videoView = islandView.findViewById<VideoView>(R.id.island_video_view)\n\n            val stretchFactor = 1f + (stretchAmount / 300f).coerceAtMost(4.0f)\n            val newMinHeight = (initialHeight * stretchFactor).toInt()\n            mainLayout.minimumHeight = newMinHeight\n\n            val textMarginIncrease = (stretchAmount * 0.8f).toInt()\n\n            val deviceTextParams = deviceText.layoutParams as LinearLayout.LayoutParams\n            deviceTextParams.topMargin = textMarginIncrease\n            deviceText.layoutParams = deviceTextParams\n\n            val background = mainLayout.background\n            if (background is GradientDrawable) {\n                val cornerRadius = 56f\n                background.cornerRadius = cornerRadius\n            }\n\n            if (params != null) {\n                params!!.height = screenHeight\n\n                val containerParams = containerView.layoutParams\n                containerParams.height = screenHeight\n                containerView.layoutParams = containerParams\n\n                try {\n                    windowManager.updateViewLayout(containerView, params)\n                } catch (e: Exception) {\n                    e.printStackTrace()\n                }\n            }\n        } catch (e: Exception) {\n            e.printStackTrace()\n        }\n    }\n\n    private fun resetAutoCloseTimer() {\n        autoCloseHandler?.removeCallbacks(autoCloseRunnable ?: return)\n        autoCloseHandler = Handler(Looper.getMainLooper())\n        autoCloseRunnable = Runnable { close() }\n        autoCloseHandler?.postDelayed(autoCloseRunnable!!, 4500)\n    }\n\n    private fun springBackWithInertia(velocity: Float) {\n        springAnimation.cancel()\n        flingAnimator.cancel()\n\n        springAnimation.setStartVelocity(velocity)\n\n        val baseStiffness = SpringForce.STIFFNESS_MEDIUM\n        val dynamicStiffness = baseStiffness * (1f + (abs(velocity) / 3000f))\n        springAnimation.spring = SpringForce(0f)\n            .setDampingRatio(SpringForce.DAMPING_RATIO_MEDIUM_BOUNCY)\n            .setStiffness(dynamicStiffness)\n\n        resetStretchEffects(velocity)\n\n        if (params != null) {\n            params!!.height = WindowManager.LayoutParams.WRAP_CONTENT\n            try {\n                windowManager.updateViewLayout(containerView, params)\n            } catch (e: Exception) {\n                e.printStackTrace()\n            }\n        }\n\n        springAnimation.start()\n    }\n\n    private fun resetStretchEffects(velocity: Float) {\n        try {\n            val mainLayout = islandView.findViewById<LinearLayout>(R.id.island_window_layout)\n            val deviceText = islandView.findViewById<TextView>(R.id.island_device_name)\n\n            val heightAnimator = ValueAnimator.ofInt(mainLayout.minimumHeight, initialHeight)\n            heightAnimator.duration = 300\n            heightAnimator.interpolator = OvershootInterpolator(1.5f)\n            heightAnimator.addUpdateListener { animation ->\n                mainLayout.minimumHeight = animation.animatedValue as Int\n            }\n\n            val deviceTextParams = deviceText.layoutParams as LinearLayout.LayoutParams\n            val textMarginAnimator = ValueAnimator.ofInt(deviceTextParams.topMargin, 0)\n            textMarginAnimator.duration = 300\n            textMarginAnimator.interpolator = OvershootInterpolator(1.5f)\n            textMarginAnimator.addUpdateListener { animation ->\n                deviceTextParams.topMargin = animation.animatedValue as Int\n                deviceText.layoutParams = deviceTextParams\n            }\n\n            heightAnimator.start()\n            textMarginAnimator.start()\n        } catch (e: Exception) {\n            e.printStackTrace()\n        }\n    }\n\n    private fun animateDismissWithInertia(velocity: Float) {\n        springAnimation.cancel()\n        flingAnimator.cancel()\n\n        val baseDistance = -screenHeight\n        val velocityFactor = (abs(velocity) / 2000f).coerceIn(0.5f, 2.0f)\n        val targetDistance = baseDistance * velocityFactor\n\n        val baseDuration = 400L\n        val velocityDurationFactor = (1500f / (abs(velocity) + 1500f))\n        val duration = (baseDuration * velocityDurationFactor).toLong().coerceIn(200L, 500L)\n\n        flingAnimator.setFloatValues(containerView.translationY, targetDistance)\n        flingAnimator.duration = duration\n        flingAnimator.addUpdateListener { animation ->\n            containerView.translationY = animation.animatedValue as Float\n\n            val progress = animation.animatedFraction\n            containerView.scaleX = 1f - (progress * 0.5f)\n            containerView.scaleY = 1f - (progress * 0.5f)\n\n            containerView.alpha = 1f - progress\n        }\n        flingAnimator.addListener(object : AnimatorListenerAdapter() {\n            override fun onAnimationEnd(animation: Animator) {\n                forceClose()\n            }\n        })\n\n        flingAnimator.interpolator = DecelerateInterpolator(1.2f)\n        flingAnimator.start()\n    }\n\n    private fun animateExpandWithStretch(velocity: Float) {\n        springAnimation.cancel()\n        flingAnimator.cancel()\n\n        val baseDuration = 600L\n        val velocityFactor = (1800f / (abs(velocity) + 1800f)).coerceIn(0.5f, 1.5f)\n        val expandDuration = (baseDuration * velocityFactor).toLong().coerceIn(300L, 700L)\n\n        if (params != null) {\n            params!!.height = screenHeight\n            try {\n                windowManager.updateViewLayout(containerView, params)\n            } catch (e: Exception) {\n                e.printStackTrace()\n            }\n        }\n\n        val containerAnimator = ValueAnimator.ofFloat(containerView.translationY, screenHeight * 0.6f)\n        containerAnimator.duration = expandDuration\n        containerAnimator.interpolator = DecelerateInterpolator(0.8f)\n        containerAnimator.addUpdateListener { animation ->\n            containerView.translationY = animation.animatedValue as Float\n        }\n\n        val stretchAnimator = ValueAnimator.ofFloat(0f, 1f)\n        stretchAnimator.duration = expandDuration\n        stretchAnimator.interpolator = OvershootInterpolator(0.5f)\n        stretchAnimator.addUpdateListener { animation ->\n            val progress = animation.animatedValue as Float\n            animateCustomStretch(progress, expandDuration)\n        }\n\n        val normalizeAnimator = ValueAnimator.ofFloat(1.0f, 0.0f)\n        normalizeAnimator.duration = 300\n        normalizeAnimator.startDelay = expandDuration - 150\n        normalizeAnimator.interpolator = AccelerateInterpolator(1.2f)\n        normalizeAnimator.addUpdateListener { animation ->\n            val progress = animation.animatedValue as Float\n            containerView.alpha = progress\n\n            if (progress < 0.7f) {\n                islandView.findViewById<VideoView>(R.id.island_video_view).visibility = View.GONE\n            }\n        }\n        normalizeAnimator.addListener(object : AnimatorListenerAdapter() {\n            override fun onAnimationEnd(animation: Animator) {\n                ServiceManager.getService()?.startMainActivity()\n                forceClose()\n            }\n        })\n\n        containerAnimator.start()\n        stretchAnimator.start()\n        normalizeAnimator.start()\n    }\n\n    private fun animateCustomStretch(progress: Float, duration: Long) {\n        try {\n            val mainLayout = islandView.findViewById<LinearLayout>(R.id.island_window_layout)\n            val connectedText = islandView.findViewById<TextView>(R.id.island_connected_text)\n            val deviceText = islandView.findViewById<TextView>(R.id.island_device_name)\n\n            val targetHeight = (screenHeight * 0.7f).toInt()\n            val currentHeight = initialHeight + ((targetHeight - initialHeight) * progress)\n            mainLayout.minimumHeight = currentHeight.toInt()\n\n            val mainLayoutParams = mainLayout.layoutParams\n            mainLayoutParams.height = LinearLayout.LayoutParams.MATCH_PARENT\n            mainLayout.layoutParams = mainLayoutParams\n\n            val targetMargin = (400 * progress).toInt()\n            val deviceTextParams = deviceText.layoutParams as LinearLayout.LayoutParams\n            deviceTextParams.topMargin = targetMargin\n            deviceText.layoutParams = deviceTextParams\n\n            val baseTextSize = 24f\n            deviceText.textSize = baseTextSize + (progress * 8f)\n\n            val baseSubTextSize = 16f\n            connectedText.textSize = baseSubTextSize + (progress * 4f)\n        } catch (e: Exception) {\n            e.printStackTrace()\n        }\n    }\n\n    fun close() {\n        try {\n            if (isClosing) return\n            isClosing = true\n\n            try {\n                context.unregisterReceiver(batteryReceiver)\n            } catch (e: Exception) {\n                e.printStackTrace()\n            }\n\n            ServiceManager.getService()?.islandOpen = false\n            autoCloseHandler?.removeCallbacks(autoCloseRunnable ?: return)\n\n            resetStretchEffects(0f)\n\n            val videoView = islandView.findViewById<VideoView>(R.id.island_video_view)\n            try {\n                videoView.stopPlayback()\n            } catch (e: Exception) {\n                e.printStackTrace()\n            }\n\n            val scaleX = PropertyValuesHolder.ofFloat(View.SCALE_X, containerView.scaleX, 0.5f)\n            val scaleY = PropertyValuesHolder.ofFloat(View.SCALE_Y, containerView.scaleY, 0.5f)\n            val translationY = PropertyValuesHolder.ofFloat(View.TRANSLATION_Y, containerView.translationY, -200f)\n            ObjectAnimator.ofPropertyValuesHolder(containerView, scaleX, scaleY, translationY).apply {\n                duration = 700\n                interpolator = AnticipateOvershootInterpolator()\n                addListener(object : AnimatorListenerAdapter() {\n                    override fun onAnimationEnd(animation: Animator) {\n                        cleanupAndRemoveView()\n                    }\n                })\n                start()\n            }\n        } catch (e: Exception) {\n            e.printStackTrace()\n            // Even if animation fails, ensure we cleanup\n            cleanupAndRemoveView()\n        }\n    }\n\n    private fun cleanupAndRemoveView() {\n        containerView.visibility = View.GONE\n        try {\n            if (containerView.parent != null) {\n                windowManager.removeView(containerView)\n            }\n        } catch (e: Exception) {\n            e(\"IslandWindow\", \"Error removing view: $e\")\n        }\n        isClosing = false\n        // Make sure all animations are canceled\n        springAnimation.cancel()\n        flingAnimator.cancel()\n    }\n\n    fun forceClose() {\n        try {\n            if (isClosing) return\n            isClosing = true\n\n            try {\n                context.unregisterReceiver(batteryReceiver)\n            } catch (e: Exception) {\n                // Silent catch - receiver might already be unregistered\n            }\n\n            ServiceManager.getService()?.islandOpen = false\n            autoCloseHandler?.removeCallbacks(autoCloseRunnable ?: return)\n\n            // Cancel all ongoing animations\n            springAnimation.cancel()\n            flingAnimator.cancel()\n\n            // Immediately remove the view without animations\n            cleanupAndRemoveView()\n        } catch (e: Exception) {\n            e.printStackTrace()\n            isClosing = false\n        }\n    }\n}\n"
        },
        {
          "name": "SystemAPIUtils.kt",
          "ext": ".kt",
          "size": 8378,
          "preview": "package me.kavishdevar.librepods.utils\n\nimport android.bluetooth.BluetoothDevice\nimport android.util.Log\nimport org.lsposed.hiddenapibypass.HiddenApiBypass\n\nobject SystemApisUtils {\n\n    /**\n     * Device type which is used in METADATA_DEVICE_TYPE\n     * Indicates this Bluetooth device is an untethered headset.\n     * @hide\n     */\n    val BluetoothDevice.DEVICE_TYPE_UNTETHERED_HEADSET: String\n        get() = \"Untethered Headset\"\n\n    /**\n     * Maximum length of a metadata entry, this is to avoid exploding Bluetooth\n     * disk usage\n     * @hide\n     */\n    val BluetoothDevice.METADATA_MAX_LENGTH: Int\n        get() = 2048\n\n    /**\n     * Manufacturer name of this Bluetooth device\n     * Data type should be {@String} as [Byte] array.\n     * @hide\n     */\n    val BluetoothDevice.METADATA_MANUFACTURER_NAME: Int\n        get() = 0\n\n    /**\n     * Model name of this Bluetooth device\n     * Data type should be {@String} as [Byte] array.\n     * @hide\n     */\n    val BluetoothDevice.METADATA_MODEL_NAME: Int\n        get() = 1\n\n    /**\n     * Software version of this Bluetooth device\n     * Data type should be {@String} as [Byte] array.\n     * @hide\n     */\n    val BluetoothDevice.METADATA_SOFTWARE_VERSION: Int\n        get() = 2\n\n    /**\n     * Hardware version of this Bluetooth device\n     * Data type should be {@String} as [Byte] array.\n     * @hide\n     */\n    val BluetoothDevice.METADATA_HARDWARE_VERSION: Int\n        get() = 3\n\n    /**\n     * Package name of the companion app, if any\n     * Data type should be {@String} as [Byte] array.\n     * @hide\n     */\n    val BluetoothDevice.METADATA_COMPANION_APP: Int\n        get() = 4\n\n    /**\n     * URI to the main icon shown on the settings UI\n     * Data type should be [Byte] array.\n     * @hide\n     */\n    val BluetoothDevice.METADATA_MAIN_ICON: Int\n        get() = 5\n\n    /**\n     * Whether this device is an untethered headset with left, right and case\n     * Data type should be {@String} as [Byte] array.\n     * @hide\n     */\n    val BluetoothDevice.METADATA_IS_UNTETHERED_HEADSET: Int\n        get() = 6\n\n    /**\n     * URI to icon of the left headset\n     * Data type should be [Byte] array.\n     * @hide\n     */\n    val BluetoothDevice.METADATA_UNTETHERED_LEFT_ICON: Int\n        get() = 7\n\n    /**\n     * URI to icon of the right headset\n     * Data type should be [Byte] array.\n     * @hide\n     */\n    val BluetoothDevice.METADATA_UNTETHERED_RIGHT_ICON: Int\n        get() = 8\n\n    /**\n     * URI to icon of the headset charging case\n     * Data type should be [Byte] array.\n     * @hide\n     */\n    val BluetoothDevice.METADATA_UNTETHERED_CASE_ICON: Int\n        get() = 9\n\n    /**\n     * Battery level of left headset\n     * Data type should be {@String} 0-100 as [Byte] array, otherwise\n     * as invalid.\n     * @hide\n     */\n    val BluetoothDevice.METADATA_UNTETHERED_LEFT_BATTERY: Int\n        get() = 10\n\n    /**\n     * Battery level of rigth headset\n     * Data type should be {@String} 0-100 as [Byte] array, otherwise\n     * as invalid.\n     * @hide\n     */\n    val BluetoothDevice.METADATA_UNTETHERED_RIGHT_BATTERY: Int\n        get() = 11\n\n    /**\n     * Battery level of the headset charging case\n     * Data type should be {@String} 0-100 as [Byte] array, otherwise\n     * as invalid.\n     * @hide\n     */\n    val BluetoothDevice.METADATA_UNTETHERED_CASE_BATTERY: Int\n        get() = 12\n\n    /**\n     * Whether the left headset is charging\n     * Data type should be {@String} as [Byte] array.\n     * @hide\n     */\n    val BluetoothDevice.METADATA_UNTETHERED_LEFT_CHARGING: Int\n        get() = 13\n\n    /**\n     * Whether the right headset is charging\n     * Data type should be {@String} as [Byte] array.\n     * @hide\n     */\n    val BluetoothDevice.METADATA_UNTETHERED_RIGHT_CHARGING: Int\n        get() = 14\n\n    /**\n     * Whether the headset charging case is charging\n     * Data type should be {@String} as [Byte] array.\n     * @hide\n     */\n    val BluetoothDevice.METADATA_UNTETHERED_CASE_CHARGING: Int\n        get() = 15\n\n    /**\n     * URI to the enhanced settings UI slice\n     * Data type should be {@String} as [Byte] array, null means\n     * the UI does not exist.\n     * @hide\n     */\n    val BluetoothDevice.METADATA_ENHANCED_SETTINGS_UI_URI: Int\n        get() = 16\n\n    /**\n     * @hide\n     */\n    val BluetoothDevice.COMPANION_TYPE_PRIMARY: String\n        get() = \"COMPANION_PRIMARY\"\n\n    /**\n     * @hide\n     */\n    val BluetoothDevice.COMPANION_TYPE_SECONDARY: String\n        get() = \"COMPANION_SECONDARY\"\n\n    /**\n     * @hide\n     */\n    val BluetoothDevice.COMPANION_TYPE_NONE: String\n        get() = \"COMPANION_NONE\"\n\n    /**\n     * Type of the Bluetooth device, must be within the list of\n     * BluetoothDevice.DEVICE_TYPE_*\n     * Data type should be {@String} as [Byte] array.\n     * @hide\n     */\n    val BluetoothDevice.METADATA_DEVICE_TYPE: Int\n        get() = 17\n\n    /**\n     * Battery level of the Bluetooth device, use when the Bluetooth device\n     * does not support HFP battery indicator.\n     * Data type should be {@String} as [Byte] array.\n     * @hide\n     */\n    val BluetoothDevice.METADATA_MAIN_BATTERY: Int\n        get() = 18\n\n    /**\n     * Whether the device is charging.\n     * Data type should be {@String} as [Byte] array.\n     * @hide\n     */\n    val BluetoothDevice.METADATA_MAIN_CHARGING: Int\n        get() = 19\n\n    /**\n     * The battery threshold of the Bluetooth device to show low battery icon.\n     * Data type should be {@String} as [Byte] array.\n     * @hide\n     */\n    val BluetoothDevice.METADATA_MAIN_LOW_BATTERY_THRESHOLD: Int\n        get() = 20\n\n    /**\n     * The battery threshold of the left headset to show low battery icon.\n     * Data type should be {@String} as [Byte] array.\n     * @hide\n     */\n    val BluetoothDevice.METADATA_UNTETHERED_LEFT_LOW_BATTERY_THRESHOLD: Int\n        get() = 21\n\n    /**\n     * The battery threshold of the right headset to show low battery icon.\n     * Data type should be {@String} as [Byte] array.\n     * @hide\n     */\n    val BluetoothDevice.METADATA_UNTETHERED_RIGHT_LOW_BATTERY_THRESHOLD: Int\n        get() = 22\n\n    /**\n     * The battery threshold of the case to show low battery icon.\n     * Data type should be {@String} as [Byte] array.\n     * @hide\n     */\n    val BluetoothDevice.METADATA_UNTETHERED_CASE_LOW_BATTERY_THRESHOLD: Int\n        get() = 23\n\n\n    /**\n     * The metadata of the audio spatial data.\n     * Data type should be [Byte] array.\n     * @hide\n     */\n    val BluetoothDevice.METADATA_SPATIAL_AUDIO: Int\n        get() = 24\n\n    /**\n     * The metadata of the Fast Pair for any custmized feature.\n     * Data type should be [Byte] array.\n     * @hide\n     */\n    val BluetoothDevice.METADATA_FAST_PAIR_CUSTOMIZED_FIELDS: Int\n        get() = 25\n\n    /**\n     * The metadata of the Fast Pair for LE Audio capable devices.\n     * Data type should be [Byte] array.\n     * @hide\n     */\n    val BluetoothDevice.METADATA_LE_AUDIO: Int\n        get() = 26\n\n    /**\n     * The UUIDs (16-bit) of registered to CCC characteristics from Media Control services.\n     * Data type should be [Byte] array.\n     * @hide\n     */\n    val BluetoothDevice.METADATA_GMCS_CCCD: Int\n        get() = 27\n\n    /**\n     * The UUIDs (16-bit) of registered to CCC characteristics from Telephony Bearer service.\n     * Data type should be [Byte] array.\n     * @hide\n     */\n    val BluetoothDevice.METADATA_GTBS_CCCD: Int\n        get() = 28\n\n    const val BATTERY_LEVEL_UNKNOWN: Int = -1\n\n    const val ACTION_BLUETOOTH_HANDSFREE_BATTERY_CHANGED = \"android.intent.action.BLUETOOTH_HANDSFREE_BATTERY_CHANGED\"\n    const val EXTRA_SHOW_BT_HANDSFREE_BATTERY = \"android.intent.extra.show_bluetooth_handsfree_battery\"\n    const val EXTRA_BT_HANDSFREE_BATTERY_LEVEL = \"android.intent.extra.bluetooth_handsfree_battery_level\"\n\n    /**\n     * Helper method to set metadata using HiddenApiBypass\n     */\n     fun setMetadata(device: BluetoothDevice, key: Int, value: ByteArray): Boolean {\n        return try {\n            val result = HiddenApiBypass.invoke(\n                BluetoothDevice::class.java,\n                device,\n                \"setMetadata\",\n                key,\n                value\n            ) as Boolean\n            result\n        } catch (e: Exception) {\n            Log.e(\"SystemApisUtils\", \"Failed to set metadata for key $key\", e)\n            false\n        }\n    }\n}\n"
        },
        {
          "name": "BLEManager.kt",
          "ext": ".kt",
          "size": 19483,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple's ecosystem\n *\n * Copyright (C) 2025 LibrePods Contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\npackage me.kavishdevar.librepods.utils\n\nimport android.annotation.SuppressLint\nimport android.bluetooth.BluetoothManager\nimport android.bluetooth.le.BluetoothLeScanner\nimport android.bluetooth.le.ScanCallback\nimport android.bluetooth.le.ScanFilter\nimport android.bluetooth.le.ScanResult\nimport android.bluetooth.le.ScanSettings\nimport android.content.Context\nimport android.content.SharedPreferences\nimport android.os.Handler\nimport android.os.Looper\nimport android.util.Log\nimport me.kavishdevar.librepods.services.ServiceManager\nimport javax.crypto.Cipher\nimport javax.crypto.spec.SecretKeySpec\nimport kotlin.io.encoding.Base64\nimport kotlin.io.encoding.ExperimentalEncodingApi\n\n/**\n * Manager for Bluetooth Low Energy scanning operations specifically for AirPods\n */\n@OptIn(ExperimentalEncodingApi::class)\nclass BLEManager(private val context: Context) {\n\n    data class AirPodsStatus(\n        val address: String,\n        val lastSeen: Long = System.currentTimeMillis(),\n        val paired: Boolean = false,\n        val model: String = \"Unknown\",\n        val leftBattery: Int? = null,\n        val rightBattery: Int? = null,\n        val caseBattery: Int? = null,\n        val isLeftInEar: Boolean = false,\n        val isRightInEar: Boolean = false,\n        val isLeftCharging: Boolean = false,\n        val isRightCharging: Boolean = false,\n        val isCaseCharging: Boolean = false,\n        val lidOpen: Boolean = false,\n        val color: String = \"Unknown\",\n        val connectionState: String = \"Unknown\"\n    )\n\n    fun getMostRecentStatus(): AirPodsStatus? {\n        return deviceStatusMap.values.maxByOrNull { it.lastSeen }\n    }\n\n    interface AirPodsStatusListener {\n        fun onDeviceStatusChanged(device: AirPodsStatus, previousStatus: AirPodsStatus?)\n        fun onBroadcastFromNewAddress(device: AirPodsStatus)\n        fun onLidStateChanged(lidOpen: Boolean)\n        fun onEarStateChanged(device: AirPodsStatus, leftInEar: Boolean, rightInEar: Boolean)\n        fun onBatteryChanged(device: AirPodsStatus)\n    }\n\n    private var mBluetoothLeScanner: BluetoothLeScanner? = null\n    private var mScanCallback: ScanCallback? = null\n    private var airPodsStatusListener: AirPodsStatusListener? = null\n    private val deviceStatusMap = mutableMapOf<String, AirPodsStatus>()\n    private val verifiedAddresses = mutableSetOf<String>()\n    private val sharedPreferences: SharedPreferences = context.getSharedPreferences(\"settings\", Context.MODE_PRIVATE)\n    private var currentGlobalLidState: Boolean? = null\n    private var lastBroadcastTime: Long = 0\n    private val processedAddresses = mutableSetOf<String>()\n\n    private val lastValidCaseBatteryMap = mutableMapOf<String, Int>()\n    private val modelNames = mapOf(\n        0x0E20 to \"AirPods Pro\",\n        0x1420 to \"AirPods Pro 2\",\n        0x2420 to \"AirPods Pro 2 (USB-C)\",\n        0x0220 to \"AirPods 1\",\n        0x0F20 to \"AirPods 2\",\n        0x1320 to \"AirPods 3\",\n        0x1920 to \"AirPods 4\",\n        0x1B20 to \"AirPods 4 (ANC)\",\n        0x0A20 to \"AirPods Max\",\n        0x1F20 to \"AirPods Max (USB-C)\"\n    )\n\n    val colorNames = mapOf(\n        0x00 to \"White\", 0x01 to \"Black\", 0x02 to \"Red\", 0x03 to \"Blue\",\n        0x04 to \"Pink\", 0x05 to \"Gray\", 0x06 to \"Silver\", 0x07 to \"Gold\",\n        0x08 to \"Rose Gold\", 0x09 to \"Space Gray\", 0x0A to \"Dark Blue\",\n        0x0B to \"Light Blue\", 0x0C to \"Yellow\"\n    )\n\n    val connStates = mapOf(\n        0x00 to \"Disconnected\", 0x04 to \"Idle\", 0x05 to \"Music\",\n        0x06 to \"Call\", 0x07 to \"Ringing\", 0x09 to \"Hanging Up\", 0xFF to \"Unknown\"\n    )\n\n    private val cleanupHandler = Handler(Looper.getMainLooper())\n    private val cleanupRunnable = object : Runnable {\n        override fun run() {\n            cleanupStaleDevices()\n            checkLidStateTimeout()\n            cleanupHandler.postDelayed(this, CLEANUP_INTERVAL_MS)\n        }\n    }\n\n    fun setAirPodsStatusListener(listener: AirPodsStatusListener) {\n        airPodsStatusListener = listener\n    }\n\n    @SuppressLint(\"MissingPermission\")\n    fun startScanning() {\n        try {\n            Log.d(TAG, \"Starting BLE scanner\")\n\n            val btManager = context.getSystemService(Context.BLUETOOTH_SERVICE) as BluetoothManager\n            val btAdapter = btManager.adapter\n\n            if (btAdapter == null) {\n                Log.d(TAG, \"No Bluetooth adapter available\")\n                return\n            }\n\n            if (mBluetoothLeScanner != null && mScanCallback != null) {\n                mBluetoothLeScanner?.stopScan(mScanCallback)\n                mScanCallback = null\n            }\n\n            if (!btAdapter.isEnabled) {\n                Log.d(TAG, \"Bluetooth is disabled\")\n                return\n            }\n\n            mBluetoothLeScanner = btAdapter.bluetoothLeScanner\n\n            val scanSettings = ScanSettings.Builder()\n                .setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY)\n                .setMatchMode(ScanSettings.MATCH_MODE_AGGRESSIVE)\n                .setCallbackType(ScanSettings.CALLBACK_TYPE_ALL_MATCHES)\n                .setNumOfMatches(ScanSettings.MATCH_NUM_MAX_ADVERTISEMENT)\n                .setReportDelay(500L)\n                .build()\n\n            val manufacturerData = ByteArray(27)\n            val manufacturerDataMask = ByteArray(27)\n\n            manufacturerData[0] = 7\n            manufacturerData[1] = 25\n\n            manufacturerDataMask[0] = -1\n            manufacturerDataMask[1] = -1\n\n            val scanFilter = ScanFilter.Builder()\n                .setManufacturerData(76, manufacturerData, manufacturerDataMask)\n                .build()\n\n            mScanCallback = object : ScanCallback() {\n                override fun onScanResult(callbackType: Int, result: ScanResult) {\n                    processScanResult(result)\n                }\n\n                override fun onBatchScanResults(results: List<ScanResult>) {\n                    processedAddresses.clear()\n                    for (result in results) {\n                        processScanResult(result)\n                    }\n                }\n\n                override fun onScanFailed(errorCode: Int) {\n                    Log.e(TAG, \"BLE scan failed with error code: $errorCode\")\n                }\n            }\n\n            mBluetoothLeScanner?.startScan(listOf(scanFilter), scanSettings, mScanCallback)\n            Log.d(TAG, \"BLE scanner started successfully\")\n\n            cleanupHandler.postDelayed(cleanupRunnable, CLEANUP_INTERVAL_MS)\n        } catch (t: Throwable) {\n            Log.e(TAG, \"Error starting BLE scanner\", t)\n        }\n    }\n\n    @SuppressLint(\"MissingPermission\")\n    fun stopScanning() {\n        try {\n            if (mBluetoothLeScanner != null && mScanCallback != null) {\n                Log.d(TAG, \"Stopping BLE scanner\")\n                mBluetoothLeScanner?.stopScan(mScanCallback)\n                mScanCallback = null\n            }\n\n            cleanupHandler.removeCallbacks(cleanupRunnable)\n        } catch (t: Throwable) {\n            Log.e(TAG, \"Error stopping BLE scanner\", t)\n        }\n    }\n\n    @OptIn(ExperimentalEncodingApi::class)\n    private fun getEncryptionKeyFromPreferences(): ByteArray? {\n        val keyBase64 = sharedPreferences.getString(AACPManager.Companion.ProximityKeyType.ENC_KEY.name, null)\n        return if (keyBase64 != null) {\n            try {\n                Base64.decode(keyBase64)\n            } catch (e: Exception) {\n                Log.e(TAG, \"Failed to decode encryption key\", e)\n                null\n            }\n        } else {\n            null\n        }\n    }\n\n    private fun decryptLastBytes(data: ByteArray, key: ByteArray): ByteArray? {\n        return try {\n            if (data.size < 16) {\n                return null\n            }\n            \n            val block = data.copyOfRange(data.size - 16, data.size)\n            val cipher = Cipher.getInstance(\"AES/ECB/NoPadding\")\n            val secretKey = SecretKeySpec(key, \"AES\")\n            cipher.init(Cipher.DECRYPT_MODE, secretKey)\n            cipher.doFinal(block)\n        } catch (e: Exception) {\n            Log.e(TAG, \"Error decrypting data\", e)\n            null\n        }\n    }\n\n    private fun formatBattery(byteVal: Int): Pair<Boolean, Int> {\n        val charging = (byteVal and 0x80) != 0\n        val level = byteVal and 0x7F\n        return Pair(charging, level)\n    }\n\n    private fun processScanResult(result: ScanResult) {\n        try {\n            val scanRecord = result.scanRecord ?: return\n            val address = result.device.address\n\n            if (processedAddresses.contains(address)) {\n                return\n            }\n\n            val manufacturerData = scanRecord.getManufacturerSpecificData(76) ?: return\n            if (manufacturerData.size <= 20) return\n\n            if (!verifiedAddresses.contains(address)) {\n                val irk = getIrkFromPreferences()\n                if (irk == null || !BluetoothCryptography.verifyRPA(address, irk)) {\n                    return\n                }\n                verifiedAddresses.add(address)\n                Log.d(TAG, \"RPA verified and added to trusted list: $address\")\n            }\n\n            processedAddresses.add(address)\n            lastBroadcastTime = System.currentTimeMillis()\n\n            val encryptionKey = getEncryptionKeyFromPreferences()\n            val decryptedData = if (encryptionKey != null) decryptLastBytes(manufacturerData, encryptionKey) else null\n            val parsedStatus = if (decryptedData != null && decryptedData.size == 16) {\n                parseProximityMessageWithDecryption(address, manufacturerData, decryptedData)\n            } else {\n                parseProximityMessage(address, manufacturerData)\n            }\n\n            val previousStatus = deviceStatusMap[address]\n            deviceStatusMap[address] = parsedStatus\n\n            airPodsStatusListener?.let { listener ->\n                if (previousStatus == null) {\n                    listener.onBroadcastFromNewAddress(parsedStatus)\n                    Log.d(TAG, \"New AirPods device detected: $address\")\n\n                    if (currentGlobalLidState == null || currentGlobalLidState != parsedStatus.lidOpen) {\n                        currentGlobalLidState = parsedStatus.lidOpen\n                        listener.onLidStateChanged(parsedStatus.lidOpen)\n                        Log.d(TAG, \"Lid state ${if (parsedStatus.lidOpen) \"opened\" else \"closed\"} (detected from new device)\")\n                    }\n                } else {\n                    if (parsedStatus != previousStatus) {\n                        listener.onDeviceStatusChanged(parsedStatus, previousStatus)\n                    }\n\n                    if (parsedStatus.lidOpen != previousStatus.lidOpen) {\n                        val previousGlobalState = currentGlobalLidState\n                        currentGlobalLidState = parsedStatus.lidOpen\n\n                        if (previousGlobalState != parsedStatus.lidOpen) {\n                            listener.onLidStateChanged(parsedStatus.lidOpen)\n                            Log.d(TAG, \"Lid state changed from ${previousGlobalState} to ${parsedStatus.lidOpen}\")\n                        }\n                    }\n\n                    if (parsedStatus.isLeftInEar != previousStatus.isLeftInEar ||\n                        parsedStatus.isRightInEar != previousStatus.isRightInEar) {\n                        listener.onEarStateChanged(\n                            parsedStatus,\n                            parsedStatus.isLeftInEar,\n                            parsedStatus.isRightInEar\n                        )\n                        Log.d(TAG, \"Ear state changed - Left: ${parsedStatus.isLeftInEar}, Right: ${parsedStatus.isRightInEar}\")\n                    }\n\n                    if (parsedStatus.leftBattery != previousStatus.leftBattery ||\n                        parsedStatus.rightBattery != previousStatus.rightBattery ||\n                        parsedStatus.caseBattery != previousStatus.caseBattery) {\n                        listener.onBatteryChanged(parsedStatus)\n                        Log.d(TAG, \"Battery changed - Left: ${parsedStatus.leftBattery}, Right: ${parsedStatus.rightBattery}, Case: ${parsedStatus.caseBattery}\")\n                    }\n                }\n            }\n        } catch (t: Throwable) {\n            Log.e(TAG, \"Error processing scan result\", t)\n        }\n    }\n\n    private fun parseProximityMessageWithDecryption(address: String, data: ByteArray, decrypted: ByteArray): AirPodsStatus {\n        val paired = data[2].toInt() == 1\n        val modelId = ((data[3].toInt() and 0xFF) shl 8) or (data[4].toInt() and 0xFF)\n        val model = modelNames[modelId] ?: \"Unknown ($modelId)\"\n\n        val status = data[5].toInt() and 0xFF\n        val flagsCase = data[7].toInt() and 0xFF\n        val lid = data[8].toInt() and 0xFF\n        val color = colorNames[data[9].toInt()] ?: \"Unknown\"\n        val conn = connStates[data[10].toInt()] ?: \"Unknown (${data[10].toInt()})\"\n\n        val primaryLeft = ((status shr 5) and 0x01) == 1\n        val thisInCase = ((status shr 6) and 0x01) == 1\n        val xorFactor = primaryLeft xor thisInCase\n\n        val isLeftInEar = if (xorFactor) (status and 0x08) != 0 else (status and 0x02) != 0\n        val isRightInEar = if (xorFactor) (status and 0x02) != 0 else (status and 0x08) != 0\n\n        val isFlipped = !primaryLeft\n        \n        val leftByteIndex = if (isFlipped) 2 else 1\n        val rightByteIndex = if (isFlipped) 1 else 2\n        \n        val (isLeftCharging, leftBattery) = formatBattery(decrypted[leftByteIndex].toInt() and 0xFF)\n        val (isRightCharging, rightBattery) = formatBattery(decrypted[rightByteIndex].toInt() and 0xFF)\n        \n        val rawCaseBatteryByte = decrypted[3].toInt() and 0xFF\n        val (isCaseCharging, rawCaseBattery) = formatBattery(rawCaseBatteryByte)\n\n        val caseBattery = if (rawCaseBatteryByte == 0xFF || (isCaseCharging && rawCaseBattery == 127)) {\n            lastValidCaseBatteryMap[address]\n        } else {\n            lastValidCaseBatteryMap[address] = rawCaseBattery\n            rawCaseBattery\n        }\n\n        val lidOpen = ((lid shr 3) and 0x01) == 0\n\n        return AirPodsStatus(\n            address = address,\n            lastSeen = System.currentTimeMillis(),\n            paired = paired,\n            model = model,\n            leftBattery = leftBattery,\n            rightBattery = rightBattery,\n            caseBattery = caseBattery,\n            isLeftInEar = isLeftInEar,\n            isRightInEar = isRightInEar,\n            isLeftCharging = isLeftCharging,\n            isRightCharging = isRightCharging,\n            isCaseCharging = isCaseCharging,\n            lidOpen = lidOpen,\n            color = color,\n            connectionState = conn\n        )\n    }\n\n    private fun cleanupStaleDevices() {\n        val now = System.currentTimeMillis()\n        val staleCutoff = now - STALE_DEVICE_TIMEOUT_MS\n\n        val staleDevices = deviceStatusMap.filter { it.value.lastSeen < staleCutoff }\n\n        for (device in staleDevices) {\n            deviceStatusMap.remove(device.key)\n            Log.d(TAG, \"Removed stale device from tracking: ${device.key}\")\n        }\n    }\n\n    private fun checkLidStateTimeout() {\n        val currentTime = System.currentTimeMillis()\n        if (currentTime - lastBroadcastTime > LID_CLOSE_TIMEOUT_MS && currentGlobalLidState == true) {\n            Log.d(TAG, \"No broadcasts for ${LID_CLOSE_TIMEOUT_MS}ms, forcing lid state to closed\")\n            currentGlobalLidState = false\n            airPodsStatusListener?.onLidStateChanged(false)\n        }\n    }\n\n    @OptIn(ExperimentalEncodingApi::class)\n    private fun getIrkFromPreferences(): ByteArray? {\n        val irkBase64 = sharedPreferences.getString(AACPManager.Companion.ProximityKeyType.IRK.name, null)\n        return if (irkBase64 != null) {\n            try {\n                Base64.decode(irkBase64)\n            } catch (e: Exception) {\n                Log.e(TAG, \"Failed to decode IRK\", e)\n                null\n            }\n        } else {\n            null\n        }\n    }\n\n    private fun parseProximityMessage(address: String, data: ByteArray): AirPodsStatus {\n        val paired = data[2].toInt() == 1\n        val modelId = ((data[3].toInt() and 0xFF) shl 8) or (data[4].toInt() and 0xFF)\n        val model = modelNames[modelId] ?: \"Unknown ($modelId)\"\n\n        val status = data[5].toInt() and 0xFF\n        val podsBattery = data[6].toInt() and 0xFF\n        val flagsCase = data[7].toInt() and 0xFF\n        val lid = data[8].toInt() and 0xFF\n        val color = colorNames[data[9].toInt()] ?: \"Unknown\"\n        val conn = connStates[data[10].toInt()] ?: \"Unknown (${data[10].toInt()})\"\n\n        val primaryLeft = ((status shr 5) and 0x01) == 1\n        val thisInCase = ((status shr 6) and 0x01) == 1\n        val xorFactor = primaryLeft xor thisInCase\n\n        val isLeftInEar = if (xorFactor) (status and 0x08) != 0 else (status and 0x02) != 0\n        val isRightInEar = if (xorFactor) (status and 0x02) != 0 else (status and 0x08) != 0\n\n        val isFlipped = !primaryLeft\n        \n        val leftBatteryNibble = if (isFlipped) (podsBattery shr 4) and 0x0F else podsBattery and 0x0F\n        val rightBatteryNibble = if (isFlipped) podsBattery and 0x0F else (podsBattery shr 4) and 0x0F\n        \n        val caseBattery = flagsCase and 0x0F\n        val flags = (flagsCase shr 4) and 0x0F\n\n        val isLeftCharging = if (isFlipped) (flags and 0x02) != 0 else (flags and 0x01) != 0\n        val isRightCharging = if (isFlipped) (flags and 0x01) != 0 else (flags and 0x02) != 0\n        val isCaseCharging = (flags and 0x04) != 0\n\n        val lidOpen = ((lid shr 3) and 0x01) == 0\n\n        fun decodeBattery(n: Int): Int? = when (n) {\n            in 0x0..0x9 -> n * 10\n            in 0xA..0xE -> 100\n            0xF -> null\n            else -> null\n        }\n\n        return AirPodsStatus(\n            address = address,\n            lastSeen = System.currentTimeMillis(),\n            paired = paired,\n            model = model,\n            leftBattery = decodeBattery(leftBatteryNibble),\n            rightBattery = decodeBattery(rightBatteryNibble),\n            caseBattery = decodeBattery(caseBattery),\n            isLeftInEar = isLeftInEar,\n            isRightInEar = isRightInEar,\n            isLeftCharging = isLeftCharging,\n            isRightCharging = isRightCharging,\n            isCaseCharging = isCaseCharging,\n            lidOpen = lidOpen,\n            color = color,\n            connectionState = conn\n        )\n    }\n\n    companion object {\n        private const val TAG = \"AirPodsBLE\"\n        private const val CLEANUP_INTERVAL_MS = 30000L\n        private const val STALE_DEVICE_TIMEOUT_MS = 60000L\n        private const val LID_CLOSE_TIMEOUT_MS = 2000L\n    }\n}\n"
        },
        {
          "name": "LogCollector.kt",
          "ext": ".kt",
          "size": 8620,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple's ecosystem\n *\n * Copyright (C) 2025 LibrePods contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\npackage me.kavishdevar.librepods.utils\n\nimport android.content.Context\nimport android.content.Intent\nimport android.net.Uri\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.withContext\nimport java.io.BufferedReader\nimport java.io.File\nimport java.io.InputStreamReader\n\nclass LogCollector(private val context: Context) {\n    private var isCollecting = false\n    private var logProcess: Process? = null\n    \n    suspend fun openXposedSettings(context: Context) {\n        withContext(Dispatchers.IO) {\n            val command = if (android.os.Build.VERSION.SDK_INT >= 29) {\n                \"am broadcast -a android.telephony.action.SECRET_CODE -d android_secret_code://5776733 android\"\n            } else {\n                \"am broadcast -a android.provider.Telephony.SECRET_CODE -d android_secret_code://5776733 android\"\n            }\n            \n            executeRootCommand(command)\n        }\n    }\n    \n    suspend fun clearLogs() {\n        withContext(Dispatchers.IO) {\n            executeRootCommand(\"logcat -c\")\n        }\n    }\n    \n    suspend fun killBluetoothService() {\n        withContext(Dispatchers.IO) {\n            executeRootCommand(\"killall com.android.bluetooth\")\n        }\n    }\n    \n    private suspend fun getPackageUIDs(): Pair<String?, String?> {\n        return withContext(Dispatchers.IO) {\n            val btUid = executeRootCommand(\"dumpsys package com.android.bluetooth | grep -m 1 \\\"uid=\\\" | sed -E 's/.*uid=([0-9]+).*/\\\\1/'\")\n                .trim()\n                .takeIf { it.isNotEmpty() }\n            \n            val appUid = executeRootCommand(\"dumpsys package me.kavishdevar.librepods | grep -m 1 \\\"uid=\\\" | sed -E 's/.*uid=([0-9]+).*/\\\\1/'\")\n                .trim()\n                .takeIf { it.isNotEmpty() }\n            \n            Pair(btUid, appUid)\n        }\n    }\n    \n    suspend fun startLogCollection(listener: (String) -> Unit, connectionDetectedCallback: () -> Unit): String {\n        return withContext(Dispatchers.IO) {\n            isCollecting = true\n            val (btUid, appUid) = getPackageUIDs()\n            \n            val uidFilter = buildString {\n                if (!btUid.isNullOrEmpty() && !appUid.isNullOrEmpty()) {\n                    append(\"$btUid,$appUid\")\n                } else if (!btUid.isNullOrEmpty()) {\n                    append(btUid)\n                } else if (!appUid.isNullOrEmpty()) {\n                    append(appUid)\n                }\n            }\n            \n            val command = if (uidFilter.isNotEmpty()) {\n                \"su -c logcat --uid=$uidFilter -v threadtime\"\n            } else {\n                \"su -c logcat -v threadtime\"\n            }\n            \n            val logs = StringBuilder()\n            try {\n                logProcess = Runtime.getRuntime().exec(command)\n                val reader = BufferedReader(InputStreamReader(logProcess!!.inputStream))\n                var line: String? = null\n                var connectionDetected = false\n                \n                while (isCollecting && reader.readLine().also { line = it } != null) {\n                    line?.let {\n                        if (it.contains(\"<LogCollector:\")) {\n                            logs.append(\"\\n=============\\n\")\n                        }\n                        \n                        logs.append(it).append(\"\\n\")\n                        listener(it)\n                        \n                        if (it.contains(\"<LogCollector:\")) {\n                            logs.append(\"=============\\n\\n\")\n                        }\n                        \n                        if (!connectionDetected) {\n                            if (it.contains(\"<LogCollector:Complete:Success>\")) {\n                                connectionDetected = true\n                                connectionDetectedCallback()\n                            } else if (it.contains(\"<LogCollector:Complete:Failed>\")) {\n                                connectionDetected = true\n                                connectionDetectedCallback()\n                            } else if (it.contains(\"<LogCollector:Start>\")) {\n                            } \n                            else if (it.contains(\"AirPodsService\") && it.contains(\"Connected to device\")) {\n                                connectionDetected = true\n                                connectionDetectedCallback()\n                            } else if (it.contains(\"AirPodsService\") && it.contains(\"Connection failed\")) {\n                                connectionDetected = true\n                                connectionDetectedCallback()\n                            } else if (it.contains(\"AirPodsService\") && it.contains(\"Device disconnected\")) {\n                            }\n                            else if (it.contains(\"BluetoothService\") && it.contains(\"CONNECTION_STATE_CONNECTED\")) {\n                                connectionDetected = true\n                                connectionDetectedCallback()\n                            } else if (it.contains(\"BluetoothService\") && it.contains(\"CONNECTION_STATE_DISCONNECTED\")) {\n                            }\n                        }\n                    }\n                }\n            } catch (e: Exception) {\n                logs.append(\"Error collecting logs: ${e.message}\").append(\"\\n\")\n                e.printStackTrace()\n            }\n            \n            logs.toString()\n        }\n    }\n    \n    fun stopLogCollection() {\n        isCollecting = false\n        logProcess?.destroy()\n        logProcess = null\n    }\n    \n    suspend fun saveLogToInternalStorage(fileName: String, content: String): File? {\n        return withContext(Dispatchers.IO) {\n            try {\n                val logsDir = File(context.filesDir, \"logs\")\n                if (!logsDir.exists()) {\n                    logsDir.mkdir()\n                }\n                \n                val file = File(logsDir, fileName)\n                file.writeText(content)\n                return@withContext file\n            } catch (e: Exception) {\n                e.printStackTrace()\n                return@withContext null\n            }\n        }\n    }\n    \n    suspend fun addLogMarker(markerType: LogMarkerType, details: String = \"\") {\n        withContext(Dispatchers.IO) {\n            val timestamp = java.text.SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\", java.util.Locale.US)\n                .format(java.util.Date())\n            \n            val marker = when (markerType) {\n                LogMarkerType.START -> \"<LogCollector:Start> [$timestamp] Beginning connection test\"\n                LogMarkerType.SUCCESS -> \"<LogCollector:Complete:Success> [$timestamp] Connection test completed successfully\"\n                LogMarkerType.FAILURE -> \"<LogCollector:Complete:Failed> [$timestamp] Connection test failed\"\n                LogMarkerType.CUSTOM -> \"<LogCollector:Custom:$details> [$timestamp]\"\n            }\n            \n            val command = \"log -t AirPodsService \\\"$marker\\\"\"\n            executeRootCommand(command)\n        }\n    }\n    \n    enum class LogMarkerType {\n        START,\n        SUCCESS,\n        FAILURE,\n        CUSTOM\n    }\n    \n    private suspend fun executeRootCommand(command: String): String {\n        return withContext(Dispatchers.IO) {\n            try {\n                val process = Runtime.getRuntime().exec(\"su -c $command\")\n                val reader = BufferedReader(InputStreamReader(process.inputStream))\n                val output = StringBuilder()\n                var line: String?\n                \n                while (reader.readLine().also { line = it } != null) {\n                    output.append(line).append(\"\\n\")\n                }\n                \n                process.waitFor()\n                output.toString()\n            } catch (e: Exception) {\n                e.printStackTrace()\n                \"\"\n            }\n        }\n    }\n}\n"
        },
        {
          "name": "HeadOrientation.kt",
          "ext": ".kt",
          "size": 2884,
          "preview": "package me.kavishdevar.librepods.utils\n\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlin.math.roundToInt\n\ndata class Orientation(val pitch: Float = 0f, val yaw: Float = 0f)\ndata class Acceleration(val vertical: Float = 0f, val horizontal: Float = 0f)\n\nobject HeadTracking {\n    private val _orientation = MutableStateFlow(Orientation())\n    val orientation = _orientation.asStateFlow()\n\n    private val _acceleration = MutableStateFlow(Acceleration())\n    val acceleration = _acceleration.asStateFlow()\n\n    private val calibrationSamples = mutableListOf<Triple<Int, Int, Int>>()\n    private var isCalibrated = false\n    private var o1Neutral = 19000\n    private var o2Neutral = 0\n    private var o3Neutral = 0\n\n    private const val CALIBRATION_SAMPLE_COUNT = 10\n    private const val ORIENTATION_OFFSET = 5500\n\n    fun processPacket(packet: ByteArray) {\n        val o1 = bytesToInt(packet[43], packet[44])\n        val o2 = bytesToInt(packet[45], packet[46])\n        val o3 = bytesToInt(packet[47], packet[48])\n\n        val horizontalAccel = bytesToInt(packet[51], packet[52]).toFloat()\n        val verticalAccel = bytesToInt(packet[53], packet[54]).toFloat()\n\n        if (!isCalibrated) {\n            calibrationSamples.add(Triple(o1, o2, o3))\n            if (calibrationSamples.size >= CALIBRATION_SAMPLE_COUNT) {\n                calibrate()\n            }\n            return\n        }\n\n        val orientation = calculateOrientation(o1, o2, o3)\n        _orientation.value = orientation\n\n        _acceleration.value = Acceleration(verticalAccel, horizontalAccel)\n    }\n\n    private fun calibrate() {\n        if (calibrationSamples.size < 3) return\n\n        // Add offset during calibration\n        o1Neutral = calibrationSamples.map { it.first + ORIENTATION_OFFSET }.average().roundToInt()\n        o2Neutral = calibrationSamples.map { it.second + ORIENTATION_OFFSET }.average().roundToInt()\n        o3Neutral = calibrationSamples.map { it.third + ORIENTATION_OFFSET }.average().roundToInt()\n\n        isCalibrated = true\n    }\n\n    @Suppress(\"UnusedVariable\")\n    private fun calculateOrientation(o1: Int, o2: Int, o3: Int): Orientation {\n        if (!isCalibrated) return Orientation()\n\n        val o1Norm = (o1 + ORIENTATION_OFFSET) - o1Neutral\n        val o2Norm = (o2 + ORIENTATION_OFFSET) - o2Neutral\n        val o3Norm = (o3 + ORIENTATION_OFFSET) - o3Neutral\n\n        val pitch = (o2Norm + o3Norm) / 2f / 32000f * 180f\n        val yaw = (o2Norm - o3Norm) / 2f / 32000f * 180f\n\n        return Orientation(pitch, yaw)\n    }\n\n    private fun bytesToInt(b1: Byte, b2: Byte): Int {\n        return (b2.toInt() shl 8) or (b1.toInt() and 0xFF)\n    }\n\n    fun reset() {\n        calibrationSamples.clear()\n        isCalibrated = false\n        _orientation.value = Orientation()\n        _acceleration.value = Acceleration()\n    }\n}\n"
        },
        {
          "name": "SettingsManager.kt",
          "ext": ".kt",
          "size": 665,
          "preview": "package me.kavishdevar.librepods.utils\n\nimport android.content.Context\nimport android.content.SharedPreferences\n\nobject SettingsManager {\n    private const val PREFS_NAME = \"settings\"\n    private const val KEY_USE_COC = \"use_coc\"\n\n    fun setUseCoc(context: Context, enabled: Boolean) {\n        val prefs: SharedPreferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)\n        prefs.edit().putBoolean(KEY_USE_COC, enabled).apply()\n    }\n\n    fun isUseCoc(context: Context): Boolean {\n        val prefs: SharedPreferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)\n        return prefs.getBoolean(KEY_USE_COC, true)\n    }\n}\n"
        },
        {
          "name": "MediaController.kt",
          "ext": ".kt",
          "size": 10125,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n *\n * Copyright (C) 2025 LibrePods contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\n@file:OptIn(ExperimentalEncodingApi::class)\n\npackage me.kavishdevar.librepods.utils\n\nimport android.content.SharedPreferences\nimport android.media.AudioManager\nimport android.media.AudioPlaybackConfiguration\nimport android.os.Build\nimport android.os.Handler\nimport android.os.Looper\nimport android.util.Log\nimport android.view.KeyEvent\nimport androidx.annotation.RequiresApi\nimport me.kavishdevar.librepods.services.ServiceManager\nimport kotlin.io.encoding.ExperimentalEncodingApi\n\nobject MediaController {\n    private var initialVolume: Int? = null\n    private lateinit var audioManager: AudioManager\n    var iPausedTheMedia = false\n    var userPlayedTheMedia = false\n    private lateinit var sharedPreferences: SharedPreferences\n    private val handler = Handler(Looper.getMainLooper())\n    private lateinit var preferenceChangeListener: SharedPreferences.OnSharedPreferenceChangeListener\n\n    var pausedForCrossDevice = false\n\n    private var relativeVolume: Boolean = false\n    private var conversationalAwarenessVolume: Int = 2\n    private var conversationalAwarenessPauseMusic: Boolean = false\n\n    fun initialize(audioManager: AudioManager, sharedPreferences: SharedPreferences) {\n        if (this::audioManager.isInitialized) {\n            return\n        }\n        this.audioManager = audioManager\n        this.sharedPreferences = sharedPreferences\n        Log.d(\"MediaController\", \"Initializing MediaController\")\n        relativeVolume = sharedPreferences.getBoolean(\"relative_conversational_awareness_volume\", false)\n        conversationalAwarenessVolume = sharedPreferences.getInt(\"conversational_awareness_volume\", (audioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC) / 0.4).toInt())\n        conversationalAwarenessPauseMusic = sharedPreferences.getBoolean(\"conversational_awareness_pause_music\", false)\n\n        preferenceChangeListener = SharedPreferences.OnSharedPreferenceChangeListener { _, key ->\n            when (key) {\n                \"relative_conversational_awareness_volume\" -> {\n                    relativeVolume = sharedPreferences.getBoolean(\"relative_conversational_awareness_volume\", false)\n                }\n                \"conversational_awareness_volume\" -> {\n                    conversationalAwarenessVolume = sharedPreferences.getInt(\"conversational_awareness_volume\", (audioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC) * 0.4).toInt())\n                }\n                \"conversational_awareness_pause_music\" -> {\n                    conversationalAwarenessPauseMusic = sharedPreferences.getBoolean(\"conversational_awareness_pause_music\", false)\n                }\n            }\n        }\n\n        sharedPreferences.registerOnSharedPreferenceChangeListener(preferenceChangeListener)\n\n        audioManager.registerAudioPlaybackCallback(cb, null)\n    }\n\n    val cb = object : AudioManager.AudioPlaybackCallback() {\n        @RequiresApi(Build.VERSION_CODES.R)\n        override fun onPlaybackConfigChanged(configs: MutableList<AudioPlaybackConfiguration>?) {\n            super.onPlaybackConfigChanged(configs)\n            Log.d(\"MediaController\", \"Playback config changed, iPausedTheMedia: $iPausedTheMedia\")\n            if (configs != null && !iPausedTheMedia) {\n                Log.d(\"MediaController\", \"Seems like the user changed the state of media themselves, now I won't play until the ear detection pauses it.\")\n                handler.postDelayed({\n                    userPlayedTheMedia = audioManager.isMusicActive\n                }, 7) // i have no idea why android sends an event a hundred times after the user does something.\n            }\n            Log.d(\"MediaController\", \"pausedforcrossdevice: $pausedForCrossDevice\")\n            if (!pausedForCrossDevice && audioManager.isMusicActive) {\n                ServiceManager.getService()?.takeOver(\"music\")\n            }\n        }\n    }\n\n    @Synchronized\n    fun getMusicActive(): Boolean {\n        return audioManager.isMusicActive\n    }\n\n    @Synchronized\n    fun sendPlayPause() {\n        if (audioManager.isMusicActive) {\n            Log.d(\"MediaController\", \"Sending pause because music is active\")\n            sendPause()\n        } else {\n            Log.d(\"MediaController\", \"Sending play because music is not active\")\n            sendPlay()\n        }\n    }\n\n    @Synchronized\n    fun sendPreviousTrack() {\n        Log.d(\"MediaController\", \"Sending previous track\")\n        audioManager.dispatchMediaKeyEvent(\n            KeyEvent(\n                KeyEvent.ACTION_DOWN,\n                KeyEvent.KEYCODE_MEDIA_PREVIOUS\n            )\n        )\n        audioManager.dispatchMediaKeyEvent(\n            KeyEvent(\n                KeyEvent.ACTION_UP,\n                KeyEvent.KEYCODE_MEDIA_PREVIOUS\n            )\n        )\n    }\n\n    @Synchronized\n    fun sendNextTrack() {\n        Log.d(\"MediaController\", \"Sending next track\")\n        audioManager.dispatchMediaKeyEvent(\n            KeyEvent(\n                KeyEvent.ACTION_DOWN,\n                KeyEvent.KEYCODE_MEDIA_NEXT\n            )\n        )\n        audioManager.dispatchMediaKeyEvent(\n            KeyEvent(\n                KeyEvent.ACTION_UP,\n                KeyEvent.KEYCODE_MEDIA_NEXT\n            )\n        )\n    }\n\n    @Synchronized\n    fun sendPause(force: Boolean = false) {\n        Log.d(\"MediaController\", \"Sending pause with iPausedTheMedia: $iPausedTheMedia, userPlayedTheMedia: $userPlayedTheMedia, isMusicActive: ${audioManager.isMusicActive}, force: $force\")\n        if ((audioManager.isMusicActive) && (!userPlayedTheMedia || force)) {\n            iPausedTheMedia = if (force) audioManager.isMusicActive else true\n            userPlayedTheMedia = false\n            audioManager.dispatchMediaKeyEvent(\n                KeyEvent(\n                    KeyEvent.ACTION_DOWN,\n                    KeyEvent.KEYCODE_MEDIA_PAUSE\n                )\n            )\n            audioManager.dispatchMediaKeyEvent(\n                KeyEvent(\n                    KeyEvent.ACTION_UP,\n                    KeyEvent.KEYCODE_MEDIA_PAUSE\n                )\n            )\n        }\n    }\n\n    @Synchronized\n    fun sendPlay() {\n        Log.d(\"MediaController\", \"Sending play with iPausedTheMedia: $iPausedTheMedia\")\n        if (iPausedTheMedia) {\n            Log.d(\"MediaController\", \"Sending play and setting userPlayedTheMedia to false\")\n            userPlayedTheMedia = false\n            audioManager.dispatchMediaKeyEvent(\n                KeyEvent(\n                    KeyEvent.ACTION_DOWN,\n                    KeyEvent.KEYCODE_MEDIA_PLAY\n                )\n            )\n            audioManager.dispatchMediaKeyEvent(\n                KeyEvent(\n                    KeyEvent.ACTION_UP,\n                    KeyEvent.KEYCODE_MEDIA_PLAY\n                )\n            )\n        }\n        if (!audioManager.isMusicActive) {\n            Log.d(\"MediaController\", \"Setting iPausedTheMedia to false\")\n            iPausedTheMedia = false\n        }\n        if (pausedForCrossDevice) {\n            Log.d(\"MediaController\", \"Setting pausedForCrossDevice to false\")\n            pausedForCrossDevice = false\n        }\n    }\n\n    @Synchronized\n    fun startSpeaking() {\n        Log.d(\"MediaController\", \"Starting speaking max vol: ${audioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC)}, current vol: ${audioManager.getStreamVolume(AudioManager.STREAM_MUSIC)}, conversationalAwarenessVolume: $conversationalAwarenessVolume, relativeVolume: $relativeVolume\")\n\n        if (initialVolume == null) {\n            initialVolume = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC)\n            Log.d(\"MediaController\", \"Initial Volume: $initialVolume\")\n            val targetVolume = if (relativeVolume) {\n                (initialVolume!! * conversationalAwarenessVolume / 100)\n            } else if (initialVolume!! > (audioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC) * conversationalAwarenessVolume / 100)) {\n                (audioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC) * conversationalAwarenessVolume / 100)\n            } else {\n                initialVolume!!\n            }\n            smoothVolumeTransition(initialVolume!!, targetVolume.toInt())\n            if (conversationalAwarenessPauseMusic) {\n                sendPause(force = true)\n            }\n        }\n        Log.d(\"MediaController\", \"Initial Volume: $initialVolume\")\n    }\n\n    @Synchronized\n    fun stopSpeaking() {\n        Log.d(\"MediaController\", \"Stopping speaking, initialVolume: $initialVolume\")\n        if (initialVolume != null) {\n            smoothVolumeTransition(audioManager.getStreamVolume(AudioManager.STREAM_MUSIC), initialVolume!!)\n            if (conversationalAwarenessPauseMusic) {\n                sendPlay()\n            }\n            initialVolume = null\n        }\n    }\n\n    private fun smoothVolumeTransition(fromVolume: Int, toVolume: Int) {\n        Log.d(\"MediaController\", \"Smooth volume transition from $fromVolume to $toVolume\")\n        val step = if (fromVolume < toVolume) 1 else -1\n        val delay = 50L\n        var currentVolume = fromVolume\n\n        handler.post(object : Runnable {\n            override fun run() {\n                if (currentVolume != toVolume) {\n                    currentVolume += step\n                    audioManager.setStreamVolume(AudioManager.STREAM_MUSIC, currentVolume, 0)\n                    handler.postDelayed(this, delay)\n                }\n            }\n        })\n    }\n}\n"
        },
        {
          "name": "GestureFeedback.kt",
          "ext": ".kt",
          "size": 5369,
          "preview": "@file:Suppress(\"PrivatePropertyName\")\n\npackage me.kavishdevar.librepods.utils\n\nimport android.content.Context\nimport android.media.AudioAttributes\nimport android.media.SoundPool\nimport android.os.Build\nimport android.os.SystemClock\nimport android.util.Log\nimport androidx.annotation.RequiresApi\nimport me.kavishdevar.librepods.R\nimport java.util.concurrent.atomic.AtomicBoolean\n\n@RequiresApi(Build.VERSION_CODES.Q)\nclass GestureFeedback(private val context: Context) {\n\n    private val TAG = \"GestureFeedback\"\n\n    private val soundsLoaded = AtomicBoolean(false)\n\n    private val soundPool = SoundPool.Builder()\n        .setMaxStreams(3)\n        .setAudioAttributes(\n            AudioAttributes.Builder()\n                .setUsage(AudioAttributes.USAGE_ASSISTANCE_ACCESSIBILITY)\n                .setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)\n                .setFlags(AudioAttributes.FLAG_LOW_LATENCY or\n                         AudioAttributes.FLAG_AUDIBILITY_ENFORCED)\n                .build()\n        )\n        .build()\n\n\n    private var soundId = 0\n    private var confirmYesId = 0\n    private var confirmNoId = 0\n\n    private var lastHorizontalTime = 0L\n    private var lastLeftTime = 0L\n    private var lastRightTime = 0L\n\n    private var lastVerticalTime = 0L\n    private var lastUpTime = 0L\n    private var lastDownTime = 0L\n\n    private val MIN_TIME_BETWEEN_SOUNDS = 150L\n    private val MIN_TIME_BETWEEN_DIRECTION = 200L\n\n    private var currentHorizontalStreamId = 0\n    private var currentVerticalStreamId = 0\n\n\n    private val LEFT_VOLUME = Pair(1.0f, 0.0f)\n    private val RIGHT_VOLUME = Pair(0.0f, 1.0f)\n    private val VERTICAL_VOLUME = Pair(1.0f, 1.0f)\n\n    init {\n        soundId = soundPool.load(context, R.raw.blip_no, 1)\n        confirmYesId = soundPool.load(context, R.raw.confirm_yes, 1)\n        confirmNoId = soundPool.load(context, R.raw.confirm_no, 1)\n\n        soundPool.setOnLoadCompleteListener { _, _, _ ->\n            Log.d(TAG, \"Sounds loaded\")\n            soundsLoaded.set(true)\n\n            soundPool.play(soundId, 0.0f, 0.0f, 1, 0, 1.0f)\n        }\n    }\n\n    @RequiresApi(Build.VERSION_CODES.R)\n    fun playDirectional(isVertical: Boolean, value: Double) {\n        if (!soundsLoaded.get()) {\n            Log.d(TAG, \"Sounds not yet loaded, skipping playback\")\n            return\n        }\n\n        val now = SystemClock.uptimeMillis()\n\n        if (isVertical) {\n            val isUp = value > 0\n\n            if (now - lastVerticalTime < MIN_TIME_BETWEEN_SOUNDS) {\n                Log.d(TAG, \"Skipping vertical sound due to general vertical debounce\")\n                return\n            }\n\n            if (isUp && now - lastUpTime < MIN_TIME_BETWEEN_DIRECTION) {\n                Log.d(TAG, \"Skipping UP sound due to direction debounce\")\n                return\n            }\n\n            if (!isUp && now - lastDownTime < MIN_TIME_BETWEEN_DIRECTION) {\n                Log.d(TAG, \"Skipping DOWN sound due to direction debounce\")\n                return\n            }\n\n            if (currentVerticalStreamId > 0) {\n                soundPool.stop(currentVerticalStreamId)\n            }\n\n            val (leftVol, rightVol) = VERTICAL_VOLUME\n\n            currentVerticalStreamId = soundPool.play(soundId, leftVol, rightVol, 1, 0, 1.0f)\n            Log.d(TAG, \"Playing VERTICAL sound: ${if (isUp) \"UP\" else \"DOWN\"} - streamID=$currentVerticalStreamId\")\n\n            lastVerticalTime = now\n            if (isUp) {\n                lastUpTime = now\n            } else {\n                lastDownTime = now\n            }\n        } else {\n            if (now - lastHorizontalTime < MIN_TIME_BETWEEN_SOUNDS) {\n                Log.d(TAG, \"Skipping horizontal sound due to general horizontal debounce\")\n                return\n            }\n\n            val isRight = value > 0\n\n            if (isRight && now - lastRightTime < MIN_TIME_BETWEEN_DIRECTION) {\n                Log.d(TAG, \"Skipping RIGHT sound due to direction debounce\")\n                return\n            }\n\n            if (!isRight && now - lastLeftTime < MIN_TIME_BETWEEN_DIRECTION) {\n                Log.d(TAG, \"Skipping LEFT sound due to direction debounce\")\n                return\n            }\n\n            if (currentHorizontalStreamId > 0) {\n                soundPool.stop(currentHorizontalStreamId)\n            }\n\n            val (leftVol, rightVol) = if (isRight) RIGHT_VOLUME else LEFT_VOLUME\n\n            currentHorizontalStreamId = soundPool.play(soundId, leftVol, rightVol, 1, 0, 1.0f)\n            Log.d(TAG, \"Playing HORIZONTAL sound: ${if (isRight) \"RIGHT\" else \"LEFT\"} - streamID=$currentHorizontalStreamId\")\n\n            lastHorizontalTime = now\n            if (isRight) {\n                lastRightTime = now\n            } else {\n                lastLeftTime = now\n            }\n        }\n    }\n\n    fun playConfirmation(isYes: Boolean) {\n        if (currentHorizontalStreamId > 0) {\n            soundPool.stop(currentHorizontalStreamId)\n        }\n        if (currentVerticalStreamId > 0) {\n            soundPool.stop(currentVerticalStreamId)\n        }\n\n        val soundId = if (isYes) confirmYesId else confirmNoId\n        if (soundId != 0 && soundsLoaded.get()) {\n            val streamId = soundPool.play(soundId, 1.0f, 1.0f, 1, 0, 1.0f)\n            Log.d(TAG, \"Playing ${if (isYes) \"YES\" else \"NO\"} confirmation - streamID=$streamId\")\n        }\n    }\n}\n"
        },
        {
          "name": "GestureDetector.kt",
          "ext": ".kt",
          "size": 14484,
          "preview": "@file:OptIn(ExperimentalEncodingApi::class)\n\npackage me.kavishdevar.librepods.utils\n\nimport android.os.Build\nimport android.util.Log\nimport androidx.annotation.RequiresApi\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.Job\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.withContext\nimport me.kavishdevar.librepods.services.AirPodsService\nimport me.kavishdevar.librepods.services.ServiceManager\nimport java.util.Collections\nimport java.util.concurrent.CopyOnWriteArrayList\nimport kotlin.io.encoding.ExperimentalEncodingApi\nimport kotlin.math.abs\nimport kotlin.math.max\nimport kotlin.math.min\nimport kotlin.math.pow\n\n@RequiresApi(Build.VERSION_CODES.Q)\nclass GestureDetector(\n    private val airPodsService: AirPodsService\n) {\n    companion object {\n        private const val TAG = \"GestureDetector\"\n\n        private const val IMMEDIATE_FEEDBACK_THRESHOLD = 600\n        private const val DIRECTION_CHANGE_SENSITIVITY = 150\n\n        private const val FAST_MOVEMENT_THRESHOLD = 300.0\n        private const val MIN_REQUIRED_EXTREMES = 3\n        private const val MAX_REQUIRED_EXTREMES = 4\n\n        private const val MAX_VALID_ORIENTATION_VALUE = 6000\n    }\n\n    val audio = GestureFeedback(ServiceManager.getService()?.baseContext!!)\n\n    private val horizontalBuffer = Collections.synchronizedList(ArrayList<Double>())\n    private val verticalBuffer = Collections.synchronizedList(ArrayList<Double>())\n\n    private val horizontalAvgBuffer = Collections.synchronizedList(ArrayList<Double>())\n    private val verticalAvgBuffer = Collections.synchronizedList(ArrayList<Double>())\n\n    private var prevHorizontal: Double = 0.0\n    private var prevVertical: Double = 0.0\n\n    private val horizontalPeaks = CopyOnWriteArrayList<Triple<Int, Double, Long>>()\n    private val horizontalTroughs = CopyOnWriteArrayList<Triple<Int, Double, Long>>()\n    private val verticalPeaks = CopyOnWriteArrayList<Triple<Int, Double, Long>>()\n    private val verticalTroughs = CopyOnWriteArrayList<Triple<Int, Double, Long>>()\n\n    private var lastPeakTime: Long = 0\n    private val peakIntervals = Collections.synchronizedList(ArrayList<Double>())\n\n    private val movementSpeedIntervals = Collections.synchronizedList(ArrayList<Long>())\n\n    private val peakThreshold = 400\n    private val directionChangeThreshold = DIRECTION_CHANGE_SENSITIVITY\n    private val rhythmConsistencyThreshold = 0.5\n\n    private var horizontalIncreasing: Boolean? = null\n    private var verticalIncreasing: Boolean? = null\n\n    private val minConfidenceThreshold = 0.7\n\n    private var isRunning = false\n    private var detectionJob: Job? = null\n    private var gestureDetectedCallback: ((Boolean) -> Unit)? = null\n\n    private var significantMotion = false\n    private var lastSignificantMotionTime = 0L\n\n    init {\n        while (horizontalAvgBuffer.size < 3) horizontalAvgBuffer.add(0.0)\n        while (verticalAvgBuffer.size < 3) verticalAvgBuffer.add(0.0)\n    }\n\nfun startDetection(doNotStop: Boolean = false, onGestureDetected: (Boolean) -> Unit) {\n        if (isRunning) return\n\n        Log.d(TAG, \"Starting gesture detection...\")\n        isRunning = true\n        gestureDetectedCallback = onGestureDetected\n\n        Log.d(TAG, \"started: ${airPodsService.startHeadTracking()}\")\n\n        clearData()\n\n        prevHorizontal = 0.0\n        prevVertical = 0.0\n\n        detectionJob = CoroutineScope(Dispatchers.Default).launch {\n            while (isRunning) {\n                delay(50)\n\n                val gesture = detectGestures()\n                if (gesture != null) {\n                    withContext(Dispatchers.Main) {\n                        audio.playConfirmation(gesture)\n\n                        gestureDetectedCallback?.invoke(gesture)\n                        stopDetection(doNotStop)\n                    }\n                    break\n                }\n            }\n        }\n    }\n    fun stopDetection(doNotStop: Boolean = false) {\n        if (!isRunning) return\n\n        Log.d(TAG, \"Stopping gesture detection\")\n        isRunning = false\n\n        if (!doNotStop) airPodsService.stopHeadTracking()\n\n        detectionJob?.cancel()\n        detectionJob = null\n        gestureDetectedCallback = null\n    }\n\n    @RequiresApi(Build.VERSION_CODES.R)\n    fun processHeadOrientation(horizontal: Int, vertical: Int) {\n        if (!isRunning) return\n\n        if (abs(horizontal) > MAX_VALID_ORIENTATION_VALUE || abs(vertical) > MAX_VALID_ORIENTATION_VALUE) {\n            Log.d(TAG, \"Ignoring likely calibration data: h=$horizontal, v=$vertical\")\n            return\n        }\n\n        val horizontalDelta = horizontal - prevHorizontal\n        val verticalDelta = vertical - prevVertical\n\n        val significantHorizontal = abs(horizontalDelta) > IMMEDIATE_FEEDBACK_THRESHOLD\n        val significantVertical = abs(verticalDelta) > IMMEDIATE_FEEDBACK_THRESHOLD\n\n        if (significantHorizontal && (!significantVertical || abs(horizontalDelta) > abs(verticalDelta))) {\n            CoroutineScope(Dispatchers.Main).launch {\n                audio.playDirectional(isVertical = false, value = horizontalDelta)\n            }\n            significantMotion = true\n            lastSignificantMotionTime = System.currentTimeMillis()\n            Log.d(TAG, \"Significant HORIZONTAL movement: $horizontalDelta\")\n        }\n        else if (significantVertical) {\n            CoroutineScope(Dispatchers.Main).launch {\n                audio.playDirectional(isVertical = true, value = verticalDelta)\n            }\n            significantMotion = true\n            lastSignificantMotionTime = System.currentTimeMillis()\n            Log.d(TAG, \"Significant VERTICAL movement: $verticalDelta\")\n        }\n        else if (significantMotion &&\n                 (System.currentTimeMillis() - lastSignificantMotionTime) > 300) {\n            significantMotion = false\n        }\n\n        prevHorizontal = horizontal.toDouble()\n        prevVertical = vertical.toDouble()\n\n        val smoothHorizontal = applySmoothing(horizontal.toDouble(), horizontalAvgBuffer)\n        val smoothVertical = applySmoothing(vertical.toDouble(), verticalAvgBuffer)\n\n        synchronized(horizontalBuffer) {\n            horizontalBuffer.add(smoothHorizontal)\n            if (horizontalBuffer.size > 100) horizontalBuffer.removeAt(0)\n        }\n\n        synchronized(verticalBuffer) {\n            verticalBuffer.add(smoothVertical)\n            if (verticalBuffer.size > 100) verticalBuffer.removeAt(0)\n        }\n\n        detectPeaksAndTroughs()\n    }\n\n    private fun applySmoothing(newValue: Double, buffer: MutableList<Double>): Double {\n        synchronized(buffer) {\n            buffer.add(newValue)\n            if (buffer.size > 3) buffer.removeAt(0)\n            return buffer.average()\n        }\n    }\n\n\n    private fun detectPeaksAndTroughs() {\n        if (horizontalBuffer.size < 4 || verticalBuffer.size < 4) return\n\n        val hValues = horizontalBuffer.takeLast(4)\n        val vValues = verticalBuffer.takeLast(4)\n        val hVariance = calculateVariance(hValues)\n        val vVariance = calculateVariance(vValues)\n\n        processDirectionChanges(\n            horizontalBuffer,\n            horizontalIncreasing,\n            hVariance,\n            horizontalPeaks,\n            horizontalTroughs\n        )?.let { horizontalIncreasing = it }\n\n        processDirectionChanges(\n            verticalBuffer,\n            verticalIncreasing,\n            vVariance,\n            verticalPeaks,\n            verticalTroughs\n        )?.let { verticalIncreasing = it }\n    }\n\n    private fun processDirectionChanges(\n        buffer: List<Double>,\n        isIncreasing: Boolean?,\n        variance: Double,\n        peaks: MutableList<Triple<Int, Double, Long>>,\n        troughs: MutableList<Triple<Int, Double, Long>>\n    ): Boolean? {\n        if (buffer.size < 2) return isIncreasing\n\n        val current = buffer.last()\n        val prev = buffer[buffer.size - 2]\n        var increasing = isIncreasing ?: (current > prev)\n\n        val dynamicThreshold = max(50.0, min(directionChangeThreshold.toDouble(), variance / 3))\n\n        val now = System.currentTimeMillis()\n\n        if (increasing && current < prev - dynamicThreshold) {\n            if (abs(prev) > peakThreshold) {\n                peaks.add(Triple(buffer.size - 1, prev, now))\n                if (lastPeakTime > 0) {\n                    val interval = (now - lastPeakTime) / 1000.0\n                    val timeDiff = now - lastPeakTime\n\n                    synchronized(peakIntervals) {\n                        peakIntervals.add(interval)\n                        if (peakIntervals.size > 5) peakIntervals.removeAt(0)\n                    }\n\n                    synchronized(movementSpeedIntervals) {\n                        movementSpeedIntervals.add(timeDiff)\n                        if (movementSpeedIntervals.size > 5) movementSpeedIntervals.removeAt(0)\n                    }\n                }\n                lastPeakTime = now\n            }\n            increasing = false\n        } else if (!increasing && current > prev + dynamicThreshold) {\n            if (abs(prev) > peakThreshold) {\n                troughs.add(Triple(buffer.size - 1, prev, now))\n\n                if (lastPeakTime > 0) {\n                    val interval = (now - lastPeakTime) / 1000.0\n                    val timeDiff = now - lastPeakTime\n\n                    synchronized(peakIntervals) {\n                        peakIntervals.add(interval)\n                        if (peakIntervals.size > 5) peakIntervals.removeAt(0)\n                    }\n\n                    synchronized(movementSpeedIntervals) {\n                        movementSpeedIntervals.add(timeDiff)\n                        if (movementSpeedIntervals.size > 5) movementSpeedIntervals.removeAt(0)\n                    }\n                }\n                lastPeakTime = now\n            }\n            increasing = true\n        }\n\n        return increasing\n    }\n\n    private fun calculateVariance(values: List<Double>): Double {\n        if (values.size <= 1) return 0.0\n\n        val mean = values.average()\n        val squaredDiffs = values.map { (it - mean) * (it - mean) }\n        return squaredDiffs.average()\n    }\n\n\n    private fun calculateRhythmConsistency(): Double {\n        if (peakIntervals.size < 2) return 0.0\n\n        val meanInterval = peakIntervals.average()\n        if (meanInterval == 0.0) return 0.0\n\n        val variances = peakIntervals.map { (it / meanInterval - 1.0).pow(2) }\n        val consistency = 1.0 - min(1.0, variances.average() / rhythmConsistencyThreshold)\n        return max(0.0, consistency)\n    }\n\n\n    private fun calculateConfidenceScore(extremes: List<Triple<Int, Double, Long>>, isVertical: Boolean): Double {\n        if (extremes.size < getRequiredExtremes()) return 0.0\n\n        val sortedExtremes = extremes.sortedBy { it.first }\n\n        val recent = sortedExtremes.takeLast(getRequiredExtremes())\n\n        val avgAmplitude = recent.map { abs(it.second) }.average()\n        val amplitudeFactor = min(1.0, avgAmplitude / 600)\n\n        val rhythmFactor = calculateRhythmConsistency()\n\n        val signs = recent.map { if (it.second > 0) 1 else -1 }\n        val alternating = (1 until signs.size).all { signs[it] != signs[it - 1] }\n        val alternationFactor = if (alternating) 1.0 else 0.5\n\n        val isolationFactor = if (isVertical) {\n            val vertAmplitude = recent.map { abs(it.second) }.average()\n            val horizVals = horizontalBuffer.takeLast(recent.size * 2)\n            val horizAmplitude = horizVals.map { abs(it) }.average()\n            min(1.0, vertAmplitude / (horizAmplitude + 0.1) * 1.2)\n        } else {\n            val horizAmplitude = recent.map { abs(it.second) }.average()\n            val vertVals = verticalBuffer.takeLast(recent.size * 2)\n            val vertAmplitude = vertVals.map { abs(it) }.average()\n            min(1.0, horizAmplitude / (vertAmplitude + 0.1) * 1.2)\n        }\n\n        return (\n            amplitudeFactor * 0.4 +\n            rhythmFactor * 0.2 +\n            alternationFactor * 0.2 +\n            isolationFactor * 0.2\n        )\n    }\n\n    private fun getRequiredExtremes(): Int {\n        if (movementSpeedIntervals.isEmpty()) return MIN_REQUIRED_EXTREMES\n\n        val avgInterval = movementSpeedIntervals.average()\n        Log.d(TAG, \"Average movement interval: $avgInterval ms\")\n\n        return if (avgInterval < FAST_MOVEMENT_THRESHOLD) {\n            MAX_REQUIRED_EXTREMES\n        } else {\n            MIN_REQUIRED_EXTREMES\n        }\n    }\n\n    private fun detectGestures(): Boolean? {\n        val requiredExtremes = getRequiredExtremes()\n        Log.d(TAG, \"Current required extremes: $requiredExtremes\")\n\n        if (verticalPeaks.size + verticalTroughs.size >= requiredExtremes) {\n            val allExtremes = (verticalPeaks + verticalTroughs).sortedBy { it.first }\n\n            val confidence = calculateConfidenceScore(allExtremes, isVertical = true)\n\n            Log.d(TAG, \"Vertical motion confidence: $confidence (need $minConfidenceThreshold)\")\n\n            if (confidence >= minConfidenceThreshold) {\n                Log.d(TAG, \"\\\"Yes\\\" Gesture Detected (confidence: $confidence, extremes: ${allExtremes.size}/$requiredExtremes)\")\n                return true\n            }\n        }\n\n        if (horizontalPeaks.size + horizontalTroughs.size >= requiredExtremes) {\n            val allExtremes = (horizontalPeaks + horizontalTroughs).sortedBy { it.first }\n\n            val confidence = calculateConfidenceScore(allExtremes, isVertical = false)\n\n            Log.d(TAG, \"Horizontal motion confidence: $confidence (need $minConfidenceThreshold)\")\n\n            if (confidence >= minConfidenceThreshold) {\n                Log.d(TAG, \"\\\"No\\\" Gesture Detected (confidence: $confidence, extremes: ${allExtremes.size}/$requiredExtremes)\")\n                return false\n            }\n        }\n\n        return null\n    }\n\n    private fun clearData() {\n        horizontalBuffer.clear()\n        verticalBuffer.clear()\n        horizontalPeaks.clear()\n        horizontalTroughs.clear()\n        verticalPeaks.clear()\n        verticalTroughs.clear()\n        peakIntervals.clear()\n        movementSpeedIntervals.clear()\n        horizontalIncreasing = null\n        verticalIncreasing = null\n        lastPeakTime = 0\n        significantMotion = false\n        lastSignificantMotionTime = 0L\n    }\n\n    private fun Double.pow(exponent: Int): Double = this.pow(exponent.toDouble())\n}\n"
        },
        {
          "name": "BluetoothCryptography.kt",
          "ext": ".kt",
          "size": 2721,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple's ecosystem\n *\n * Copyright (C) 2025 LibrePods Contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\npackage me.kavishdevar.librepods.utils\n\nimport javax.crypto.Cipher\nimport javax.crypto.spec.SecretKeySpec\n\n/**\n * Utilities for Bluetooth cryptography operations, particularly for\n * verifying Resolvable Private Addresses (RPA) used by AirPods.\n */\nobject BluetoothCryptography {\n    \n    /**\n     * Verifies if the provided Bluetooth address is an RPA that matches the given Identity Resolving Key (IRK)\n     * \n     * @param addr The Bluetooth address to verify\n     * @param irk The Identity Resolving Key to use for verification\n     * @return true if the address is verified as an RPA matching the IRK\n     */\n    fun verifyRPA(addr: String, irk: ByteArray): Boolean {\n        val rpa = addr.split(\":\").map { it.toInt(16).toByte() }.reversed().toByteArray()\n        val prand = rpa.copyOfRange(3, 6)\n        val hash = rpa.copyOfRange(0, 3)\n        val computedHash = ah(irk, prand)\n        return hash.contentEquals(computedHash)\n    }\n\n    /**\n     * Performs E function (AES-128) as specified in Bluetooth Core Specification\n     * \n     * @param key The key for encryption\n     * @param data The data to encrypt\n     * @return The encrypted data\n     */\n    fun e(key: ByteArray, data: ByteArray): ByteArray {\n        val swappedKey = key.reversedArray()\n        val swappedData = data.reversedArray()\n        val cipher = Cipher.getInstance(\"AES/ECB/NoPadding\")\n        val secretKey = SecretKeySpec(swappedKey, \"AES\")\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey)\n        return cipher.doFinal(swappedData).reversedArray()\n    }\n\n    /**\n     * Performs the ah function as specified in Bluetooth Core Specification\n     * \n     * @param k The IRK key\n     * @param r The random part of the address\n     * @return The hash part of the address\n     */\n    fun ah(k: ByteArray, r: ByteArray): ByteArray {\n        val rPadded = ByteArray(16)\n        r.copyInto(rPadded, 0, 0, 3)\n        val encrypted = e(k, rPadded)\n        return encrypted.copyOfRange(0, 3)\n    }\n}\n"
        },
        {
          "name": "CrossDevice.kt",
          "ext": ".kt",
          "size": 14329,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n *\n * Copyright (C) 2025 LibrePods contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\n@file:OptIn(ExperimentalEncodingApi::class)\n\npackage me.kavishdevar.librepods.utils\n\nimport android.annotation.SuppressLint\nimport android.bluetooth.BluetoothAdapter\nimport android.bluetooth.BluetoothManager\nimport android.bluetooth.BluetoothServerSocket\nimport android.bluetooth.BluetoothSocket\nimport android.bluetooth.le.AdvertiseCallback\nimport android.bluetooth.le.AdvertiseData\nimport android.bluetooth.le.AdvertiseSettings\nimport android.bluetooth.le.BluetoothLeAdvertiser\nimport android.content.Context\nimport android.content.Intent\nimport android.content.SharedPreferences\nimport android.os.ParcelUuid\nimport android.util.Log\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.launch\nimport me.kavishdevar.librepods.services.ServiceManager\nimport java.io.IOException\nimport java.util.UUID\nimport kotlin.io.encoding.ExperimentalEncodingApi\n\nenum class CrossDevicePackets(val packet: ByteArray) {\n    AIRPODS_CONNECTED(byteArrayOf(0x00, 0x01, 0x00, 0x01)),\n    AIRPODS_DISCONNECTED(byteArrayOf(0x00, 0x01, 0x00, 0x00)),\n    REQUEST_DISCONNECT(byteArrayOf(0x00, 0x02, 0x00, 0x00)),\n    REQUEST_BATTERY_BYTES(byteArrayOf(0x00, 0x02, 0x00, 0x01)),\n    REQUEST_ANC_BYTES(byteArrayOf(0x00, 0x02, 0x00, 0x02)),\n    REQUEST_CONNECTION_STATUS(byteArrayOf(0x00, 0x02, 0x00, 0x03)),\n    AIRPODS_DATA_HEADER(byteArrayOf(0x00, 0x04, 0x00, 0x01)),\n}\n\n\nobject CrossDevice {\n    var initialized = false\n    private val uuid = UUID.fromString(\"1abbb9a4-10e4-4000-a75c-8953c5471342\")\n    private var serverSocket: BluetoothServerSocket? = null\n    private var clientSocket: BluetoothSocket? = null\n    private lateinit var bluetoothAdapter: BluetoothAdapter\n    private lateinit var bluetoothLeAdvertiser: BluetoothLeAdvertiser\n    private const val MANUFACTURER_ID = 0x1234\n    private const val MANUFACTURER_DATA = \"ALN_AirPods\"\n    var isAvailable: Boolean = false // set to true when airpods are connected to another device\n    var batteryBytes: ByteArray = byteArrayOf()\n    var ancBytes: ByteArray = byteArrayOf()\n    private lateinit var sharedPreferences: SharedPreferences\n    private const val PACKET_LOG_KEY = \"packet_log\"\n    private var earDetectionStatus = listOf(false, false)\n    var disconnectionRequested = false\n\n    @SuppressLint(\"MissingPermission\")\n    fun init(context: Context) {\n        CoroutineScope(Dispatchers.IO).launch {\n            Log.d(\"CrossDevice\", \"Initializing CrossDevice\")\n            sharedPreferences = context.getSharedPreferences(\"packet_logs\", Context.MODE_PRIVATE)\n            sharedPreferences.edit().putBoolean(\"CrossDeviceIsAvailable\", false).apply()\n            this@CrossDevice.bluetoothAdapter = context.getSystemService(BluetoothManager::class.java).adapter\n            this@CrossDevice.bluetoothLeAdvertiser = bluetoothAdapter.bluetoothLeAdvertiser\n            // startAdvertising()\n            startServer()\n            initialized = true\n        }\n    }\n\n    @SuppressLint(\"MissingPermission\")\n    private fun startServer() {\n        CoroutineScope(Dispatchers.IO).launch {\n            if (!bluetoothAdapter.isEnabled) return@launch\n//            serverSocket = bluetoothAdapter.listenUsingRfcommWithServiceRecord(\"ALNCrossDevice\", uuid)\n            Log.d(\"CrossDevice\", \"Server started\")\n            while (serverSocket != null) {\n                if (!bluetoothAdapter.isEnabled) {\n                    serverSocket?.close()\n                    break\n                }\n                if (clientSocket != null) {\n                    try {\n                        clientSocket!!.close()\n                    } catch (e: IOException) {\n                        e.printStackTrace()\n                    }\n                }\n                try {\n                    val socket = serverSocket!!.accept()\n                    handleClientConnection(socket)\n                } catch (e: IOException) { }\n            }\n        }\n    }\n\n    @SuppressLint(\"MissingPermission\")\n    private fun startAdvertising() {\n        CoroutineScope(Dispatchers.IO).launch {\n            val settings = AdvertiseSettings.Builder()\n                .setAdvertiseMode(AdvertiseSettings.ADVERTISE_MODE_LOW_LATENCY)\n                .setTxPowerLevel(AdvertiseSettings.ADVERTISE_TX_POWER_HIGH)\n                .setConnectable(true)\n                .build()\n\n            val data = AdvertiseData.Builder()\n                .setIncludeDeviceName(true)\n                .addManufacturerData(MANUFACTURER_ID, MANUFACTURER_DATA.toByteArray())\n                .addServiceUuid(ParcelUuid(uuid))\n                .build()\n            try {\n                bluetoothLeAdvertiser.startAdvertising(settings, data, advertiseCallback)\n            } catch (e: Exception) {\n                Log.e(\"CrossDevice\", \"Failed to start BLE Advertising: ${e.message}\")\n            }\n            Log.d(\"CrossDevice\", \"BLE Advertising started\")\n        }\n    }\n\n    private val advertiseCallback = object : AdvertiseCallback() {\n        override fun onStartSuccess(settingsInEffect: AdvertiseSettings) {\n            Log.d(\"CrossDevice\", \"BLE Advertising started successfully\")\n        }\n\n        override fun onStartFailure(errorCode: Int) {\n            Log.e(\"CrossDevice\", \"BLE Advertising failed with error code: $errorCode\")\n        }\n    }\n\n    fun setAirPodsConnected(connected: Boolean) {\n        if (connected) {\n            isAvailable = false\n            sharedPreferences.edit().putBoolean(\"CrossDeviceIsAvailable\", false).apply()\n            clientSocket?.outputStream?.write(CrossDevicePackets.AIRPODS_CONNECTED.packet)\n        } else {\n            clientSocket?.outputStream?.write(CrossDevicePackets.AIRPODS_DISCONNECTED.packet)\n            // Reset state variables\n            isAvailable = true\n        }\n    }\n\n    fun sendReceivedPacket(packet: ByteArray) {\n        if (clientSocket == null || clientSocket!!.outputStream != null) {\n            return\n        }\n        clientSocket?.outputStream?.write(CrossDevicePackets.AIRPODS_DATA_HEADER.packet + packet)\n    }\n\n    private fun logPacket(packet: ByteArray, source: String) {\n        val packetHex = packet.joinToString(\" \") { \"%02X\".format(it) }\n        val logEntry = \"$source: $packetHex\"\n        val logs = sharedPreferences.getStringSet(PACKET_LOG_KEY, mutableSetOf())?.toMutableSet() ?: mutableSetOf()\n        logs.add(logEntry)\n        sharedPreferences.edit().putStringSet(PACKET_LOG_KEY, logs).apply()\n    }\n\n    @SuppressLint(\"MissingPermission\")\n    private fun handleClientConnection(socket: BluetoothSocket) {\n        Log.d(\"CrossDevice\", \"Client connected\")\n        notifyAirPodsConnectedRemotely(ServiceManager.getService()?.applicationContext!!)\n        clientSocket = socket\n        val inputStream = socket.inputStream\n        val buffer = ByteArray(1024)\n        var bytes: Int\n        setAirPodsConnected(ServiceManager.getService()?.isConnectedLocally == true)\n        while (true) {\n            try {\n                bytes = inputStream.read(buffer)\n            } catch (e: IOException) {\n                e.printStackTrace()\n                notifyAirPodsDisconnectedRemotely(ServiceManager.getService()?.applicationContext!!)\n                val s = serverSocket?.accept()\n                if (s != null) {\n                    handleClientConnection(s)\n                }\n                break\n            }\n            var packet = buffer.copyOf(bytes)\n            logPacket(packet, \"Relay\")\n            Log.d(\"CrossDevice\", \"Received packet: ${packet.joinToString(\"\") { \"%02x\".format(it) }}\")\n            if (bytes == -1) {\n                notifyAirPodsDisconnectedRemotely(ServiceManager.getService()?.applicationContext!!)\n                break\n            } else if (packet.contentEquals(CrossDevicePackets.REQUEST_DISCONNECT.packet) || packet.contentEquals(CrossDevicePackets.REQUEST_DISCONNECT.packet + CrossDevicePackets.AIRPODS_DATA_HEADER.packet)) {\n                ServiceManager.getService()?.disconnect()\n                disconnectionRequested = true\n                CoroutineScope(Dispatchers.IO).launch {\n                    delay(1000)\n                    disconnectionRequested = false\n                }\n            } else if (packet.contentEquals(CrossDevicePackets.AIRPODS_CONNECTED.packet)) {\n                isAvailable = true\n                sharedPreferences.edit().putBoolean(\"CrossDeviceIsAvailable\", true).apply()\n            } else if (packet.contentEquals(CrossDevicePackets.AIRPODS_DISCONNECTED.packet)) {\n                isAvailable = false\n                sharedPreferences.edit().putBoolean(\"CrossDeviceIsAvailable\", false).apply()\n            } else if (packet.contentEquals(CrossDevicePackets.REQUEST_BATTERY_BYTES.packet)) {\n                Log.d(\"CrossDevice\", \"Received battery request, battery data: ${batteryBytes.joinToString(\"\") { \"%02x\".format(it) }}\")\n                sendRemotePacket(batteryBytes)\n            } else if (packet.contentEquals(CrossDevicePackets.REQUEST_ANC_BYTES.packet)) {\n                Log.d(\"CrossDevice\", \"Received ANC request\")\n                sendRemotePacket(ancBytes)\n            } else if (packet.contentEquals(CrossDevicePackets.REQUEST_CONNECTION_STATUS.packet)) {\n                Log.d(\"CrossDevice\", \"Received connection status request\")\n                sendRemotePacket(if (ServiceManager.getService()?.isConnectedLocally == true) CrossDevicePackets.AIRPODS_CONNECTED.packet else CrossDevicePackets.AIRPODS_DISCONNECTED.packet)\n            } else {\n                if (packet.sliceArray(0..3).contentEquals(CrossDevicePackets.AIRPODS_DATA_HEADER.packet)) {\n                    isAvailable = true\n                    sharedPreferences.edit().putBoolean(\"CrossDeviceIsAvailable\", true).apply()\n                    if (packet.size % 2 == 0) {\n                        val half = packet.size / 2\n                        if (packet.sliceArray(0 until half).contentEquals(packet.sliceArray(half until packet.size))) {\n                            Log.d(\"CrossDevice\", \"Duplicated packet, trimming\")\n                            packet = packet.sliceArray(0 until half)\n                        }\n                    }\n                    var trimmedPacket = packet.drop(CrossDevicePackets.AIRPODS_DATA_HEADER.packet.size).toByteArray()\n                    Log.d(\"CrossDevice\", \"Received relayed packet: ${trimmedPacket.joinToString(\"\") { \"%02x\".format(it) }}\")\n                    if (ServiceManager.getService()?.isConnectedLocally == true) {\n                        val packetInHex = trimmedPacket.joinToString(\"\") { \"%02x\".format(it) }\n//                        ServiceManager.getService()?.sendPacket(packetInHex)\n                    } else if (ServiceManager.getService()?.batteryNotification?.isBatteryData(trimmedPacket) == true) {\n                        batteryBytes = trimmedPacket\n                        ServiceManager.getService()?.batteryNotification?.setBattery(trimmedPacket)\n                        Log.d(\"CrossDevice\", \"Battery data: ${ServiceManager.getService()?.batteryNotification?.getBattery()[0]?.level}\")\n                        ServiceManager.getService()?.updateBattery()\n                        ServiceManager.getService()?.sendBatteryBroadcast()\n                        ServiceManager.getService()?.sendBatteryNotification()\n                    } else if (ServiceManager.getService()?.ancNotification?.isANCData(trimmedPacket) == true) {\n                        ServiceManager.getService()?.ancNotification?.setStatus(trimmedPacket)\n                        ServiceManager.getService()?.sendANCBroadcast()\n                        ServiceManager.getService()?.updateNoiseControlWidget()\n                        ancBytes = trimmedPacket\n                    } else if (ServiceManager.getService()?.earDetectionNotification?.isEarDetectionData(trimmedPacket) == true) {\n                        Log.d(\"CrossDevice\", \"Ear detection data: ${trimmedPacket.joinToString(\"\") { \"%02x\".format(it) }}\")\n                        ServiceManager.getService()?.earDetectionNotification?.setStatus(trimmedPacket)\n                        val newEarDetectionStatus = listOf(\n                            ServiceManager.getService()?.earDetectionNotification?.status?.get(0) == 0x00.toByte(),\n                            ServiceManager.getService()?.earDetectionNotification?.status?.get(1) == 0x00.toByte()\n                        )\n                        if (earDetectionStatus == listOf(false, false) && newEarDetectionStatus.contains(true)) {\n                            ServiceManager.getService()?.applicationContext?.sendBroadcast(\n                                Intent(\"me.kavishdevar.librepods.cross_device_island\")\n                            )\n                        }\n                        earDetectionStatus = newEarDetectionStatus\n                    }\n                }\n            }\n        }\n    }\n\n    fun sendRemotePacket(byteArray: ByteArray) {\n        if (clientSocket == null || clientSocket!!.outputStream == null) {\n            return\n        }\n        clientSocket?.outputStream?.write(byteArray)\n        clientSocket?.outputStream?.flush()\n        logPacket(byteArray, \"Sent\")\n        Log.d(\"CrossDevice\", \"Sent packet to remote device\")\n    }\n\n    fun notifyAirPodsConnectedRemotely(context: Context) {\n        val intent = Intent(\"me.kavishdevar.librepods.AIRPODS_CONNECTED_REMOTELY\")\n        context.sendBroadcast(intent)\n    }\n    fun notifyAirPodsDisconnectedRemotely(context: Context) {\n        val intent = Intent(\"me.kavishdevar.librepods.AIRPODS_DISCONNECTED_REMOTELY\")\n        context.sendBroadcast(intent)\n    }\n}\n"
        },
        {
          "name": "RadareOffsetFinder.kt",
          "ext": ".kt",
          "size": 25961,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n *\n * Copyright (C) 2025 LibrePods contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\n@file:OptIn(ExperimentalEncodingApi::class)\n\npackage me.kavishdevar.librepods.utils\n\nimport android.content.Context\nimport android.util.Log\nimport androidx.compose.runtime.NoLiveLiterals\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.withContext\nimport me.kavishdevar.librepods.services.ServiceManager\nimport java.io.BufferedReader\nimport java.io.File\nimport java.io.FileOutputStream\nimport java.io.InputStreamReader\nimport java.net.HttpURLConnection\nimport java.net.URL\nimport kotlin.io.encoding.ExperimentalEncodingApi\n\n@NoLiveLiterals\nclass RadareOffsetFinder(context: Context) {\n    companion object {\n        private const val TAG = \"RadareOffsetFinder\"\n        private const val RADARE2_URL = \"https://hc-cdn.hel1.your-objectstorage.com/s/v3/c9898243c42c0d3d1387de9a37d57ce9df77f9c9_radare2-5.9.9-android-aarch64.tar.gz\"\n        private const val HOOK_OFFSET_PROP = \"persist.librepods.hook_offset\"\n        private const val CFG_REQ_OFFSET_PROP = \"persist.librepods.cfg_req_offset\"\n        private const val CSM_CONFIG_OFFSET_PROP = \"persist.librepods.csm_config_offset\"\n        private const val PEER_INFO_REQ_OFFSET_PROP = \"persist.librepods.peer_info_req_offset\"\n        private const val EXTRACT_DIR = \"/\"\n\n        private const val RADARE2_BIN_PATH = \"$EXTRACT_DIR/data/local/tmp/aln_unzip/org.radare.radare2installer/radare2/bin\"\n        private const val RADARE2_LIB_PATH = \"$EXTRACT_DIR/data/local/tmp/aln_unzip/org.radare.radare2installer/radare2/lib\"\n        private const val BUSYBOX_PATH = \"$EXTRACT_DIR/data/local/tmp/aln_unzip/busybox\"\n\n        private val LIBRARY_PATHS = listOf(\n            \"/apex/com.android.bt/lib64/libbluetooth_jni.so\",\n            \"/apex/com.android.btservices/lib64/libbluetooth_jni.so\",\n            \"/system/lib64/libbluetooth_jni.so\",\n            \"/system/lib64/libbluetooth_qti.so\",\n            \"/system_ext/lib64/libbluetooth_qti.so\"\n        )\n\n        fun findBluetoothLibraryPath(): String? {\n            for (path in LIBRARY_PATHS) {\n                if (File(path).exists()) {\n                    Log.d(TAG, \"Found Bluetooth library at $path\")\n                    return path\n                }\n            }\n            Log.e(TAG, \"Could not find Bluetooth library\")\n            return null\n        }\n\n        fun clearHookOffsets(): Boolean {\n            try {\n                val process = Runtime.getRuntime().exec(arrayOf(\n                    \"su\", \"-c\",\n                    \"setprop $HOOK_OFFSET_PROP '' && \" +\n                    \"setprop $CFG_REQ_OFFSET_PROP '' && \" +\n                    \"setprop $CSM_CONFIG_OFFSET_PROP '' && \" +\n                    \"setprop $PEER_INFO_REQ_OFFSET_PROP ''\"\n                ))\n                val exitCode = process.waitFor()\n\n                if (exitCode == 0) {\n                    Log.d(TAG, \"Successfully cleared hook offset properties\")\n                    return true\n                } else {\n                    Log.e(TAG, \"Failed to clear hook offset properties, exit code: $exitCode\")\n                }\n            } catch (e: Exception) {\n                Log.e(TAG, \"Error clearing hook offset properties\", e)\n            }\n            return false\n        }\n    }\n\n    private val radare2TarballFile = File(context.cacheDir, \"radare2.tar.gz\")\n\n    private val _progressState = MutableStateFlow<ProgressState>(ProgressState.Idle)\n    val progressState: StateFlow<ProgressState> = _progressState\n\n    sealed class ProgressState {\n        object Idle : ProgressState()\n        object CheckingExisting : ProgressState()\n        object Downloading : ProgressState()\n        data class DownloadProgress(val progress: Float) : ProgressState()\n        object Extracting : ProgressState()\n        object MakingExecutable : ProgressState()\n        object FindingOffset : ProgressState()\n        object SavingOffset : ProgressState()\n        object Cleaning : ProgressState()\n        data class Error(val message: String) : ProgressState()\n        data class Success(val offset: Long) : ProgressState()\n    }\n\n\n    fun isHookOffsetAvailable(): Boolean {\n        Log.d(TAG, \"Setup Skipped? \" + ServiceManager.getService()?.applicationContext?.getSharedPreferences(\"settings\", Context.MODE_PRIVATE)?.getBoolean(\"skip_setup\", false).toString())\n        if (ServiceManager.getService()?.applicationContext?.getSharedPreferences(\"settings\", Context.MODE_PRIVATE)?.getBoolean(\"skip_setup\", false) == true) {\n            Log.d(TAG, \"Setup skipped, returning true.\")\n            return true\n        }\n        _progressState.value = ProgressState.CheckingExisting\n        try {\n            val process = Runtime.getRuntime().exec(arrayOf(\"getprop\", HOOK_OFFSET_PROP))\n            val reader = BufferedReader(InputStreamReader(process.inputStream))\n            val propValue = reader.readLine()\n            process.waitFor()\n\n            if (propValue != null && propValue.isNotEmpty()) {\n                Log.d(TAG, \"Hook offset property exists: $propValue\")\n                _progressState.value = ProgressState.Idle\n                return true\n            }\n        } catch (e: Exception) {\n            Log.e(TAG, \"Error checking if offset property exists\", e)\n            _progressState.value = ProgressState.Error(\"Failed to check if offset property exists: ${e.message}\")\n        }\n\n        Log.d(TAG, \"No hook offset available\")\n        _progressState.value = ProgressState.Idle\n        return false\n    }\n\n    suspend fun setupAndFindOffset(): Boolean {\n        val offset = findOffset()\n        return offset > 0\n    }\n\n    suspend fun findOffset(): Long = withContext(Dispatchers.IO) {\n        try {\n            _progressState.value = ProgressState.Downloading\n            if (!downloadRadare2TarballIfNeeded()) {\n                _progressState.value = ProgressState.Error(\"Failed to download radare2 tarball\")\n                Log.e(TAG, \"Failed to download radare2 tarball\")\n                return@withContext 0L\n            }\n\n            _progressState.value = ProgressState.Extracting\n            if (!extractRadare2Tarball()) {\n                _progressState.value = ProgressState.Error(\"Failed to extract radare2 tarball\")\n                Log.e(TAG, \"Failed to extract radare2 tarball\")\n                return@withContext 0L\n            }\n\n            _progressState.value = ProgressState.MakingExecutable\n            if (!makeExecutable()) {\n                _progressState.value = ProgressState.Error(\"Failed to make binaries executable\")\n                Log.e(TAG, \"Failed to make binaries executable\")\n                return@withContext 0L\n            }\n\n            _progressState.value = ProgressState.FindingOffset\n            val offset = findFunctionOffset()\n            if (offset == 0L) {\n                _progressState.value = ProgressState.Error(\"Failed to find function offset\")\n                Log.e(TAG, \"Failed to find function offset\")\n                return@withContext 0L\n            }\n\n            _progressState.value = ProgressState.SavingOffset\n            if (!saveOffset(offset)) {\n                _progressState.value = ProgressState.Error(\"Failed to save offset\")\n                Log.e(TAG, \"Failed to save offset\")\n                return@withContext 0L\n            }\n\n            _progressState.value = ProgressState.Cleaning\n            cleanupExtractedFiles()\n\n            _progressState.value = ProgressState.Success(offset)\n            return@withContext offset\n\n        } catch (e: Exception) {\n            _progressState.value = ProgressState.Error(\"Error: ${e.message}\")\n            Log.e(TAG, \"Error in findOffset\", e)\n            return@withContext 0L\n        }\n    }\n\n    private suspend fun downloadRadare2TarballIfNeeded(): Boolean = withContext(Dispatchers.IO) {\n        if (radare2TarballFile.exists() && radare2TarballFile.length() > 0) {\n            Log.d(TAG, \"Radare2 tarball already downloaded to ${radare2TarballFile.absolutePath}\")\n            return@withContext true\n        }\n\n        try {\n            val url = URL(RADARE2_URL)\n            val connection = url.openConnection() as HttpURLConnection\n            connection.connectTimeout = 60000\n            connection.readTimeout = 60000\n\n            val contentLength = connection.contentLength.toFloat()\n            val inputStream = connection.inputStream\n            val outputStream = FileOutputStream(radare2TarballFile)\n\n            val buffer = ByteArray(4096)\n            var bytesRead: Int\n            var totalBytesRead = 0L\n\n            while (inputStream.read(buffer).also { bytesRead = it } != -1) {\n                outputStream.write(buffer, 0, bytesRead)\n                totalBytesRead += bytesRead\n                if (contentLength > 0) {\n                    val progress = totalBytesRead.toFloat() / contentLength\n                    _progressState.value = ProgressState.DownloadProgress(progress)\n                }\n            }\n\n            outputStream.close()\n            inputStream.close()\n\n            Log.d(TAG, \"Download successful to ${radare2TarballFile.absolutePath}\")\n            return@withContext true\n        } catch (e: Exception) {\n            Log.e(TAG, \"Failed to download radare2 tarball\", e)\n            return@withContext false\n        }\n    }\n\n    private suspend fun extractRadare2Tarball(): Boolean = withContext(Dispatchers.IO) {\n        try {\n            val isAlreadyExtracted = checkIfAlreadyExtracted()\n\n            if (isAlreadyExtracted) {\n                Log.d(TAG, \"Radare2 files already extracted correctly, skipping extraction\")\n                return@withContext true\n            }\n\n            Log.d(TAG, \"Removing existing extract directory\")\n            Runtime.getRuntime().exec(arrayOf(\"su\", \"-c\", \"rm -rf $EXTRACT_DIR/data/local/tmp/aln_unzip\")).waitFor()\n\n            Runtime.getRuntime().exec(arrayOf(\"su\", \"-c\", \"mkdir -p $EXTRACT_DIR/data/local/tmp/aln_unzip\")).waitFor()\n\n            Log.d(TAG, \"Extracting ${radare2TarballFile.absolutePath} to $EXTRACT_DIR\")\n\n            val process = Runtime.getRuntime().exec(\n                arrayOf(\"su\", \"-c\", \"tar xvf ${radare2TarballFile.absolutePath} -C $EXTRACT_DIR\")\n            )\n\n            val reader = BufferedReader(InputStreamReader(process.inputStream))\n            val errorReader = BufferedReader(InputStreamReader(process.errorStream))\n\n            var line: String?\n            while (reader.readLine().also { line = it } != null) {\n                Log.d(TAG, \"Extract output: $line\")\n            }\n\n            while (errorReader.readLine().also { line = it } != null) {\n                Log.e(TAG, \"Extract error: $line\")\n            }\n\n            val exitCode = process.waitFor()\n            if (exitCode == 0) {\n                Log.d(TAG, \"Extraction completed successfully\")\n                return@withContext true\n            } else {\n                Log.e(TAG, \"Extraction failed with exit code $exitCode\")\n                return@withContext false\n            }\n        } catch (e: Exception) {\n            Log.e(TAG, \"Failed to extract radare2\", e)\n            return@withContext false\n        }\n    }\n\n    private suspend fun checkIfAlreadyExtracted(): Boolean = withContext(Dispatchers.IO) {\n        try {\n            val checkDirProcess = Runtime.getRuntime().exec(\n                arrayOf(\"su\", \"-c\", \"[ -d $EXTRACT_DIR/data/local/tmp/aln_unzip ] && echo 'exists'\")\n            )\n            val dirExists = BufferedReader(InputStreamReader(checkDirProcess.inputStream)).readLine() == \"exists\"\n            checkDirProcess.waitFor()\n\n            if (!dirExists) {\n                Log.d(TAG, \"Extract directory doesn't exist, need to extract\")\n                return@withContext false\n            }\n\n            val tarProcess = Runtime.getRuntime().exec(\n                arrayOf(\"su\", \"-c\", \"tar tf ${radare2TarballFile.absolutePath}\")\n            )\n            val tarFiles = BufferedReader(InputStreamReader(tarProcess.inputStream)).readLines()\n                .filter { it.isNotEmpty() }\n                .map { it.trim() }\n                .toSet()\n            tarProcess.waitFor()\n\n            if (tarFiles.isEmpty()) {\n                Log.e(TAG, \"Failed to get file list from tarball\")\n                return@withContext false\n            }\n\n            val findProcess = Runtime.getRuntime().exec(\n                arrayOf(\"su\", \"-c\", \"find $EXTRACT_DIR/data/local/tmp/aln_unzip -type f | sort\")\n            )\n            val extractedFiles = BufferedReader(InputStreamReader(findProcess.inputStream)).readLines()\n                .filter { it.isNotEmpty() }\n                .map { it.trim() }\n                .toSet()\n            findProcess.waitFor()\n\n            if (extractedFiles.isEmpty()) {\n                Log.d(TAG, \"No files found in extract directory, need to extract\")\n                return@withContext false\n            }\n\n            for (tarFile in tarFiles) {\n                if (tarFile.endsWith(\"/\")) continue\n\n                val filePathInExtractDir = \"$EXTRACT_DIR/$tarFile\"\n                val fileCheckProcess = Runtime.getRuntime().exec(\n                    arrayOf(\"su\", \"-c\", \"[ -f $filePathInExtractDir ] && echo 'exists'\")\n                )\n                val fileExists = BufferedReader(InputStreamReader(fileCheckProcess.inputStream)).readLine() == \"exists\"\n                fileCheckProcess.waitFor()\n\n                if (!fileExists) {\n                    Log.d(TAG, \"File $filePathInExtractDir from tarball missing in extract directory\")\n                    Runtime.getRuntime().exec(arrayOf(\"su\", \"-c\", \"rm -rf $EXTRACT_DIR/data/local/tmp/aln_unzip\")).waitFor()\n                    return@withContext false\n                }\n            }\n\n            Log.d(TAG, \"All ${tarFiles.size} files from tarball exist in extract directory\")\n            return@withContext true\n        } catch (e: Exception) {\n            Log.e(TAG, \"Error checking extraction status\", e)\n            return@withContext false\n        }\n    }\n\n    private suspend fun makeExecutable(): Boolean = withContext(Dispatchers.IO) {\n        try {\n            Log.d(TAG, \"Making binaries executable in $RADARE2_BIN_PATH\")\n            val chmod1Result = Runtime.getRuntime().exec(\n                arrayOf(\"su\", \"-c\", \"chmod -R 755 $RADARE2_BIN_PATH\")\n            ).waitFor()\n\n            Log.d(TAG, \"Making binaries executable in $BUSYBOX_PATH\")\n\n            val chmod2Result = Runtime.getRuntime().exec(\n                arrayOf(\"su\", \"-c\", \"chmod -R 755 $BUSYBOX_PATH\")\n            ).waitFor()\n\n            if (chmod1Result == 0 && chmod2Result == 0) {\n                Log.d(TAG, \"Successfully made binaries executable\")\n                return@withContext true\n            } else {\n                Log.e(TAG, \"Failed to make binaries executable, exit codes: $chmod1Result, $chmod2Result\")\n                return@withContext false\n            }\n        } catch (e: Exception) {\n            Log.e(TAG, \"Error making binaries executable\", e)\n            return@withContext false\n        }\n    }\n\n    private suspend fun findFunctionOffset(): Long = withContext(Dispatchers.IO) {\n        val libraryPath = findBluetoothLibraryPath() ?: return@withContext 0L\n        var offset = 0L\n\n        try {\n            @Suppress(\"LocalVariableName\") val currentLD_LIBRARY_PATH = ProcessBuilder().command(\"su\", \"-c\", \"printenv LD_LIBRARY_PATH\").start().inputStream.bufferedReader().readText().trim()\n            val currentPATH = ProcessBuilder().command(\"su\", \"-c\", \"printenv PATH\").start().inputStream.bufferedReader().readText().trim()\n            val envSetup = \"\"\"\n                export LD_LIBRARY_PATH=\"$RADARE2_LIB_PATH:$currentLD_LIBRARY_PATH\"\n                export PATH=\"$BUSYBOX_PATH:$RADARE2_BIN_PATH:$currentPATH\"\n            \"\"\".trimIndent()\n\n            val command = \"$envSetup && $RADARE2_BIN_PATH/rabin2 -q -E $libraryPath | grep fcr_chk_chan\"\n            Log.d(TAG, \"Running command: $command\")\n\n            val process = Runtime.getRuntime().exec(arrayOf(\"su\", \"-c\", command))\n\n            val reader = BufferedReader(InputStreamReader(process.inputStream))\n            val errorReader = BufferedReader(InputStreamReader(process.errorStream))\n\n            var line: String?\n\n            while (reader.readLine().also { line = it } != null) {\n                Log.d(TAG, \"rabin2 output: $line\")\n                if (line?.contains(\"fcr_chk_chan\") == true) {\n                    val parts = line.split(\" \")\n                    if (parts.isNotEmpty() && parts[0].startsWith(\"0x\")) {\n                        offset = parts[0].substring(2).toLong(16)\n                        Log.d(TAG, \"Found offset at ${parts[0]}\")\n                        break\n                    }\n                }\n            }\n\n            while (errorReader.readLine().also { line = it } != null) {\n                Log.d(TAG, \"rabin2 error: $line\")\n            }\n\n            val exitCode = process.waitFor()\n            if (exitCode != 0) {\n                Log.e(TAG, \"rabin2 command failed with exit code $exitCode\")\n            }\n\n//            findAndSaveL2cuProcessCfgReqOffset(libraryPath, envSetup)\n//            findAndSaveL2cCsmConfigOffset(libraryPath, envSetup)\n//            findAndSaveL2cuSendPeerInfoReqOffset(libraryPath, envSetup)\n\n        } catch (e: Exception) {\n            Log.e(TAG, \"Failed to find function offset\", e)\n            return@withContext 0L\n        }\n\n        if (offset == 0L) {\n            Log.e(TAG, \"Failed to extract function offset from output, aborting\")\n            return@withContext 0L\n        }\n\n        Log.d(TAG, \"Successfully found offset: 0x${offset.toString(16)}\")\n        return@withContext offset\n    }\n\n    private suspend fun findAndSaveL2cuProcessCfgReqOffset(libraryPath: String, envSetup: String) = withContext(Dispatchers.IO) {\n        try {\n            val command = \"$envSetup && $RADARE2_BIN_PATH/rabin2 -q -E $libraryPath | grep l2cu_process_our_cfg_req\"\n            Log.d(TAG, \"Running command: $command\")\n\n            val process = Runtime.getRuntime().exec(arrayOf(\"su\", \"-c\", command))\n            val reader = BufferedReader(InputStreamReader(process.inputStream))\n            val errorReader = BufferedReader(InputStreamReader(process.errorStream))\n\n            var line: String?\n            var offset = 0L\n\n            while (reader.readLine().also { line = it } != null) {\n                Log.d(TAG, \"rabin2 output: $line\")\n                if (line?.contains(\"l2cu_process_our_cfg_req\") == true) {\n                    val parts = line.split(\" \")\n                    if (parts.isNotEmpty() && parts[0].startsWith(\"0x\")) {\n                        offset = parts[0].substring(2).toLong(16)\n                        Log.d(TAG, \"Found l2cu_process_our_cfg_req offset at ${parts[0]}\")\n                        break\n                    }\n                }\n            }\n\n            while (errorReader.readLine().also { line = it } != null) {\n                Log.d(TAG, \"rabin2 error: $line\")\n            }\n\n            val exitCode = process.waitFor()\n            if (exitCode != 0) {\n                Log.e(TAG, \"rabin2 command failed with exit code $exitCode\")\n            }\n\n            if (offset > 0L) {\n                val hexString = \"0x${offset.toString(16)}\"\n                Runtime.getRuntime().exec(arrayOf(\n                    \"su\", \"-c\", \"setprop $CFG_REQ_OFFSET_PROP $hexString\"\n                )).waitFor()\n                Log.d(TAG, \"Saved l2cu_process_our_cfg_req offset: $hexString\")\n            }\n        } catch (e: Exception) {\n            Log.e(TAG, \"Failed to find or save l2cu_process_our_cfg_req offset\", e)\n        }\n    }\n\n    private suspend fun findAndSaveL2cCsmConfigOffset(libraryPath: String, envSetup: String) = withContext(Dispatchers.IO) {\n        try {\n            val command = \"$envSetup && $RADARE2_BIN_PATH/rabin2 -q -E $libraryPath | grep l2c_csm_config\"\n            Log.d(TAG, \"Running command: $command\")\n\n            val process = Runtime.getRuntime().exec(arrayOf(\"su\", \"-c\", command))\n            val reader = BufferedReader(InputStreamReader(process.inputStream))\n            val errorReader = BufferedReader(InputStreamReader(process.errorStream))\n\n            var line: String?\n            var offset = 0L\n\n            while (reader.readLine().also { line = it } != null) {\n                Log.d(TAG, \"rabin2 output: $line\")\n                if (line?.contains(\"l2c_csm_config\") == true) {\n                    val parts = line.split(\" \")\n                    if (parts.isNotEmpty() && parts[0].startsWith(\"0x\")) {\n                        offset = parts[0].substring(2).toLong(16)\n                        Log.d(TAG, \"Found l2c_csm_config offset at ${parts[0]}\")\n                        break\n                    }\n                }\n            }\n\n            while (errorReader.readLine().also { line = it } != null) {\n                Log.d(TAG, \"rabin2 error: $line\")\n            }\n\n            val exitCode = process.waitFor()\n            if (exitCode != 0) {\n                Log.e(TAG, \"rabin2 command failed with exit code $exitCode\")\n            }\n\n            if (offset > 0L) {\n                val hexString = \"0x${offset.toString(16)}\"\n                Runtime.getRuntime().exec(arrayOf(\n                    \"su\", \"-c\", \"setprop $CSM_CONFIG_OFFSET_PROP $hexString\"\n                )).waitFor()\n                Log.d(TAG, \"Saved l2c_csm_config offset: $hexString\")\n            }\n        } catch (e: Exception) {\n            Log.e(TAG, \"Failed to find or save l2c_csm_config offset\", e)\n        }\n    }\n\n    private suspend fun findAndSaveL2cuSendPeerInfoReqOffset(libraryPath: String, envSetup: String) = withContext(Dispatchers.IO) {\n        try {\n            val command = \"$envSetup && $RADARE2_BIN_PATH/rabin2 -q -E $libraryPath | grep l2cu_send_peer_info_req\"\n            Log.d(TAG, \"Running command: $command\")\n\n            val process = Runtime.getRuntime().exec(arrayOf(\"su\", \"-c\", command))\n            val reader = BufferedReader(InputStreamReader(process.inputStream))\n            val errorReader = BufferedReader(InputStreamReader(process.errorStream))\n\n            var line: String?\n            var offset = 0L\n\n            while (reader.readLine().also { line = it } != null) {\n                Log.d(TAG, \"rabin2 output: $line\")\n                if (line?.contains(\"l2cu_send_peer_info_req\") == true) {\n                    val parts = line.split(\" \")\n                    if (parts.isNotEmpty() && parts[0].startsWith(\"0x\")) {\n                        offset = parts[0].substring(2).toLong(16)\n                        Log.d(TAG, \"Found l2cu_send_peer_info_req offset at ${parts[0]}\")\n                        break\n                    }\n                }\n            }\n\n            while (errorReader.readLine().also { line = it } != null) {\n                Log.d(TAG, \"rabin2 error: $line\")\n            }\n\n            val exitCode = process.waitFor()\n            if (exitCode != 0) {\n                Log.e(TAG, \"rabin2 command failed with exit code $exitCode\")\n            }\n\n            if (offset > 0L) {\n                val hexString = \"0x${offset.toString(16)}\"\n                Runtime.getRuntime().exec(arrayOf(\n                    \"su\", \"-c\", \"setprop $PEER_INFO_REQ_OFFSET_PROP $hexString\"\n                )).waitFor()\n                Log.d(TAG, \"Saved l2cu_send_peer_info_req offset: $hexString\")\n            }\n        } catch (e: Exception) {\n            Log.e(TAG, \"Failed to find or save l2cu_send_peer_info_req offset\", e)\n        }\n    }\n\n    private suspend fun saveOffset(offset: Long): Boolean = withContext(Dispatchers.IO) {\n        try {\n            val hexString = \"0x${offset.toString(16)}\"\n            Log.d(TAG, \"Saving offset to system property: $hexString\")\n\n            val process = Runtime.getRuntime().exec(arrayOf(\n                \"su\", \"-c\", \"setprop $HOOK_OFFSET_PROP $hexString\"\n            ))\n\n            val exitCode = process.waitFor()\n            if (exitCode == 0) {\n                val verifyProcess = Runtime.getRuntime().exec(arrayOf(\n                    \"getprop\", HOOK_OFFSET_PROP\n                ))\n                val propValue = BufferedReader(InputStreamReader(verifyProcess.inputStream)).readLine()\n                verifyProcess.waitFor()\n\n                if (propValue != null && propValue.isNotEmpty()) {\n                    Log.d(TAG, \"Successfully saved offset to system property: $propValue\")\n                    return@withContext true\n                } else {\n                    Log.e(TAG, \"Property was set but couldn't be verified\")\n                }\n            } else {\n                Log.e(TAG, \"Failed to set property, exit code: $exitCode\")\n            }\n            return@withContext false\n        } catch (e: Exception) {\n            Log.e(TAG, \"Failed to save offset\", e)\n            return@withContext false\n        }\n    }\n\n    private fun cleanupExtractedFiles() {\n        try {\n            Runtime.getRuntime().exec(arrayOf(\"su\", \"-c\", \"rm -rf $EXTRACT_DIR/data/local/tmp/aln_unzip\")).waitFor()\n            Log.d(TAG, \"Cleaned up extracted files at $EXTRACT_DIR/data/local/tmp/aln_unzip\")\n        } catch (e: Exception) {\n            Log.e(TAG, \"Failed to cleanup extracted files\", e)\n        }\n    }\n}\n"
        },
        {
          "name": "BluetoothConnectionManager.kt",
          "ext": ".kt",
          "size": 1400,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple's ecosystem\n *\n * Copyright (C) 2025 LibrePods Contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\npackage me.kavishdevar.librepods.utils\n\nimport android.bluetooth.BluetoothDevice\nimport android.bluetooth.BluetoothSocket\nimport android.util.Log\n\nobject BluetoothConnectionManager {\n    private const val TAG = \"BluetoothConnectionManager\"\n\n    private var currentSocket: BluetoothSocket? = null\n    private var currentDevice: BluetoothDevice? = null\n\n    fun setCurrentConnection(socket: BluetoothSocket, device: BluetoothDevice) {\n        currentSocket = socket\n        currentDevice = device\n        Log.d(TAG, \"Current connection set to device: ${device.address}\")\n    }\n\n    fun getCurrentSocket(): BluetoothSocket? {\n        return currentSocket\n    }\n}\n"
        }
      ]
    },
    {
      "dir": "android/app/src/main/java/me/kavishdevar/librepods/services",
      "files": [
        {
          "name": "AirPodsService.kt",
          "ext": ".kt",
          "size": 112565,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n *\n * Copyright (C) 2025 LibrePods Contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\n@file:OptIn(ExperimentalEncodingApi::class)\n\npackage me.kavishdevar.librepods.services\n\nimport android.Manifest\nimport android.annotation.SuppressLint\nimport android.app.Notification\nimport android.app.NotificationChannel\nimport android.app.NotificationManager\nimport android.app.PendingIntent\nimport android.app.Service\nimport android.appwidget.AppWidgetManager\nimport android.bluetooth.BluetoothDevice\nimport android.bluetooth.BluetoothManager\nimport android.bluetooth.BluetoothProfile\nimport android.bluetooth.BluetoothSocket\nimport android.content.BroadcastReceiver\nimport android.content.ComponentName\nimport android.content.ContentResolver\nimport android.content.Context\nimport android.content.Intent\nimport android.content.IntentFilter\nimport android.content.SharedPreferences\nimport android.content.pm.PackageManager\nimport android.content.res.Resources\nimport android.media.AudioManager\nimport android.net.Uri\nimport android.os.BatteryManager\nimport android.os.Binder\nimport android.os.Build\nimport android.os.Handler\nimport android.os.IBinder\nimport android.os.Looper\nimport android.os.ParcelUuid\nimport android.os.UserHandle\nimport android.provider.Settings\nimport android.telecom.TelecomManager\nimport android.telephony.PhoneStateListener\nimport android.telephony.TelephonyManager\nimport android.util.Log\nimport android.util.TypedValue\nimport android.view.View\nimport android.widget.RemoteViews\nimport android.widget.Toast\nimport androidx.annotation.RequiresApi\nimport androidx.annotation.RequiresPermission\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.core.app.NotificationCompat\nimport androidx.core.content.edit\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.ExperimentalCoroutinesApi\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.runBlocking\nimport kotlinx.coroutines.suspendCancellableCoroutine\nimport kotlinx.coroutines.withTimeout\nimport me.kavishdevar.librepods.MainActivity\nimport me.kavishdevar.librepods.R\nimport me.kavishdevar.librepods.constants.AirPodsNotifications\nimport me.kavishdevar.librepods.constants.Battery\nimport me.kavishdevar.librepods.constants.BatteryComponent\nimport me.kavishdevar.librepods.constants.BatteryStatus\nimport me.kavishdevar.librepods.constants.StemAction\nimport me.kavishdevar.librepods.constants.isHeadTrackingData\nimport me.kavishdevar.librepods.utils.AACPManager\nimport me.kavishdevar.librepods.utils.AACPManager.Companion.StemPressType\nimport me.kavishdevar.librepods.utils.BLEManager\nimport me.kavishdevar.librepods.utils.BluetoothConnectionManager\nimport me.kavishdevar.librepods.utils.CrossDevice\nimport me.kavishdevar.librepods.utils.CrossDevicePackets\nimport me.kavishdevar.librepods.utils.GestureDetector\nimport me.kavishdevar.librepods.utils.HeadTracking\nimport me.kavishdevar.librepods.utils.IslandType\nimport me.kavishdevar.librepods.utils.IslandWindow\nimport me.kavishdevar.librepods.utils.MediaController\nimport me.kavishdevar.librepods.utils.PopupWindow\nimport me.kavishdevar.librepods.utils.SystemApisUtils\nimport me.kavishdevar.librepods.utils.SystemApisUtils.DEVICE_TYPE_UNTETHERED_HEADSET\nimport me.kavishdevar.librepods.utils.SystemApisUtils.METADATA_COMPANION_APP\nimport me.kavishdevar.librepods.utils.SystemApisUtils.METADATA_DEVICE_TYPE\nimport me.kavishdevar.librepods.utils.SystemApisUtils.METADATA_MAIN_ICON\nimport me.kavishdevar.librepods.utils.SystemApisUtils.METADATA_MANUFACTURER_NAME\nimport me.kavishdevar.librepods.utils.SystemApisUtils.METADATA_MODEL_NAME\nimport me.kavishdevar.librepods.utils.SystemApisUtils.METADATA_UNTETHERED_CASE_BATTERY\nimport me.kavishdevar.librepods.utils.SystemApisUtils.METADATA_UNTETHERED_CASE_CHARGING\nimport me.kavishdevar.librepods.utils.SystemApisUtils.METADATA_UNTETHERED_CASE_ICON\nimport me.kavishdevar.librepods.utils.SystemApisUtils.METADATA_UNTETHERED_CASE_LOW_BATTERY_THRESHOLD\nimport me.kavishdevar.librepods.utils.SystemApisUtils.METADATA_UNTETHERED_LEFT_BATTERY\nimport me.kavishdevar.librepods.utils.SystemApisUtils.METADATA_UNTETHERED_LEFT_CHARGING\nimport me.kavishdevar.librepods.utils.SystemApisUtils.METADATA_UNTETHERED_LEFT_ICON\nimport me.kavishdevar.librepods.utils.SystemApisUtils.METADATA_UNTETHERED_LEFT_LOW_BATTERY_THRESHOLD\nimport me.kavishdevar.librepods.utils.SystemApisUtils.METADATA_UNTETHERED_RIGHT_BATTERY\nimport me.kavishdevar.librepods.utils.SystemApisUtils.METADATA_UNTETHERED_RIGHT_CHARGING\nimport me.kavishdevar.librepods.utils.SystemApisUtils.METADATA_UNTETHERED_RIGHT_ICON\nimport me.kavishdevar.librepods.utils.SystemApisUtils.METADATA_UNTETHERED_RIGHT_LOW_BATTERY_THRESHOLD\nimport me.kavishdevar.librepods.widgets.BatteryWidget\nimport me.kavishdevar.librepods.widgets.NoiseControlWidget\nimport org.lsposed.hiddenapibypass.HiddenApiBypass\nimport java.nio.ByteBuffer\nimport java.nio.ByteOrder\nimport kotlin.io.encoding.Base64\nimport kotlin.io.encoding.ExperimentalEncodingApi\n\nobject ServiceManager {\n    @ExperimentalEncodingApi\n    private var service: AirPodsService? = null\n\n    @ExperimentalEncodingApi\n    @Synchronized\n    fun getService(): AirPodsService? {\n        return service\n    }\n\n    @ExperimentalEncodingApi\n    @Synchronized\n    fun setService(service: AirPodsService?) {\n        this.service = service\n    }\n}\n\n// @Suppress(\"unused\")\n@ExperimentalEncodingApi\nclass AirPodsService : Service(), SharedPreferences.OnSharedPreferenceChangeListener {\n    var macAddress = \"\"\n    lateinit var aacpManager: AACPManager\n    var cameraActive = false\n    data class ServiceConfig(\n        var deviceName: String = \"AirPods\",\n        var earDetectionEnabled: Boolean = true,\n        var conversationalAwarenessPauseMusic: Boolean = false,\n        var showPhoneBatteryInWidget: Boolean = true,\n        var relativeConversationalAwarenessVolume: Boolean = true,\n        var headGestures: Boolean = true,\n        var disconnectWhenNotWearing: Boolean = false,\n        var conversationalAwarenessVolume: Int = 43,\n        var textColor: Long = -1L,\n        var qsClickBehavior: String = \"cycle\",\n        var bleOnlyMode: Boolean = false,\n\n        // AirPods state-based takeover\n        var takeoverWhenDisconnected: Boolean = true,\n        var takeoverWhenIdle: Boolean = true,\n        var takeoverWhenMusic: Boolean = false,\n        var takeoverWhenCall: Boolean = true,\n\n        // Phone state-based takeover\n        var takeoverWhenRingingCall: Boolean = true,\n        var takeoverWhenMediaStart: Boolean = true,\n\n        var leftSinglePressAction: StemAction = StemAction.defaultActions[StemPressType.SINGLE_PRESS]!!,\n        var rightSinglePressAction: StemAction = StemAction.defaultActions[StemPressType.SINGLE_PRESS]!!,\n\n        var leftDoublePressAction: StemAction = StemAction.defaultActions[StemPressType.DOUBLE_PRESS]!!,\n        var rightDoublePressAction: StemAction = StemAction.defaultActions[StemPressType.DOUBLE_PRESS]!!,\n\n        var leftTriplePressAction: StemAction = StemAction.defaultActions[StemPressType.TRIPLE_PRESS]!!,\n        var rightTriplePressAction: StemAction = StemAction.defaultActions[StemPressType.TRIPLE_PRESS]!!,\n\n        var leftLongPressAction: StemAction = StemAction.defaultActions[StemPressType.LONG_PRESS]!!,\n        var rightLongPressAction: StemAction = StemAction.defaultActions[StemPressType.LONG_PRESS]!!,\n    )\n\n    private lateinit var config: ServiceConfig\n\n    inner class LocalBinder : Binder() {\n        fun getService(): AirPodsService = this@AirPodsService\n    }\n\n    private lateinit var sharedPreferencesLogs: SharedPreferences\n    private lateinit var sharedPreferences: SharedPreferences\n    private val packetLogKey = \"packet_log\"\n    private val _packetLogsFlow = MutableStateFlow<Set<String>>(emptySet())\n    val packetLogsFlow: StateFlow<Set<String>> get() = _packetLogsFlow\n\n    private lateinit var telephonyManager: TelephonyManager\n    private lateinit var phoneStateListener: PhoneStateListener\n    private val maxLogEntries = 1000\n    private val inMemoryLogs = mutableSetOf<String>()\n\n    private var handleIncomingCallOnceConnected = false\n\n    lateinit var bleManager: BLEManager\n    private val bleStatusListener = object : BLEManager.AirPodsStatusListener {\n        @SuppressLint(\"NewApi\")\n        override fun onDeviceStatusChanged(\n            device: BLEManager.AirPodsStatus,\n            previousStatus: BLEManager.AirPodsStatus?\n        ) {\n            // Store MAC address for BLE-only mode if not already stored\n            if (config.bleOnlyMode && macAddress.isEmpty()) {\n                macAddress = device.address\n                sharedPreferences.edit {\n                    putString(\"mac_address\", macAddress)\n                }\n                Log.d(\"AirPodsBLEService\", \"BLE-only mode: stored MAC address ${device.address}\")\n            }\n\n            if (device.connectionState == \"Disconnected\" && !config.bleOnlyMode) {\n                Log.d(\"AirPodsBLEService\", \"Seems no device has taken over, we will.\")\n                val bluetoothManager = getSystemService(BluetoothManager::class.java)\n                val bluetoothDevice = bluetoothManager.adapter.getRemoteDevice(sharedPreferences.getString(\n                    \"mac_address\", \"\") ?: \"\")\n                connectToSocket(bluetoothDevice)\n            }\n            Log.d(\"AirPodsBLEService\", \"Device status changed\")\n            if (isConnectedLocally) return\n            val leftLevel = bleManager.getMostRecentStatus()?.leftBattery?: 0\n            val rightLevel = bleManager.getMostRecentStatus()?.rightBattery?: 0\n            val caseLevel = bleManager.getMostRecentStatus()?.caseBattery?: 0\n            val leftCharging = bleManager.getMostRecentStatus()?.isLeftCharging\n            val rightCharging = bleManager.getMostRecentStatus()?.isRightCharging\n            val caseCharging = bleManager.getMostRecentStatus()?.isCaseCharging\n\n            batteryNotification.setBatteryDirect(\n                leftLevel = leftLevel,\n                leftCharging = leftCharging == true,\n                rightLevel = rightLevel,\n                rightCharging = rightCharging == true,\n                caseLevel = caseLevel,\n                caseCharging = caseCharging == true\n            )\n            updateBattery()\n        }\n\n        override fun onBroadcastFromNewAddress(device: BLEManager.AirPodsStatus) {\n            Log.d(\"AirPodsService\", \"New address detected\")\n        }\n\n        override fun onLidStateChanged(\n            lidOpen: Boolean,\n        ) {\n            if (lidOpen) {\n                Log.d(\"AirPodsBLEService\", \"Lid opened\")\n                showPopup(\n                    this@AirPodsService,\n                    getSharedPreferences(\"settings\", MODE_PRIVATE).getString(\"name\", \"AirPods Pro\") ?: \"AirPods\"\n                )\n                if (isConnectedLocally) return\n                val leftLevel = bleManager.getMostRecentStatus()?.leftBattery?: 0\n                val rightLevel = bleManager.getMostRecentStatus()?.rightBattery?: 0\n                val caseLevel = bleManager.getMostRecentStatus()?.caseBattery?: 0\n                val leftCharging = bleManager.getMostRecentStatus()?.isLeftCharging\n                val rightCharging = bleManager.getMostRecentStatus()?.isRightCharging\n                val caseCharging = bleManager.getMostRecentStatus()?.isCaseCharging\n\n                batteryNotification.setBatteryDirect(\n                    leftLevel = leftLevel,\n                    leftCharging = leftCharging == true,\n                    rightLevel = rightLevel,\n                    rightCharging = rightCharging == true,\n                    caseLevel = caseLevel,\n                    caseCharging = caseCharging == true\n                )\n                sendBatteryBroadcast()\n            } else {\n                Log.d(\"AirPodsBLEService\", \"Lid closed\")\n            }\n        }\n\n        override fun onEarStateChanged(\n            device: BLEManager.AirPodsStatus,\n            leftInEar: Boolean,\n            rightInEar: Boolean\n        ) {\n            Log.d(\"AirPodsBLEService\", \"Ear state changed - Left: $leftInEar, Right: $rightInEar\")\n\n            // In BLE-only mode, ear detection is purely based on BLE data\n            if (config.bleOnlyMode) {\n                Log.d(\"AirPodsBLEService\", \"BLE-only mode: ear detection from BLE data\")\n            }\n        }\n\n        override fun onBatteryChanged(device: BLEManager.AirPodsStatus) {\n            if (isConnectedLocally) return\n            val leftLevel = bleManager.getMostRecentStatus()?.leftBattery?: 0\n            val rightLevel = bleManager.getMostRecentStatus()?.rightBattery?: 0\n            val caseLevel = bleManager.getMostRecentStatus()?.caseBattery?: 0\n            val leftCharging = bleManager.getMostRecentStatus()?.isLeftCharging\n            val rightCharging = bleManager.getMostRecentStatus()?.isRightCharging\n            val caseCharging = bleManager.getMostRecentStatus()?.isCaseCharging\n\n            batteryNotification.setBatteryDirect(\n                leftLevel = leftLevel,\n                leftCharging = leftCharging == true,\n                rightLevel = rightLevel,\n                rightCharging = rightCharging == true,\n                caseLevel = caseLevel,\n                caseCharging = caseCharging == true\n            )\n            updateBattery()\n            Log.d(\"AirPodsBLEService\", \"Battery changed\")\n        }\n\n    }\n    override fun onCreate() {\n        super.onCreate()\n        sharedPreferencesLogs = getSharedPreferences(\"packet_logs\", MODE_PRIVATE)\n\n        inMemoryLogs.addAll(sharedPreferencesLogs.getStringSet(packetLogKey, emptySet()) ?: emptySet())\n        _packetLogsFlow.value = inMemoryLogs.toSet()\n\n        sharedPreferences = getSharedPreferences(\"settings\", MODE_PRIVATE)\n        initializeConfig()\n\n        aacpManager = AACPManager()\n        initializeAACPManagerCallback()\n\n        sharedPreferences.registerOnSharedPreferenceChangeListener(this)\n    }\n\n     fun cameraOpened() {\n        Log.d(\"AirPodsService\", \"Camera opened, gonna handle stem presses and take action if enabled\")\n        val isCameraShutterUsed = listOf(\n            config.leftSinglePressAction,\n            config.rightSinglePressAction,\n            config.leftDoublePressAction,\n            config.rightDoublePressAction,\n            config.leftTriplePressAction,\n            config.rightTriplePressAction,\n            config.leftLongPressAction,\n            config.rightLongPressAction\n        ).any { it == StemAction.CAMERA_SHUTTER }\n\n        if (isCameraShutterUsed) {\n            Log.d(\"AirPodsService\", \"Camera opened, setting up stem actions\")\n            cameraActive = true\n            setupStemActions(isCameraActive = true)\n        }\n     }\n\n    fun cameraClosed() {\n        cameraActive = false\n        setupStemActions()\n    }\n\n    fun isCustomAction(\n        action: StemAction?,\n        default: StemAction?,\n        isCameraActive: Boolean = false\n    ): Boolean {\n        Log.d(\"AirPodsService\", \"Checking if action $action is custom against default $default, camera active: $isCameraActive\")\n        return action != default && (action != StemAction.CAMERA_SHUTTER || isCameraActive)\n    }\n\n    fun setupStemActions(isCameraActive: Boolean = false) {\n        val singlePressDefault = StemAction.defaultActions[StemPressType.SINGLE_PRESS]\n        val doublePressDefault = StemAction.defaultActions[StemPressType.DOUBLE_PRESS]\n        val triplePressDefault = StemAction.defaultActions[StemPressType.TRIPLE_PRESS]\n        val longPressDefault   = StemAction.defaultActions[StemPressType.LONG_PRESS]\n\n        val singlePressCustomized = isCustomAction(config.leftSinglePressAction, singlePressDefault, isCameraActive) ||\n            isCustomAction(config.rightSinglePressAction, singlePressDefault, isCameraActive)\n        val doublePressCustomized = isCustomAction(config.leftDoublePressAction, doublePressDefault, isCameraActive) ||\n            isCustomAction(config.rightDoublePressAction, doublePressDefault, isCameraActive)\n        val triplePressCustomized = isCustomAction(config.leftTriplePressAction, triplePressDefault, isCameraActive) ||\n            isCustomAction(config.rightTriplePressAction, triplePressDefault, isCameraActive)\n        val longPressCustomized = isCustomAction(config.leftLongPressAction, longPressDefault, isCameraActive) ||\n            isCustomAction(config.rightLongPressAction, longPressDefault, isCameraActive)\n        Log.d(\"AirPodsService\", \"Setting up stem actions: \" +\n            \"Single Press Customized: $singlePressCustomized, \" +\n            \"Double Press Customized: $doublePressCustomized, \" +\n            \"Triple Press Customized: $triplePressCustomized, \" +\n            \"Long Press Customized: $longPressCustomized\")\n        aacpManager.sendStemConfigPacket(\n            singlePressCustomized,\n            doublePressCustomized,\n            triplePressCustomized,\n            longPressCustomized,\n        )\n    }\n\n    @ExperimentalEncodingApi\n    private fun initializeAACPManagerCallback() {\n        aacpManager.setPacketCallback(object : AACPManager.PacketCallback {\n            @SuppressLint(\"MissingPermission\")\n            override fun onBatteryInfoReceived(batteryInfo: ByteArray) {\n                batteryNotification.setBattery(batteryInfo)\n                sendBroadcast(Intent(AirPodsNotifications.BATTERY_DATA).apply {\n                    putParcelableArrayListExtra(\"data\", ArrayList(batteryNotification.getBattery()))\n                })\n                updateBattery()\n                updateNotificationContent(\n                    true,\n                    this@AirPodsService.getSharedPreferences(\"settings\", MODE_PRIVATE)\n                        .getString(\"name\", device?.name),\n                    batteryNotification.getBattery()\n                )\n                CrossDevice.sendRemotePacket(batteryInfo)\n                CrossDevice.batteryBytes = batteryInfo\n\n                for (battery in batteryNotification.getBattery()) {\n                    Log.d(\n                        \"AirPodsParser\",\n                        \"${battery.getComponentName()}: ${battery.getStatusName()} at ${battery.level}% \"\n                    )\n                }\n\n                if (batteryNotification.getBattery()[0].status == BatteryStatus.CHARGING && batteryNotification.getBattery()[1].status == BatteryStatus.CHARGING) {\n                    disconnectAudio(this@AirPodsService, device)\n                } else {\n                    connectAudio(this@AirPodsService, device)\n                }\n            }\n\n            override fun onEarDetectionReceived(earDetection: ByteArray) {\n                sendBroadcast(Intent(AirPodsNotifications.EAR_DETECTION_DATA).apply {\n                    val list = earDetectionNotification.status\n                    val bytes = ByteArray(2)\n                    bytes[0] = list[0]\n                    bytes[1] = list[1]\n                    putExtra(\"data\", bytes)\n                })\n                Log.d(\n                    \"AirPodsParser\",\n                    \"Ear Detection: ${earDetectionNotification.status[0]} ${earDetectionNotification.status[1]}\"\n                )\n                processEarDetectionChange(earDetection)\n            }\n\n            override fun onConversationAwarenessReceived(conversationAwareness: ByteArray) {\n                conversationAwarenessNotification.setData(conversationAwareness)\n                sendBroadcast(Intent(AirPodsNotifications.CA_DATA).apply {\n                    putExtra(\"data\", conversationAwarenessNotification.status)\n                })\n\n                if (conversationAwarenessNotification.status == 1.toByte() || conversationAwarenessNotification.status == 2.toByte()) {\n                    MediaController.startSpeaking()\n                } else if (conversationAwarenessNotification.status == 8.toByte() || conversationAwarenessNotification.status == 9.toByte()) {\n                    MediaController.stopSpeaking()\n                }\n\n                Log.d(\n                    \"AirPodsParser\",\n                    \"Conversation Awareness: ${conversationAwarenessNotification.status}\"\n                )\n            }\n\n            override fun onControlCommandReceived(controlCommand: ByteArray) {\n                val command = AACPManager.ControlCommand.fromByteArray(controlCommand)\n                if (command.identifier == AACPManager.Companion.ControlCommandIdentifiers.LISTENING_MODE.value) {\n                    ancNotification.setStatus(byteArrayOf(command.value.takeIf { it.isNotEmpty() }?.get(0) ?: 0x00.toByte()))\n                    sendANCBroadcast()\n                    updateNoiseControlWidget()\n                }\n            }\n\n            override fun onDeviceMetadataReceived(deviceMetadata: ByteArray) {\n\n            }\n\n            @SuppressLint(\"NewApi\")\n            override fun onHeadTrackingReceived(headTracking: ByteArray) {\n                if (isHeadTrackingActive) {\n                    HeadTracking.processPacket(headTracking)\n                    processHeadTrackingData(headTracking)\n                }\n            }\n\n            override fun onProximityKeysReceived(proximityKeys: ByteArray) {\n                val keys = aacpManager.parseProximityKeysResponse(proximityKeys)\n                Log.d(\"AirPodsParser\", \"Proximity keys: $keys\")\n                sharedPreferences.edit {\n                    for (key in keys) {\n                        Log.d(\"AirPodsParser\", \"Proximity key: ${key.key.name} = ${key.value}\")\n                        putString(key.key.name, Base64.encode(key.value))\n                    }\n                }\n            }\n\n            override fun onStemPressReceived(stemPress: ByteArray) {\n                val (stemPressType, bud) = aacpManager.parseStemPressResponse(stemPress)\n\n                Log.d(\"AirPodsParser\", \"Stem press received: $stemPressType on $bud\")\n\n                val action = getActionFor(bud, stemPressType)\n                Log.d(\"AirPodsParser\", \"$bud $stemPressType action: $action\")\n\n                action?.let { executeStemAction(it) }\n            }\n\n            override fun onUnknownPacketReceived(packet: ByteArray) {\n                Log.d(\"AACPManager\", \"Unknown packet received: ${packet.joinToString(\" \") { \"%02X\".format(it) }}\")\n            }\n        })\n    }\n\n    private fun getActionFor(bud: AACPManager.Companion.StemPressBudType, type: StemPressType): StemAction? {\n        return when (type) {\n            StemPressType.SINGLE_PRESS -> if (bud == AACPManager.Companion.StemPressBudType.LEFT) config.leftSinglePressAction else config.rightSinglePressAction\n            StemPressType.DOUBLE_PRESS -> if (bud == AACPManager.Companion.StemPressBudType.LEFT) config.leftDoublePressAction else config.rightDoublePressAction\n            StemPressType.TRIPLE_PRESS -> if (bud == AACPManager.Companion.StemPressBudType.LEFT) config.leftTriplePressAction else config.rightTriplePressAction\n            StemPressType.LONG_PRESS -> if (bud == AACPManager.Companion.StemPressBudType.LEFT) config.leftLongPressAction else config.rightLongPressAction\n        }\n    }\n\n    private fun executeStemAction(action: StemAction) {\n        when (action) {\n            StemAction.defaultActions[StemPressType.SINGLE_PRESS] -> {\n                Log.d(\"AirPodsParser\", \"Default single press action: Play/Pause, not taking action.\")\n            }\n            StemAction.PLAY_PAUSE -> MediaController.sendPlayPause()\n            StemAction.PREVIOUS_TRACK -> MediaController.sendPreviousTrack()\n            StemAction.NEXT_TRACK -> MediaController.sendNextTrack()\n            StemAction.CAMERA_SHUTTER -> Runtime.getRuntime().exec(arrayOf(\"su\", \"-c\", \"input keyevent 27\"))\n            StemAction.DIGITAL_ASSISTANT -> {\n                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\n                    val intent = Intent(Intent.ACTION_VOICE_COMMAND).apply {\n                        addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)\n                    }\n                    startActivity(intent)\n                } else {\n                    Log.w(\"AirPodsParser\", \"Digital Assistant action is not supported on this Android version.\")\n                }\n            }\n            StemAction.CYCLE_NOISE_CONTROL_MODES -> {\n                Log.d(\"AirPodsParser\", \"Cycling noise control modes\")\n                sendBroadcast(Intent(\"me.kavishdevar.librepods.SET_ANC_MODE\"))\n            }\n        }\n    }\n\n    private fun processEarDetectionChange(earDetection: ByteArray) {\n        var inEar = false\n        var inEarData = listOf(earDetectionNotification.status[0] == 0x00.toByte(), earDetectionNotification.status[1] == 0x00.toByte())\n        var justEnabledA2dp = false\n        earDetectionNotification.setStatus(earDetection)\n        if (config.earDetectionEnabled) {\n            val data = earDetection.copyOfRange(earDetection.size - 2, earDetection.size)\n            inEar = data[0] == 0x00.toByte() && data[1] == 0x00.toByte()\n\n            val newInEarData = listOf(\n                data[0] == 0x00.toByte(),\n                data[1] == 0x00.toByte()\n            )\n\n            if (inEarData.sorted() == listOf(false, false) && newInEarData.sorted() != listOf(false, false) && islandWindow?.isVisible != true) {\n                showIsland(\n                    this@AirPodsService,\n                    (batteryNotification.getBattery().find { it.component == BatteryComponent.LEFT}?.level?: 0).coerceAtMost(batteryNotification.getBattery().find { it.component == BatteryComponent.RIGHT}?.level?: 0))\n            }\n\n            if (newInEarData == listOf(false, false) && islandWindow?.isVisible == true) {\n                islandWindow?.close()\n            }\n\n            if (newInEarData.contains(true) && inEarData == listOf(false, false)) {\n                connectAudio(this@AirPodsService, device)\n                justEnabledA2dp = true\n                registerA2dpConnectionReceiver()\n                if (MediaController.getMusicActive()) {\n                    MediaController.userPlayedTheMedia = true\n                }\n            } else if (newInEarData == listOf(false, false)) {\n                MediaController.sendPause(force = true)\n                if (config.disconnectWhenNotWearing) {\n                    disconnectAudio(this@AirPodsService, device)\n                }\n            }\n\n            if (inEarData.contains(false) && newInEarData == listOf(true, true)) {\n                Log.d(\"AirPodsParser\", \"User put in both AirPods from just one.\")\n                MediaController.userPlayedTheMedia = false\n            }\n\n            if (newInEarData.contains(false) && inEarData == listOf(true, true)) {\n                Log.d(\"AirPodsParser\", \"User took one of two out.\")\n                MediaController.userPlayedTheMedia = false\n            }\n\n            Log.d(\"AirPodsParser\", \"inEarData: ${inEarData.sorted()}, newInEarData: ${newInEarData.sorted()}\")\n\n            if (newInEarData.sorted() != inEarData.sorted()) {\n                inEarData = newInEarData\n                if (inEar == true) {\n                    if (!justEnabledA2dp) {\n                        justEnabledA2dp = false\n                        MediaController.sendPlay()\n                        MediaController.iPausedTheMedia = false\n                    }\n                } else {\n                    MediaController.sendPause()\n                }\n            }\n        }\n    }\n\n    private fun registerA2dpConnectionReceiver() {\n        val a2dpConnectionStateReceiver = object : BroadcastReceiver() {\n            override fun onReceive(context: Context, intent: Intent) {\n                if (intent.action == \"android.bluetooth.a2dp.profile.action.CONNECTION_STATE_CHANGED\") {\n                    val state = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, BluetoothProfile.STATE_DISCONNECTED)\n                    val previousState = intent.getIntExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, BluetoothProfile.STATE_DISCONNECTED)\n                    val device = intent.getParcelableExtra<BluetoothDevice>(BluetoothDevice.EXTRA_DEVICE)\n\n                    Log.d(\"MediaController\", \"A2DP state changed: $previousState -> $state for device: ${device?.address}\")\n\n                    if (state == BluetoothProfile.STATE_CONNECTED &&\n                        previousState != BluetoothProfile.STATE_CONNECTED &&\n                        device?.address == this@AirPodsService.device?.address) {\n\n                        Log.d(\"MediaController\", \"A2DP connected, sending play command\")\n                        MediaController.sendPlay()\n                        MediaController.iPausedTheMedia = false\n\n                        context.unregisterReceiver(this)\n                    }\n                }\n            }\n        }\n\n        val a2dpIntentFilter = IntentFilter(\"android.bluetooth.a2dp.profile.action.CONNECTION_STATE_CHANGED\")\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\n            registerReceiver(a2dpConnectionStateReceiver, a2dpIntentFilter, RECEIVER_EXPORTED)\n        } else {\n            registerReceiver(a2dpConnectionStateReceiver, a2dpIntentFilter)\n        }\n    }\n\n    private fun initializeConfig() {\n        config = ServiceConfig(\n            deviceName = sharedPreferences.getString(\"name\", \"AirPods\") ?: \"AirPods\",\n            earDetectionEnabled = sharedPreferences.getBoolean(\"automatic_ear_detection\", true),\n            conversationalAwarenessPauseMusic = sharedPreferences.getBoolean(\"conversational_awareness_pause_music\", false),\n            showPhoneBatteryInWidget = sharedPreferences.getBoolean(\"show_phone_battery_in_widget\", true),\n            relativeConversationalAwarenessVolume = sharedPreferences.getBoolean(\"relative_conversational_awareness_volume\", true),\n            headGestures = sharedPreferences.getBoolean(\"head_gestures\", true),\n            disconnectWhenNotWearing = sharedPreferences.getBoolean(\"disconnect_when_not_wearing\", false),\n            conversationalAwarenessVolume = sharedPreferences.getInt(\"conversational_awareness_volume\", 43),\n            textColor = sharedPreferences.getLong(\"textColor\", -1L),\n            qsClickBehavior = sharedPreferences.getString(\"qs_click_behavior\", \"cycle\") ?: \"cycle\",\n            bleOnlyMode = sharedPreferences.getBoolean(\"ble_only_mode\", false),\n\n            // AirPods state-based takeover\n            takeoverWhenDisconnected = sharedPreferences.getBoolean(\"takeover_when_disconnected\", true),\n            takeoverWhenIdle = sharedPreferences.getBoolean(\"takeover_when_idle\", true),\n            takeoverWhenMusic = sharedPreferences.getBoolean(\"takeover_when_music\", false),\n            takeoverWhenCall = sharedPreferences.getBoolean(\"takeover_when_call\", true),\n\n            // Phone state-based takeover\n            takeoverWhenRingingCall = sharedPreferences.getBoolean(\"takeover_when_ringing_call\", true),\n            takeoverWhenMediaStart = sharedPreferences.getBoolean(\"takeover_when_media_start\", true),\n\n            // Stem actions\n            leftSinglePressAction = StemAction.fromString(sharedPreferences.getString(\"left_single_press_action\", \"PLAY_PAUSE\") ?: \"PLAY_PAUSE\")!!,\n            rightSinglePressAction = StemAction.fromString(sharedPreferences.getString(\"right_single_press_action\", \"PLAY_PAUSE\") ?: \"PLAY_PAUSE\")!!,\n\n            leftDoublePressAction = StemAction.fromString(sharedPreferences.getString(\"left_double_press_action\", \"PREVIOUS_TRACK\") ?: \"NEXT_TRACK\")!!,\n            rightDoublePressAction = StemAction.fromString(sharedPreferences.getString(\"right_double_press_action\", \"NEXT_TRACK\") ?: \"NEXT_TRACK\")!!,\n\n            leftTriplePressAction = StemAction.fromString(sharedPreferences.getString(\"left_triple_press_action\", \"PREVIOUS_TRACK\") ?: \"PREVIOUS_TRACK\")!!,\n            rightTriplePressAction = StemAction.fromString(sharedPreferences.getString(\"right_triple_press_action\", \"PREVIOUS_TRACK\") ?: \"PREVIOUS_TRACK\")!!,\n\n            leftLongPressAction = StemAction.fromString(sharedPreferences.getString(\"left_long_press_action\", \"CYCLE_NOISE_CONTROL_MODES\") ?: \"CYCLE_NOISE_CONTROL_MODES\")!!,\n            rightLongPressAction = StemAction.fromString(sharedPreferences.getString(\"right_long_press_action\", \"DIGITAL_ASSISTANT\") ?: \"DIGITAL_ASSISTANT\")!!\n        )\n    }\n\n    override fun onSharedPreferenceChanged(preferences: SharedPreferences?, key: String?) {\n        if (preferences == null || key == null) return\n\n        when(key) {\n            \"name\" -> config.deviceName = preferences.getString(key, \"AirPods\") ?: \"AirPods\"\n            \"automatic_ear_detection\" -> config.earDetectionEnabled = preferences.getBoolean(key, true)\n            \"conversational_awareness_pause_music\" -> config.conversationalAwarenessPauseMusic = preferences.getBoolean(key, false)\n            \"show_phone_battery_in_widget\" -> {\n                config.showPhoneBatteryInWidget = preferences.getBoolean(key, true)\n                widgetMobileBatteryEnabled = config.showPhoneBatteryInWidget\n                updateBattery()\n            }\n            \"relative_conversational_awareness_volume\" -> config.relativeConversationalAwarenessVolume = preferences.getBoolean(key, true)\n            \"head_gestures\" -> config.headGestures = preferences.getBoolean(key, true)\n            \"disconnect_when_not_wearing\" -> config.disconnectWhenNotWearing = preferences.getBoolean(key, false)\n            \"conversational_awareness_volume\" -> config.conversationalAwarenessVolume = preferences.getInt(key, 43)\n            \"textColor\" -> config.textColor = preferences.getLong(key, -1L)\n            \"qs_click_behavior\" -> config.qsClickBehavior = preferences.getString(key, \"cycle\") ?: \"cycle\"\n            \"ble_only_mode\" -> config.bleOnlyMode = preferences.getBoolean(key, false)\n\n            // AirPods state-based takeover\n            \"takeover_when_disconnected\" -> config.takeoverWhenDisconnected = preferences.getBoolean(key, true)\n            \"takeover_when_idle\" -> config.takeoverWhenIdle = preferences.getBoolean(key, true)\n            \"takeover_when_music\" -> config.takeoverWhenMusic = preferences.getBoolean(key, false)\n            \"takeover_when_call\" -> config.takeoverWhenCall = preferences.getBoolean(key, true)\n\n            // Phone state-based takeover\n            \"takeover_when_ringing_call\" -> config.takeoverWhenRingingCall = preferences.getBoolean(key, true)\n            \"takeover_when_media_start\" -> config.takeoverWhenMediaStart = preferences.getBoolean(key, true)\n\n            \"left_single_press_action\" -> {\n                config.leftSinglePressAction = StemAction.fromString(\n                    preferences.getString(key, \"PLAY_PAUSE\") ?: \"PLAY_PAUSE\"\n                )!!\n                setupStemActions()\n            }\n            \"right_single_press_action\" -> {\n                config.rightSinglePressAction = StemAction.fromString(\n                    preferences.getString(key, \"PLAY_PAUSE\") ?: \"PLAY_PAUSE\"\n                )!!\n                setupStemActions()\n            }\n            \"left_double_press_action\" -> {\n                config.leftDoublePressAction = StemAction.fromString(\n                    preferences.getString(key, \"PREVIOUS_TRACK\") ?: \"PREVIOUS_TRACK\"\n                )!!\n                setupStemActions()\n            }\n            \"right_double_press_action\" -> {\n                config.rightDoublePressAction = StemAction.fromString(\n                    preferences.getString(key, \"NEXT_TRACK\") ?: \"NEXT_TRACK\"\n                )!!\n                setupStemActions()\n            }\n            \"left_triple_press_action\" -> {\n                config.leftTriplePressAction = StemAction.fromString(\n                    preferences.getString(key, \"PREVIOUS_TRACK\") ?: \"PREVIOUS_TRACK\"\n                )!!\n                setupStemActions()\n            }\n            \"right_triple_press_action\" -> {\n                config.rightTriplePressAction = StemAction.fromString(\n                    preferences.getString(key, \"PREVIOUS_TRACK\") ?: \"PREVIOUS_TRACK\"\n                )!!\n                setupStemActions()\n            }\n            \"left_long_press_action\" -> {\n                config.leftLongPressAction = StemAction.fromString(\n                    preferences.getString(key, \"CYCLE_NOISE_CONTROL_MODES\") ?: \"CYCLE_NOISE_CONTROL_MODES\"\n                )!!\n                setupStemActions()\n            }\n            \"right_long_press_action\" -> {\n                config.rightLongPressAction = StemAction.fromString(\n                    preferences.getString(key, \"DIGITAL_ASSISTANT\") ?: \"DIGITAL_ASSISTANT\"\n                )!!\n                setupStemActions()\n            }\n        }\n\n        if (key == \"mac_address\") {\n            macAddress = preferences.getString(key, \"\") ?: \"\"\n        }\n    }\n\n    private fun logPacket(packet: ByteArray, source: String) {\n        val packetHex = packet.joinToString(\" \") { \"%02X\".format(it) }\n        val logEntry = \"$source: $packetHex\"\n\n        synchronized(inMemoryLogs) {\n            inMemoryLogs.add(logEntry)\n            if (inMemoryLogs.size > maxLogEntries) {\n                inMemoryLogs.iterator().next().let {\n                    inMemoryLogs.remove(it)\n                }\n            }\n\n            _packetLogsFlow.value = inMemoryLogs.toSet()\n        }\n\n        CoroutineScope(Dispatchers.IO).launch {\n            val logs = sharedPreferencesLogs.getStringSet(packetLogKey, mutableSetOf())?.toMutableSet()\n                ?: mutableSetOf()\n            logs.add(logEntry)\n\n            if (logs.size > maxLogEntries) {\n                val toKeep = logs.toList().takeLast(maxLogEntries).toSet()\n                sharedPreferencesLogs.edit { putStringSet(packetLogKey, toKeep) }\n            } else {\n                sharedPreferencesLogs.edit { putStringSet(packetLogKey, logs) }\n            }\n        }\n    }\n\n    fun getPacketLogs(): Set<String> {\n        return inMemoryLogs.toSet()\n    }\n\n    private fun clearPacketLogs() {\n        synchronized(inMemoryLogs) {\n            inMemoryLogs.clear()\n            _packetLogsFlow.value = emptySet()\n        }\n        sharedPreferencesLogs.edit { remove(packetLogKey) }\n    }\n\n    fun clearLogs() {\n        clearPacketLogs()\n        _packetLogsFlow.value = emptySet()\n    }\n\n    override fun onBind(intent: Intent?): IBinder {\n        return LocalBinder()\n    }\n\n    private var gestureDetector: GestureDetector? = null\n    private var isInCall = false\n    private var callNumber: String? = null\n\n    @RequiresApi(Build.VERSION_CODES.Q)\n    private fun initGestureDetector() {\n        if (gestureDetector == null) {\n            gestureDetector = GestureDetector(this)\n        }\n    }\n\n\n    var popupShown = false\n    fun showPopup(service: Service, name: String) {\n        if (!Settings.canDrawOverlays(service)) {\n            Log.d(\"AirPodsService\", \"No permission for SYSTEM_ALERT_WINDOW\")\n            return\n        }\n        if (popupShown) {\n            return\n        }\n        val popupWindow = PopupWindow(service.applicationContext)\n        popupWindow.open(name, batteryNotification)\n        popupShown = true\n    }\n\n    var islandOpen = false\n    var islandWindow: IslandWindow? = null\n    @SuppressLint(\"MissingPermission\")\n    fun showIsland(service: Service, batteryPercentage: Int, type: IslandTy"
        },
        {
          "name": "AirPodsQSService.kt",
          "ext": ".kt",
          "size": 11042,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n *\n * Copyright (C) 2025 LibrePods Contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\n@file:OptIn(ExperimentalEncodingApi::class)\n\npackage me.kavishdevar.librepods.services\n\nimport android.annotation.SuppressLint\nimport android.app.PendingIntent\nimport android.content.BroadcastReceiver\nimport android.content.Context\nimport android.content.Intent\nimport android.content.IntentFilter\nimport android.content.SharedPreferences\nimport android.graphics.drawable.Icon\nimport android.os.Build\nimport android.service.quicksettings.Tile\nimport android.service.quicksettings.TileService\nimport android.util.Log\nimport androidx.annotation.RequiresApi\nimport me.kavishdevar.librepods.QuickSettingsDialogActivity\nimport me.kavishdevar.librepods.R\nimport me.kavishdevar.librepods.constants.AirPodsNotifications\nimport me.kavishdevar.librepods.constants.NoiseControlMode\nimport me.kavishdevar.librepods.utils.AACPManager\nimport kotlin.io.encoding.ExperimentalEncodingApi\n\n@RequiresApi(Build.VERSION_CODES.Q)\nclass AirPodsQSService : TileService() {\n\n    private lateinit var sharedPreferences: SharedPreferences\n    private var currentAncMode: Int = NoiseControlMode.OFF.ordinal + 1\n    private var isAirPodsConnected: Boolean = false\n\n    private val ancStatusReceiver = object : BroadcastReceiver() {\n        override fun onReceive(context: Context, intent: Intent) {\n            if (intent.action == AirPodsNotifications.ANC_DATA) {\n                val newMode = intent.getIntExtra(\"data\", NoiseControlMode.OFF.ordinal + 1)\n                Log.d(\"AirPodsQSService\", \"Received ANC update: $newMode\")\n                currentAncMode = newMode\n                updateTile()\n            }\n        }\n    }\n\n    private val availabilityReceiver = object : BroadcastReceiver() {\n        override fun onReceive(context: Context, intent: Intent) {\n            when (intent.action) {\n                AirPodsNotifications.AIRPODS_CONNECTED -> {\n                    Log.d(\"AirPodsQSService\", \"Received AIRPODS_CONNECTED\")\n                    isAirPodsConnected = true\n                    currentAncMode =\n                        ServiceManager.getService()?.getANC() ?: (NoiseControlMode.OFF.ordinal + 1)\n                    updateTile()\n                }\n                AirPodsNotifications.AIRPODS_DISCONNECTED -> {\n                    Log.d(\"AirPodsQSService\", \"Received AIRPODS_DISCONNECTED\")\n                    isAirPodsConnected = false\n                    updateTile()\n                }\n            }\n        }\n    }\n\n    private val preferenceChangeListener = SharedPreferences.OnSharedPreferenceChangeListener { _, key ->\n        if (key == \"off_listening_mode\") {\n            Log.d(\"AirPodsQSService\", \"Preference changed: $key\")\n            if (currentAncMode == NoiseControlMode.OFF.ordinal + 1 && !isOffModeEnabled()) {\n                currentAncMode = NoiseControlMode.TRANSPARENCY.ordinal + 1\n            }\n            updateTile()\n        }\n    }\n\n    override fun onCreate() {\n        super.onCreate()\n        sharedPreferences = getSharedPreferences(\"settings\", MODE_PRIVATE)\n    }\n\n    @SuppressLint(\"InlinedApi\", \"UnspecifiedRegisterReceiverFlag\")\n    override fun onStartListening() {\n        super.onStartListening()\n        Log.d(\"AirPodsQSService\", \"onStartListening\")\n\n        val service = ServiceManager.getService()\n        isAirPodsConnected = service?.isConnectedLocally == true\n        currentAncMode = service?.getANC() ?: (NoiseControlMode.OFF.ordinal + 1)\n\n        if (currentAncMode == NoiseControlMode.OFF.ordinal + 1 && !isOffModeEnabled()) {\n             currentAncMode = NoiseControlMode.TRANSPARENCY.ordinal + 1\n        }\n\n        val ancIntentFilter = IntentFilter(AirPodsNotifications.ANC_DATA)\n        val availabilityIntentFilter = IntentFilter().apply {\n            addAction(AirPodsNotifications.AIRPODS_CONNECTED)\n            addAction(AirPodsNotifications.AIRPODS_DISCONNECTED)\n        }\n\n        try {\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\n                registerReceiver(ancStatusReceiver, ancIntentFilter, RECEIVER_EXPORTED)\n                registerReceiver(availabilityReceiver, availabilityIntentFilter, RECEIVER_EXPORTED)\n            } else {\n                registerReceiver(ancStatusReceiver, ancIntentFilter)\n                registerReceiver(availabilityReceiver, availabilityIntentFilter)\n            }\n            sharedPreferences.registerOnSharedPreferenceChangeListener(preferenceChangeListener)\n            Log.d(\"AirPodsQSService\", \"Receivers registered\")\n        } catch (e: Exception) {\n            Log.e(\"AirPodsQSService\", \"Error registering receivers: $e\")\n        }\n\n        updateTile()\n    }\n\n    override fun onStopListening() {\n        super.onStopListening()\n        Log.d(\"AirPodsQSService\", \"onStopListening\")\n        try {\n            unregisterReceiver(ancStatusReceiver)\n            unregisterReceiver(availabilityReceiver)\n            sharedPreferences.unregisterOnSharedPreferenceChangeListener(preferenceChangeListener)\n            Log.d(\"AirPodsQSService\", \"Receivers unregistered\")\n        } catch (e: IllegalArgumentException) {\n            Log.e(\"AirPodsQSService\", \"Receiver not registered or already unregistered: $e\")\n        } catch (e: Exception) {\n            Log.e(\"AirPodsQSService\", \"Error unregistering receivers: $e\")\n        }\n    }\n\n    override fun onClick() {\n        super.onClick()\n        Log.d(\"AirPodsQSService\", \"onClick - Current state: $isAirPodsConnected, Current mode: $currentAncMode\")\n        if (!isAirPodsConnected) {\n            Log.d(\"AirPodsQSService\", \"Tile clicked but AirPods not connected.\")\n            return\n        }\n\n        val clickBehavior = sharedPreferences.getString(\"qs_click_behavior\", \"dialog\") ?: \"dialog\"\n\n        if (clickBehavior == \"dialog\") {\n            launchDialogActivity()\n        } else {\n            cycleAncMode()\n        }\n    }\n\n    private fun launchDialogActivity() {\n        try {\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.UPSIDE_DOWN_CAKE) {\n                val pendingIntent = PendingIntent.getActivity(\n                    this,\n                    0,\n                    Intent(this, QuickSettingsDialogActivity::class.java).apply {\n                        addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK)\n                    },\n                    PendingIntent.FLAG_IMMUTABLE or PendingIntent.FLAG_UPDATE_CURRENT\n                )\n                startActivityAndCollapse(pendingIntent)\n            } else {\n                val intent = Intent(this, QuickSettingsDialogActivity::class.java).apply {\n                    addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK)\n                }\n                @Suppress(\"DEPRECATION\")\n                @SuppressLint(\"StartActivityAndCollapseDeprecated\")\n                startActivityAndCollapse(intent)\n            }\n            Log.d(\"AirPodsQSService\", \"Called startActivityAndCollapse for QuickSettingsDialogActivity\")\n        } catch (e: Exception) {\n            Log.e(\"AirPodsQSService\", \"Error launching QuickSettingsDialogActivity: $e\")\n        }\n    }\n\n    private fun cycleAncMode() {\n        val service = ServiceManager.getService()\n        if (service == null) {\n            Log.d(\"AirPodsQSService\", \"Tile clicked (cycle mode) but service is null.\")\n            return\n        }\n        val nextMode = getNextAncMode()\n        Log.d(\"AirPodsQSService\", \"Cycling ANC mode to: $nextMode\")\n        service.aacpManager.sendControlCommand(\n            AACPManager.Companion.ControlCommandIdentifiers.LISTENING_MODE.value,\n            nextMode\n        )\n    }\n\n    private fun updateTile() {\n        val tile = qsTile ?: return\n        Log.d(\"AirPodsQSService\", \"updateTile - Connected: $isAirPodsConnected, Mode: $currentAncMode\")\n\n        val deviceName = sharedPreferences.getString(\"name\", \"AirPods\") ?: \"AirPods\"\n\n        if (isAirPodsConnected) {\n            tile.state = Tile.STATE_ACTIVE\n            tile.label = getModeLabel(currentAncMode)\n            tile.subtitle = deviceName\n            tile.icon = Icon.createWithResource(this, getModeIcon(currentAncMode))\n        } else {\n            tile.state = Tile.STATE_UNAVAILABLE\n            tile.label = \"AirPods\"\n            tile.subtitle = \"Disconnected\"\n            tile.icon = Icon.createWithResource(this, R.drawable.airpods)\n        }\n\n        try {\n            tile.updateTile()\n            Log.d(\"AirPodsQSService\", \"Tile updated successfully\")\n        } catch (e: Exception) {\n            Log.e(\"AirPodsQSService\", \"Error updating tile: $e\")\n        }\n    }\n\n    private fun isOffModeEnabled(): Boolean {\n        return sharedPreferences.getBoolean(\"off_listening_mode\", true)\n    }\n\n    private fun getAvailableModes(): List<Int> {\n        val modes = mutableListOf(\n            NoiseControlMode.TRANSPARENCY.ordinal + 1,\n            NoiseControlMode.ADAPTIVE.ordinal + 1,\n            NoiseControlMode.NOISE_CANCELLATION.ordinal + 1\n        )\n        if (isOffModeEnabled()) {\n            modes.add(0, NoiseControlMode.OFF.ordinal + 1)\n        }\n        return modes\n    }\n\n    private fun getNextAncMode(): Int {\n        val availableModes = getAvailableModes()\n        val currentIndex = availableModes.indexOf(currentAncMode)\n        val nextIndex = (currentIndex + 1) % availableModes.size\n        return availableModes[nextIndex]\n    }\n\n    private fun getModeLabel(mode: Int): String {\n        return when (mode) {\n            NoiseControlMode.OFF.ordinal + 1 -> \"Off\"\n            NoiseControlMode.TRANSPARENCY.ordinal + 1 -> \"Transparency\"\n            NoiseControlMode.ADAPTIVE.ordinal + 1 -> \"Adaptive\"\n            NoiseControlMode.NOISE_CANCELLATION.ordinal + 1 -> \"Noise Cancellation\"\n            else -> \"Unknown\"\n        }\n    }\n\n     private fun getModeIcon(mode: Int): Int {\n         return when (mode) {\n             NoiseControlMode.OFF.ordinal + 1 -> R.drawable.noise_cancellation\n             NoiseControlMode.TRANSPARENCY.ordinal + 1 -> R.drawable.transparency\n             NoiseControlMode.ADAPTIVE.ordinal + 1 -> R.drawable.adaptive\n             NoiseControlMode.NOISE_CANCELLATION.ordinal + 1 -> R.drawable.noise_cancellation\n             else -> R.drawable.airpods\n         }\n     }\n\n    override fun onTileAdded() {\n        super.onTileAdded()\n        Log.d(\"AirPodsQSService\", \"Tile added\")\n    }\n}\n"
        }
      ]
    },
    {
      "dir": "android/app/src/main/java/me/kavishdevar/librepods/constants",
      "files": [
        {
          "name": "Packets.kt",
          "ext": ".kt",
          "size": 9262,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n *\n * Copyright (C) 2025 LibrePods contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\npackage me.kavishdevar.librepods.constants\n\nimport android.os.Parcelable\nimport android.util.Log\nimport kotlinx.parcelize.Parcelize\n\nenum class Enums(val value: ByteArray) {\n    NOISE_CANCELLATION(Capabilities.NOISE_CANCELLATION),\n    PREFIX(byteArrayOf(0x04, 0x00, 0x04, 0x00)),\n    SETTINGS(byteArrayOf(0x09, 0x00)),\n    NOISE_CANCELLATION_PREFIX(PREFIX.value + SETTINGS.value + NOISE_CANCELLATION.value),\n    CONVERSATION_AWARENESS_RECEIVE_PREFIX(PREFIX.value + byteArrayOf(0x4b, 0x00, 0x02, 0x00)),\n}\n\nobject BatteryComponent {\n    const val LEFT = 4\n    const val RIGHT = 2\n    const val CASE = 8\n}\n\nobject BatteryStatus {\n    const val CHARGING = 1\n    const val NOT_CHARGING = 2\n    const val DISCONNECTED = 4\n}\n\n@Parcelize\ndata class Battery(val component: Int, val level: Int, val status: Int) : Parcelable {\n    fun getComponentName(): String? {\n        return when (component) {\n            BatteryComponent.LEFT -> \"LEFT\"\n            BatteryComponent.RIGHT -> \"RIGHT\"\n            BatteryComponent.CASE -> \"CASE\"\n            else -> null\n        }\n    }\n\n    fun getStatusName(): String? {\n        return when (status) {\n            BatteryStatus.CHARGING -> \"CHARGING\"\n            BatteryStatus.NOT_CHARGING -> \"NOT_CHARGING\"\n            BatteryStatus.DISCONNECTED -> \"DISCONNECTED\"\n            else -> null\n        }\n    }\n}\n\nenum class NoiseControlMode {\n    OFF,  NOISE_CANCELLATION, TRANSPARENCY, ADAPTIVE\n}\n\nclass AirPodsNotifications {\n    companion object {\n        const val AIRPODS_CONNECTED = \"me.kavishdevar.librepods.AIRPODS_CONNECTED\"\n        const val AIRPODS_DATA = \"me.kavishdevar.librepods.AIRPODS_DATA\"\n        const val EAR_DETECTION_DATA = \"me.kavishdevar.librepods.EAR_DETECTION_DATA\"\n        const val ANC_DATA = \"me.kavishdevar.librepods.ANC_DATA\"\n        const val BATTERY_DATA = \"me.kavishdevar.librepods.BATTERY_DATA\"\n        const val CA_DATA = \"me.kavishdevar.librepods.CA_DATA\"\n        const val AIRPODS_DISCONNECTED = \"me.kavishdevar.librepods.AIRPODS_DISCONNECTED\"\n        const val AIRPODS_CONNECTION_DETECTED = \"me.kavishdevar.librepods.AIRPODS_CONNECTION_DETECTED\"\n        const val DISCONNECT_RECEIVERS = \"me.kavishdevar.librepods.DISCONNECT_RECEIVERS\"\n    }\n\n    class EarDetection {\n        private val notificationBit = Capabilities.EAR_DETECTION\n        private val notificationPrefix = Enums.PREFIX.value + notificationBit\n\n        var status: List<Byte> = listOf(0x01, 0x01)\n\n        fun setStatus(data: ByteArray) {\n            status = listOf(data[6], data[7])\n        }\n\n        fun isEarDetectionData(data: ByteArray): Boolean {\n            if (data.size != 8) {\n                return false\n            }\n            val prefixHex = notificationPrefix.joinToString(\"\") { \"%02x\".format(it) }\n            val dataHex = data.joinToString(\"\") { \"%02x\".format(it) }\n            return dataHex.startsWith(prefixHex)\n        }\n    }\n\n    class ANC {\n        private val notificationPrefix = Enums.NOISE_CANCELLATION_PREFIX.value\n\n        var status: Int = 1\n            private set\n\n        fun isANCData(data: ByteArray): Boolean {\n            if (data.size != 11) {\n                return false\n            }\n            val prefixHex = notificationPrefix.joinToString(\"\") { \"%02x\".format(it) }\n            val dataHex = data.joinToString(\"\") { \"%02x\".format(it) }\n            return dataHex.startsWith(prefixHex)\n        }\n\n        fun setStatus(data: ByteArray) {\n            when (data.size) {\n                // if the whole packet is given\n                11 -> {\n                    status = data[7].toInt()\n                }\n                // if only the data is given\n                1 -> {\n                    status = data[0].toInt()\n                }\n                // if the value of control command is given\n                4 -> {\n                    status = data[0].toInt()\n                }\n                else -> {\n                    Log.d(\"ANC\", \"Invalid ANC data size: ${data.size}\")\n                }\n            }\n        }\n\n        val name: String =\n            when (status) {\n                1 -> \"OFF\"\n                2 -> \"ON\"\n                3 -> \"TRANSPARENCY\"\n                4 -> \"ADAPTIVE\"\n                else -> \"UNKNOWN\"\n            }\n\n    }\n\n    class BatteryNotification {\n        private var first: Battery = Battery(BatteryComponent.LEFT, 0, BatteryStatus.DISCONNECTED)\n        private var second: Battery = Battery(BatteryComponent.RIGHT, 0, BatteryStatus.DISCONNECTED)\n        private var case: Battery = Battery(BatteryComponent.CASE, 0, BatteryStatus.DISCONNECTED)\n\n        fun isBatteryData(data: ByteArray): Boolean {\n            if (data.joinToString(\"\") { \"%02x\".format(it) }.startsWith(\"040004000400\")) {\n                Log.d(\"BatteryNotification\", \"Battery data starts with 040004000400. Most likely is a battery packet.\")\n            } else {\n                return false\n            }\n            if (data.size != 22) {\n                Log.d(\"BatteryNotification\", \"Battery data size is not 22, probably being used with Airpods with fewer or more battery count.\")\n                return false\n            }\n            Log.d(\"BatteryNotification\", data.joinToString(\"\") { \"%02x\".format(it) }.startsWith(\"040004000400\").toString())\n            return data.joinToString(\"\") { \"%02x\".format(it) }.startsWith(\"040004000400\")\n        }\n\n        fun setBatteryDirect(\n            leftLevel: Int,\n            leftCharging: Boolean,\n            rightLevel: Int,\n            rightCharging: Boolean,\n            caseLevel: Int,\n            caseCharging: Boolean\n        ) {\n            first = Battery(BatteryComponent.LEFT, leftLevel, if (leftCharging) BatteryStatus.CHARGING else BatteryStatus.NOT_CHARGING)\n            second = Battery(BatteryComponent.RIGHT, rightLevel, if (rightCharging) BatteryStatus.CHARGING else BatteryStatus.NOT_CHARGING)\n            case = Battery(BatteryComponent.CASE, caseLevel, if (caseCharging) BatteryStatus.CHARGING else BatteryStatus.NOT_CHARGING)\n        }\n\n        fun setBattery(data: ByteArray) {\n            if (data.size != 22) {\n                return\n            }\n            first = if (data[10].toInt() == BatteryStatus.DISCONNECTED) {\n                Battery(first.component, first.level, data[10].toInt())\n            } else {\n                Battery(data[7].toInt(), data[9].toInt(), data[10].toInt())\n            }\n            second = if (data[15].toInt() == BatteryStatus.DISCONNECTED) {\n                Battery(second.component, second.level, data[15].toInt())\n            } else {\n                Battery(data[12].toInt(), data[14].toInt(), data[15].toInt())\n            }\n            case = if (data[20].toInt() == BatteryStatus.DISCONNECTED && case.status != BatteryStatus.DISCONNECTED) {\n                Battery(case.component, case.level, data[20].toInt())\n            } else {\n                Battery(data[17].toInt(), data[19].toInt(), data[20].toInt())\n            }\n        }\n\n        fun getBattery(): List<Battery> {\n            val left = if (first.component == BatteryComponent.LEFT) first else second\n            val right = if (first.component == BatteryComponent.LEFT) second else first\n            return listOf(left, right, case)\n        }\n    }\n\n    class ConversationalAwarenessNotification {\n        @Suppress(\"PrivatePropertyName\")\n        private val NOTIFICATION_PREFIX = Enums.CONVERSATION_AWARENESS_RECEIVE_PREFIX.value\n\n        var status: Byte = 0\n            private set\n\n        fun isConversationalAwarenessData(data: ByteArray): Boolean {\n            if (data.size != 10) {\n                return false\n            }\n            val prefixHex = NOTIFICATION_PREFIX.joinToString(\"\") { \"%02x\".format(it) }\n            val dataHex = data.joinToString(\"\") { \"%02x\".format(it) }\n            return dataHex.startsWith(prefixHex)\n        }\n\n        fun setData(data: ByteArray) {\n            status = data[9]\n        }\n    }\n}\n\nclass Capabilities {\n    companion object {\n        val NOISE_CANCELLATION = byteArrayOf(0x0d)\n        val EAR_DETECTION = byteArrayOf(0x06)\n    }\n}\n\nfun isHeadTrackingData(data: ByteArray): Boolean {\n    if (data.size <= 60) return false\n\n    val prefixPattern = byteArrayOf(\n        0x04, 0x00, 0x04, 0x00, 0x17, 0x00, 0x00, 0x00,\n        0x10, 0x00\n    )\n\n    for (i in prefixPattern.indices) {\n        if (data[i] != prefixPattern[i].toByte()) return false\n    }\n\n    if (data[10] != 0x44.toByte() && data[10] != 0x45.toByte()) return false\n\n    if (data[11] != 0x00.toByte()) return false\n\n    return true\n}\n"
        },
        {
          "name": "StemAction.kt",
          "ext": ".kt",
          "size": 1618,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n *\n * Copyright (C) 2025 LibrePods contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\npackage me.kavishdevar.librepods.constants\n\nimport me.kavishdevar.librepods.constants.StemAction.entries\nimport me.kavishdevar.librepods.utils.AACPManager\n\nenum class StemAction {\n    PLAY_PAUSE,\n    PREVIOUS_TRACK,\n    NEXT_TRACK,\n    CAMERA_SHUTTER,\n    DIGITAL_ASSISTANT,\n    CYCLE_NOISE_CONTROL_MODES;\n    companion object {\n        fun fromString(action: String): StemAction? {\n            return entries.find { it.name == action }\n        }\n        val defaultActions: Map<AACPManager.Companion.StemPressType, StemAction> = mapOf(\n            AACPManager.Companion.StemPressType.SINGLE_PRESS to PLAY_PAUSE,\n            AACPManager.Companion.StemPressType.DOUBLE_PRESS to NEXT_TRACK,\n            AACPManager.Companion.StemPressType.TRIPLE_PRESS to PREVIOUS_TRACK,\n            AACPManager.Companion.StemPressType.LONG_PRESS to CYCLE_NOISE_CONTROL_MODES,\n        )\n    }\n}\n"
        }
      ]
    },
    {
      "dir": "android/app/src/main/java/me/kavishdevar/librepods/composables",
      "files": [
        {
          "name": "StyledSwitch.kt",
          "ext": ".kt",
          "size": 3015,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n * \n * Copyright (C) 2025 LibrePods contributors\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n * \n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\npackage me.kavishdevar.librepods.composables\n\nimport androidx.compose.animation.core.animateDpAsState\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.clickable\nimport androidx.compose.foundation.isSystemInDarkTheme\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.offset\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.size\nimport androidx.compose.foundation.layout.width\nimport androidx.compose.foundation.shape.CircleShape\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.clip\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.tooling.preview.Preview\nimport androidx.compose.ui.unit.dp\n\n@Composable\nfun StyledSwitch(\n    checked: Boolean,\n    onCheckedChange: (Boolean) -> Unit,\n    enabled: Boolean = true,\n) {\n    val isDarkTheme = isSystemInDarkTheme()\n\n    val thumbColor = Color.White\n    val trackColor = if (enabled) (\n        if (isDarkTheme) {\n            if (checked) Color(0xFF34C759) else Color(0xFF5B5B5E)\n        } else {\n            if (checked) Color(0xFF34C759) else Color(0xFFD1D1D6)\n        }\n    ) else {\n        if (isDarkTheme) Color(0xFF5B5B5E) else Color(0xFFD1D1D6)\n    }\n\n\n    val thumbOffsetX by animateDpAsState(targetValue = if (checked) 20.dp else 0.dp, label = \"Test\")\n\n    Box(\n        modifier = Modifier\n            .width(51.dp)\n            .height(31.dp)\n            .clip(RoundedCornerShape(15.dp))\n            .background(trackColor) // Dynamic track background\n            .padding(horizontal = 3.dp),\n        contentAlignment = Alignment.CenterStart\n    ) {\n        Box(\n            modifier = Modifier\n                .offset(x = thumbOffsetX)\n                .size(27.dp)\n                .clip(CircleShape)\n                .background(thumbColor)\n                .clickable { if (enabled) onCheckedChange(!checked) }\n        )\n    }\n}\n\n@Preview\n@Composable\nfun StyledSwitchPreview() {\n    StyledSwitch(checked = true, onCheckedChange = {})\n}"
        },
        {
          "name": "NavigationButton.kt",
          "ext": ".kt",
          "size": 4126,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n * \n * Copyright (C) 2025 LibrePods contributors\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n * \n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\npackage me.kavishdevar.librepods.composables\n\nimport androidx.compose.animation.animateColorAsState\nimport androidx.compose.animation.core.tween\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.gestures.detectTapGestures\nimport androidx.compose.foundation.isSystemInDarkTheme\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.Spacer\nimport androidx.compose.foundation.layout.fillMaxHeight\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.KeyboardArrowRight\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.IconButton\nimport androidx.compose.material3.IconButtonDefaults\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.input.pointer.pointerInput\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.tooling.preview.Preview\nimport androidx.compose.ui.unit.dp\nimport androidx.navigation.NavController\n\n\n@Composable\nfun NavigationButton(to: String, name: String, navController: NavController) {\n    val isDarkTheme = isSystemInDarkTheme()\n    var backgroundColor by remember { mutableStateOf(if (isDarkTheme) Color(0xFF1C1C1E) else Color(0xFFFFFFFF)) }\n    val animatedBackgroundColor by animateColorAsState(targetValue = backgroundColor, animationSpec = tween(durationMillis = 500))\n\n    Row(\n        modifier = Modifier\n            .background(animatedBackgroundColor, RoundedCornerShape(14.dp))\n            .height(55.dp)\n            .pointerInput(Unit) {\n                detectTapGestures(\n                    onPress = {\n                        backgroundColor = if (isDarkTheme) Color(0x40888888) else Color(0x40D9D9D9)\n                        tryAwaitRelease()\n                        backgroundColor = if (isDarkTheme) Color(0xFF1C1C1E) else Color(0xFFFFFFFF)\n                    },\n                    onTap = {\n                        navController.navigate(to)\n                    }\n                )\n            }\n    ) {\n        Text(\n            text = name,\n            modifier = Modifier.padding(16.dp),\n            color = if (isDarkTheme) Color.White else Color.Black\n        )\n        Spacer(modifier = Modifier.weight(1f))\n        IconButton(\n            onClick = { navController.navigate(to) },\n            colors = IconButtonDefaults.iconButtonColors(\n                containerColor = Color.Transparent,\n                contentColor = if (isDarkTheme) Color.White else Color.Black\n            ),\n            modifier = Modifier\n                .padding(start = 16.dp)\n                .fillMaxHeight()\n        ) {\n            @Suppress(\"DEPRECATION\")\n            Icon(\n                imageVector = Icons.Default.KeyboardArrowRight,\n                contentDescription = name\n            )\n        }\n    }\n}\n\n@Preview\n@Composable\nfun NavigationButtonPreview() {\n    NavigationButton(\"to\", \"Name\", NavController(LocalContext.current))\n}"
        },
        {
          "name": "NoiseControlButton.kt",
          "ext": ".kt",
          "size": 2653,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n * \n * Copyright (C) 2025 LibrePods contributors\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n * \n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\npackage me.kavishdevar.librepods.composables\n\nimport androidx.compose.foundation.clickable\nimport androidx.compose.foundation.interaction.MutableInteractionSource\nimport androidx.compose.foundation.layout.Arrangement\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.fillMaxHeight\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.size\nimport androidx.compose.material3.Icon\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.remember\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.graphics.ImageBitmap\nimport androidx.compose.ui.res.imageResource\nimport androidx.compose.ui.tooling.preview.Preview\nimport androidx.compose.ui.unit.dp\nimport me.kavishdevar.librepods.R\n\n@Composable\nfun NoiseControlButton(\n    icon: ImageBitmap,\n    onClick: () -> Unit,\n    textColor: Color,\n    modifier: Modifier = Modifier,\n    usePadding: Boolean = true\n) {\n    Column(\n        modifier = modifier\n            .fillMaxHeight()\n            .then(if (usePadding) Modifier.padding(horizontal = 4.dp, vertical = 4.dp) else Modifier)\n            .clickable(\n                onClick = onClick,\n                indication = null,\n                interactionSource = remember { MutableInteractionSource() }\n            ),\n        horizontalAlignment = Alignment.CenterHorizontally,\n        verticalArrangement = Arrangement.Center\n    ) {\n        Icon(\n            bitmap = icon,\n            contentDescription = null,\n            tint = textColor,\n            modifier = Modifier.size(40.dp)\n        )\n    }\n}\n\n@Preview\n@Composable\nfun NoiseControlButtonPreview() {\n    NoiseControlButton(\n        icon = ImageBitmap.imageResource(R.drawable.noise_cancellation),\n        onClick = {},\n        textColor = Color.White,\n    )\n}"
        },
        {
          "name": "CustomDropdown.kt",
          "ext": ".kt",
          "size": 6731,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n *\n * Copyright (C) 2025 LibrePods contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\npackage me.kavishdevar.librepods.composables\n\nimport androidx.compose.animation.core.Spring\nimport androidx.compose.animation.core.animateDpAsState\nimport androidx.compose.animation.core.animateFloatAsState\nimport androidx.compose.animation.core.spring\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.clickable\nimport androidx.compose.foundation.interaction.MutableInteractionSource\nimport androidx.compose.foundation.isSystemInDarkTheme\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.Spacer\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.widthIn\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.scale\nimport androidx.compose.ui.geometry.Offset\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.layout.onGloballyPositioned\nimport androidx.compose.ui.platform.LocalDensity\nimport androidx.compose.ui.text.font.Font\nimport androidx.compose.ui.text.font.FontFamily\nimport androidx.compose.ui.tooling.preview.Preview\nimport androidx.compose.ui.unit.IntOffset\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport androidx.compose.ui.window.Popup\nimport androidx.compose.ui.window.PopupProperties\nimport me.kavishdevar.librepods.R\n\nclass DropdownItem(val name: String, val onSelect: () -> Unit) {\n    fun select() {\n        onSelect()\n    }\n}\n\n@Composable\nfun CustomDropdown(name: String, description: String = \"\", items: List<DropdownItem>) {\n    val isDarkTheme = isSystemInDarkTheme()\n    val textColor = if (isDarkTheme) Color.White else Color.Black\n    val backgroundColor = if (isDarkTheme) Color(0xFF1C1C1E) else Color(0xFFFFFFFF)\n    var expanded by remember { mutableStateOf(false) }\n    var offset by remember { mutableStateOf(IntOffset.Zero) }\n    var popupHeight by remember { mutableStateOf(0.dp) }\n\n    val animatedHeight by animateDpAsState(\n        targetValue = if (expanded) popupHeight else 0.dp,\n        animationSpec = spring(dampingRatio = Spring.DampingRatioMediumBouncy, stiffness = Spring.StiffnessLow)\n    )\n    val animatedScale by animateFloatAsState(\n        targetValue = if (expanded) 1f else 0f,\n        animationSpec = spring(dampingRatio = Spring.DampingRatioMediumBouncy, stiffness = Spring.StiffnessLow)\n    )\n\n    Row(\n        modifier = Modifier\n            .fillMaxWidth()\n            .background(\n                shape = RoundedCornerShape(14.dp),\n                color = Color.Transparent\n            )\n            .padding(horizontal = 12.dp, vertical = 12.dp)\n            .clickable(\n                indication = null,\n                interactionSource = remember { MutableInteractionSource() }\n            ) {\n                expanded = true\n            }\n            .onGloballyPositioned { coordinates ->\n                val windowPosition = coordinates.localToWindow(Offset.Zero)\n                offset = IntOffset(windowPosition.x.toInt(), windowPosition.y.toInt() + coordinates.size.height)\n            },\n        verticalAlignment = Alignment.CenterVertically\n    ) {\n        Column(\n            modifier = Modifier\n                .weight(1f)\n                .padding(end = 4.dp)\n        ) {\n            Text(\n                text = name,\n                fontSize = 16.sp,\n                color = textColor,\n                maxLines = 1\n            )\n            if (description.isNotEmpty()) {\n                Spacer(modifier = Modifier.height(4.dp))\n                Text(\n                    text = description,\n                    fontSize = 12.sp,\n                    color = textColor.copy(0.6f),\n                    lineHeight = 14.sp,\n                    maxLines = 1\n                )\n            }\n        }\n        Text(\n            text = \"\\uDBC0\\uDD8F\",\n            fontSize = 16.sp,\n            fontFamily = FontFamily(Font(R.font.sf_pro)),\n            color = textColor\n        )\n    }\n\n    if (expanded) {\n        Popup(\n            alignment = Alignment.TopStart,\n            offset = offset ,\n            properties = PopupProperties(focusable = true),\n            onDismissRequest = { expanded = false }\n        ) {\n            val density = LocalDensity.current\n            Column(\n                modifier = Modifier\n                    .background(backgroundColor, RoundedCornerShape(8.dp))\n                    .padding(8.dp)\n                    .widthIn(max = 50.dp)\n                    .height(animatedHeight)\n                    .scale(animatedScale)\n                    .onGloballyPositioned { coordinates ->\n                        popupHeight = with(density) { coordinates.size.height.toDp() }\n                    }\n            ) {\n                items.forEach { item ->\n                    Text(\n                        text = item.name,\n                        modifier = Modifier\n                            .fillMaxWidth()\n                            .clickable {\n                                item.select()\n                                expanded = false\n                            }\n                            .padding(8.dp),\n                        color = textColor\n                    )\n                }\n            }\n        }\n    }\n}\n\n@Preview\n@Composable\nfun CustomDropdownPreview() {\n    CustomDropdown(\n        name = \"Volume Swipe Speed\",\n        items = listOf(\n            DropdownItem(\"Always On\") { },\n            DropdownItem(\"Off\") { },\n            DropdownItem(\"Only when speaking\") { }\n        )\n    )\n}\n"
        },
        {
          "name": "ControlCenterButton.kt",
          "ext": ".kt",
          "size": 3751,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n *\n * Copyright (C) 2025 LibrePods Contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n \npackage me.kavishdevar.librepods.composables\n\nimport androidx.compose.animation.animateColorAsState\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.clickable\nimport androidx.compose.foundation.interaction.MutableInteractionSource\nimport androidx.compose.foundation.layout.Arrangement\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Spacer\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.size\nimport androidx.compose.foundation.shape.CircleShape\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.remember\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.clip\nimport androidx.compose.ui.graphics.Brush\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.graphics.painter.Painter\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.text.style.TextAlign\nimport androidx.compose.ui.unit.Dp\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\n\nprivate val SelectedColorBlue = Color(0xFF0A84FF)\nprivate val UnselectedColor = Color(0x593C3C3E)\nprivate val TextColor = Color.White\nprivate val IconTint = Color.White\n\n@Composable\nfun ControlCenterButton(\n    label: String,\n    icon: Painter,\n    onClick: () -> Unit,\n    modifier: Modifier = Modifier,\n    iconAreaSize: Dp,\n    isSelected: Boolean,\n    backgroundBrush: Brush? = null\n) {\n    val targetBackgroundColor = if (isSelected) SelectedColorBlue else UnselectedColor\n    val backgroundColor by animateColorAsState(\n        targetValue = targetBackgroundColor,\n        label = \"ButtonBackground\"\n    )\n\n    Column(\n        modifier = modifier,\n        horizontalAlignment = Alignment.CenterHorizontally,\n        verticalArrangement = Arrangement.Center\n    ) {\n        Box(\n            modifier = Modifier\n                .size(iconAreaSize)\n                .clip(CircleShape)\n                .background(backgroundBrush ?: Brush.linearGradient(colors=listOf(backgroundColor, backgroundColor)))\n                .clickable(\n                    onClick = onClick,\n                    indication = null,\n                    interactionSource = remember { MutableInteractionSource() }\n                ),\n            contentAlignment = Alignment.Center\n        ) {\n            Icon(\n                painter = icon,\n                contentDescription = null,\n                tint = IconTint,\n                modifier = Modifier.size(32.dp)\n            )\n        }\n        Spacer(modifier = Modifier.height(8.dp))\n        Text(\n            text = label,\n            color = TextColor,\n            fontSize = 12.sp,\n            fontWeight = FontWeight.Medium,\n            textAlign = TextAlign.Center,\n            maxLines = 2\n        )\n    }\n}\n"
        },
        {
          "name": "BatteryIndicator.kt",
          "ext": ".kt",
          "size": 5116,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n * \n * Copyright (C) 2025 LibrePods contributors\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n * \n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\npackage me.kavishdevar.librepods.composables\n\n\nimport androidx.compose.animation.core.animateFloatAsState\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.border\nimport androidx.compose.foundation.layout.Arrangement\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.fillMaxHeight\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.width\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.scale\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.text.TextStyle\nimport androidx.compose.ui.text.font.Font\nimport androidx.compose.ui.text.font.FontFamily\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.text.style.TextAlign\nimport androidx.compose.ui.tooling.preview.Preview\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport me.kavishdevar.librepods.R\n\n@Composable\nfun BatteryIndicator(batteryPercentage: Int, charging: Boolean = false) {\n    val batteryOutlineColor = Color(0xFFBFBFBF)\n    val batteryFillColor = if (batteryPercentage > 30) Color(0xFF30D158) else Color(0xFFFC3C3C)\n    val batteryTextColor = MaterialTheme.colorScheme.onSurface\n\n    val batteryWidth = 40.dp\n    val batteryHeight = 15.dp\n    val batteryCornerRadius = 4.dp\n    val tipWidth = 5.dp\n    val tipHeight = batteryHeight * 0.375f\n\n    val animatedFillWidth by animateFloatAsState(targetValue = batteryPercentage / 100f)\n    val animatedScale by animateFloatAsState(targetValue = if (charging) 1.2f else 1f)\n\n    Column(\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        Row(\n            verticalAlignment = Alignment.CenterVertically,\n            horizontalArrangement = Arrangement.spacedBy(0.dp),\n            modifier = Modifier.padding(bottom = 4.dp)\n        ) {\n            Box(\n                modifier = Modifier\n                    .width(batteryWidth)\n                    .height(batteryHeight)\n            ) {\n                Box (\n                    modifier = Modifier\n                        .fillMaxSize()\n                        .border(1.dp, batteryOutlineColor, RoundedCornerShape(batteryCornerRadius))\n                )\n                Box(\n                    modifier = Modifier\n                        .fillMaxHeight()\n                        .padding(2.dp)\n                        .width(batteryWidth * animatedFillWidth)\n                        .background(batteryFillColor, RoundedCornerShape(2.dp))\n                )\n                if (charging) {\n                    Text(\n                        text = \"\\uDBC0\\uDEE6\",\n                        fontSize = 16.sp,\n                        fontFamily = FontFamily(Font(R.font.sf_pro)),\n                        color = Color.White,\n                        modifier = Modifier\n                            .scale(animatedScale)\n                            .fillMaxSize(),\n                        textAlign = TextAlign.Center\n                    )\n                }\n            }\n            Box(\n                modifier = Modifier\n                    .width(tipWidth)\n                    .height(tipHeight)\n                    .padding(start = 1.dp)\n                    .background(\n                        batteryOutlineColor,\n                        RoundedCornerShape(\n                            topStart = 0.dp,\n                            topEnd = 12.dp,\n                            bottomStart = 0.dp,\n                            bottomEnd = 12.dp\n                        )\n                    )\n            )\n        }\n\n        Text(\n            text = \"$batteryPercentage%\",\n            color = batteryTextColor,\n            style = TextStyle(fontSize = 16.sp, fontWeight = FontWeight.Bold)\n        )\n    }\n}\n\n@Preview\n@Composable\nfun BatteryIndicatorPreview() {\n    BatteryIndicator(batteryPercentage = 48, charging = true)\n}"
        },
        {
          "name": "AdaptiveStrengthSlider.kt",
          "ext": ".kt",
          "size": 5872,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n *\n * Copyright (C) 2025 LibrePods contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\n@file:OptIn(ExperimentalEncodingApi::class)\n\npackage me.kavishdevar.librepods.composables\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.isSystemInDarkTheme\nimport androidx.compose.foundation.layout.Arrangement\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.size\nimport androidx.compose.foundation.shape.CircleShape\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.Slider\nimport androidx.compose.material3.SliderDefaults\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.mutableFloatStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.shadow\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.text.TextStyle\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.tooling.preview.Preview\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport me.kavishdevar.librepods.services.ServiceManager\nimport me.kavishdevar.librepods.utils.AACPManager\nimport kotlin.io.encoding.ExperimentalEncodingApi\nimport kotlin.math.roundToInt\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun AdaptiveStrengthSlider() {\n    val sliderValue = remember { mutableFloatStateOf(0f) }\n    val service = ServiceManager.getService()!!\n    LaunchedEffect(sliderValue) {\n        val sliderValueFromAACP = service.aacpManager.controlCommandStatusList.find {\n            it.identifier == AACPManager.Companion.ControlCommandIdentifiers.AUTO_ANC_STRENGTH\n        }?.value?.takeIf { it.isNotEmpty() }?.get(0)\n        sliderValueFromAACP?.toFloat()?.let { sliderValue.floatValue = (100 - it) }\n    }\n\n    val isDarkTheme = isSystemInDarkTheme()\n\n    val trackColor = if (isDarkTheme) Color(0xFFB3B3B3) else Color(0xFFD9D9D9)\n    val thumbColor = if (isDarkTheme) Color(0xFFFFFFFF) else Color(0xFFFFFFFF)\n    val labelTextColor = if (isDarkTheme) Color.White else Color.Black\n\n    Column(\n        modifier = Modifier\n            .fillMaxWidth()\n            .padding(horizontal = 8.dp),\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        Slider(\n            value = sliderValue.floatValue,\n            onValueChange = {\n                sliderValue.floatValue = it\n            },\n            valueRange = 0f..100f,\n            onValueChangeFinished = {\n                sliderValue.floatValue = sliderValue.floatValue.roundToInt().toFloat()\n                service.aacpManager.sendControlCommand(\n                    identifier = AACPManager.Companion.ControlCommandIdentifiers.AUTO_ANC_STRENGTH.value,\n                    value = (100 - sliderValue.floatValue).toInt()\n                )\n            },\n            modifier = Modifier\n                .fillMaxWidth()\n                .height(36.dp),\n            colors = SliderDefaults.colors(\n                thumbColor = thumbColor,\n                inactiveTrackColor = trackColor\n            ),\n            thumb = {\n                Box(\n                    modifier = Modifier\n                        .size(24.dp)\n                        .shadow(4.dp, CircleShape)\n                        .background(thumbColor, CircleShape)\n                )\n            },\n            track = {\n                Box(\n                    modifier = Modifier\n                        .fillMaxWidth()\n                        .height(12.dp),\n                    contentAlignment = Alignment.CenterStart\n                )\n                {\n                    Box(\n                        modifier = Modifier\n                            .fillMaxWidth()\n                            .height(4.dp)\n                            .background(trackColor, RoundedCornerShape(4.dp))\n                    )\n                }\n\n            }\n        )\n\n        Row(\n            modifier = Modifier.fillMaxWidth(),\n            horizontalArrangement = Arrangement.SpaceBetween\n        ) {\n            Text(\n                text = \"Less Noise\",\n                style = TextStyle(\n                    fontSize = 14.sp,\n                    fontWeight = FontWeight.Light,\n                    color = labelTextColor\n                ),\n                modifier = Modifier.padding(start = 4.dp)\n            )\n            Text(\n                text = \"More Noise\",\n                style = TextStyle(\n                    fontSize = 14.sp,\n                    fontWeight = FontWeight.Light,\n                    color = labelTextColor\n                ),\n                modifier = Modifier.padding(end = 4.dp)\n            )\n        }\n    }\n}\n\n@Preview\n@Composable\nfun AdaptiveStrengthSliderPreview() {\n    AdaptiveStrengthSlider()\n}\n"
        },
        {
          "name": "SinglePodANCSwitch.kt",
          "ext": ".kt",
          "size": 4768,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n *\n * Copyright (C) 2025 LibrePods contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\n@file:OptIn(ExperimentalEncodingApi::class)\n\npackage me.kavishdevar.librepods.composables\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.clickable\nimport androidx.compose.foundation.gestures.detectTapGestures\nimport androidx.compose.foundation.interaction.MutableInteractionSource\nimport androidx.compose.foundation.isSystemInDarkTheme\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.Spacer\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.input.pointer.pointerInput\nimport androidx.compose.ui.tooling.preview.Preview\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport me.kavishdevar.librepods.services.ServiceManager\nimport me.kavishdevar.librepods.utils.AACPManager\nimport kotlin.io.encoding.ExperimentalEncodingApi\n\n@Composable\nfun SinglePodANCSwitch() {\n    val service = ServiceManager.getService()!!\n    val singleANCEnabledValue = service.aacpManager.controlCommandStatusList.find {\n        it.identifier == AACPManager.Companion.ControlCommandIdentifiers.ONE_BUD_ANC_MODE\n    }?.value?.takeIf { it.isNotEmpty() }?.get(0)\n    var singleANCEnabled by remember {\n        mutableStateOf(\n            singleANCEnabledValue == 1.toByte()\n        )\n    }\n\n    fun updateSingleEnabled(enabled: Boolean) {\n        singleANCEnabled = enabled\n        service.aacpManager.sendControlCommand(\n            AACPManager.Companion.ControlCommandIdentifiers.ONE_BUD_ANC_MODE.value,\n            enabled\n        )\n    }\n\n    val isDarkTheme = isSystemInDarkTheme()\n    val textColor = if (isDarkTheme) Color.White else Color.Black\n\n    val isPressed = remember { mutableStateOf(false) }\n\n    Row(\n        modifier = Modifier\n            .fillMaxWidth()\n            .background(\n                shape = RoundedCornerShape(14.dp),\n                color = if (isPressed.value) Color(0xFFE0E0E0) else Color.Transparent\n            )\n            .padding(horizontal = 12.dp, vertical = 12.dp)\n            .pointerInput(Unit) {\n                detectTapGestures(\n                    onPress = {\n                        isPressed.value = true\n                        tryAwaitRelease()\n                        isPressed.value = false\n                    }\n                )\n            }\n            .clickable(\n                indication = null,\n                interactionSource = remember { MutableInteractionSource() }\n            ) {\n                updateSingleEnabled(!singleANCEnabled)\n            },\n        verticalAlignment = Alignment.CenterVertically\n    ) {\n        Column(\n            modifier = Modifier\n                .weight(1f)\n                .padding(end = 4.dp)\n        ) {\n            Text(\n                text = \"Noise Cancellation with Single AirPod\",\n                fontSize = 16.sp,\n                color = textColor\n            )\n            Spacer(modifier = Modifier.height(4.dp))\n            Text(\n                text = \"Allow AirPods to be put in noise cancellation mode when only one AirPods is in your ear.\",\n                fontSize = 12.sp,\n                color = textColor.copy(0.6f),\n                lineHeight = 14.sp,\n            )\n        }\n        StyledSwitch(\n            checked = singleANCEnabled,\n            onCheckedChange = {\n                updateSingleEnabled(it)\n            },\n        )\n    }\n}\n\n@Preview\n@Composable\nfun SinglePodANCSwitchPreview() {\n    SinglePodANCSwitch()\n}\n"
        },
        {
          "name": "PressAndHoldSettings.kt",
          "ext": ".kt",
          "size": 9560,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n *\n * Copyright (C) 2025 LibrePods contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\npackage me.kavishdevar.librepods.composables\n\nimport android.content.Context\nimport androidx.compose.animation.animateColorAsState\nimport androidx.compose.animation.core.tween\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.gestures.detectTapGestures\nimport androidx.compose.foundation.isSystemInDarkTheme\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.Spacer\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.automirrored.filled.KeyboardArrowRight\nimport androidx.compose.material3.HorizontalDivider\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.IconButton\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.input.pointer.pointerInput\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.text.TextStyle\nimport androidx.compose.ui.text.font.Font\nimport androidx.compose.ui.text.font.FontFamily\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.tooling.preview.Preview\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport androidx.navigation.NavController\nimport me.kavishdevar.librepods.R\nimport me.kavishdevar.librepods.constants.StemAction\n\n@Composable\nfun PressAndHoldSettings(navController: NavController) {\n    val isDarkTheme = isSystemInDarkTheme()\n    val textColor = if (isDarkTheme) Color.White else Color.Black\n    val dividerColor = Color(0x40888888)\n    var leftBackgroundColor by remember { mutableStateOf(if (isDarkTheme) Color(0xFF1C1C1E) else Color(0xFFFFFFFF)) }\n    var rightBackgroundColor by remember { mutableStateOf(if (isDarkTheme) Color(0xFF1C1C1E) else Color(0xFFFFFFFF)) }\n\n    val animationSpec = tween<Color>(durationMillis = 500)\n    val animatedLeftBackgroundColor by animateColorAsState(targetValue = leftBackgroundColor, animationSpec = animationSpec)\n    val animatedRightBackgroundColor by animateColorAsState(targetValue = rightBackgroundColor, animationSpec = animationSpec)\n\n    val context = LocalContext.current\n    val sharedPreferences = context.getSharedPreferences(\"settings\", Context.MODE_PRIVATE)\n\n    val leftAction = sharedPreferences.getString(\"left_long_press_action\", StemAction.CYCLE_NOISE_CONTROL_MODES.name)\n    val rightAction = sharedPreferences.getString(\"right_long_press_action\", StemAction.CYCLE_NOISE_CONTROL_MODES.name)\n\n    val leftActionText = when (StemAction.valueOf(leftAction ?: StemAction.CYCLE_NOISE_CONTROL_MODES.name)) {\n        StemAction.CYCLE_NOISE_CONTROL_MODES -> stringResource(R.string.noise_control)\n        StemAction.DIGITAL_ASSISTANT -> \"Digital Assistant\"\n        else -> \"INVALID!!\"\n    }\n\n    val rightActionText = when (StemAction.valueOf(rightAction ?: StemAction.CYCLE_NOISE_CONTROL_MODES.name)) {\n        StemAction.CYCLE_NOISE_CONTROL_MODES -> stringResource(R.string.noise_control)\n        StemAction.DIGITAL_ASSISTANT -> \"Digital Assistant\"\n        else -> \"INVALID!!\"\n    }\n\n    Text(\n        text = stringResource(R.string.press_and_hold_airpods).uppercase(),\n        style = TextStyle(\n            fontSize = 14.sp,\n            fontWeight = FontWeight.Light,\n            color = textColor.copy(alpha = 0.6f),\n            fontFamily = FontFamily(Font(R.font.sf_pro))\n        ),\n        modifier = Modifier.padding(8.dp, bottom = 2.dp)\n    )\n\n    Spacer(modifier = Modifier.height(1.dp))\n\n    Column(\n        modifier = Modifier\n            .fillMaxWidth()\n            .background(if (isDarkTheme) Color(0xFF1C1C1E) else Color(0xFFFFFFFF), RoundedCornerShape(14.dp))\n    ) {\n        Box(\n            modifier = Modifier\n                .fillMaxWidth()\n                .height(55.dp)\n                .background(animatedLeftBackgroundColor, RoundedCornerShape(topStart = 14.dp, topEnd = 14.dp))\n                .pointerInput(Unit) {\n                    detectTapGestures(\n                        onPress = {\n                            leftBackgroundColor = dividerColor\n                            tryAwaitRelease()\n                            leftBackgroundColor = if (isDarkTheme) Color(0xFF1C1C1E) else Color(0xFFFFFFFF)\n                        },\n                        onTap = {\n                            navController.navigate(\"long_press/Left\")\n                        }\n                    )\n                },\n            contentAlignment = Alignment.Center\n        ) {\n            Row(\n                modifier = Modifier\n                    .padding(start = 16.dp),\n                verticalAlignment = Alignment.CenterVertically\n            ) {\n                Text(\n                    text = stringResource(R.string.left),\n                    style = TextStyle(\n                        fontSize = 18.sp,\n                        color = textColor,\n                        fontFamily = FontFamily(Font(R.font.sf_pro))\n                    ),\n                )\n                Spacer(modifier = Modifier.weight(1f))\n                Text(\n                    text = leftActionText,\n                    style = TextStyle(\n                        fontSize = 18.sp,\n                        color = textColor.copy(alpha = 0.6f),\n                        fontFamily = FontFamily(Font(R.font.sf_pro))\n                    ),\n                )\n                IconButton(\n                    onClick = {\n                        navController.navigate(\"long_press/Left\")\n                    }\n                ) {\n                    Icon(\n                        imageVector = Icons.AutoMirrored.Filled.KeyboardArrowRight,\n                        contentDescription = \"go\",\n                        tint = textColor\n                    )\n                }\n            }\n        }\n        HorizontalDivider(\n            thickness = 1.5.dp,\n            color = dividerColor,\n            modifier = Modifier\n                .padding(start = 16.dp)\n        )\n        Box(\n            modifier = Modifier\n                .fillMaxWidth()\n                .height(55.dp)\n                .background(animatedRightBackgroundColor, RoundedCornerShape(bottomEnd = 14.dp, bottomStart = 14.dp))\n                .pointerInput(Unit) {\n                    detectTapGestures(\n                        onPress = {\n                            rightBackgroundColor = dividerColor\n                            tryAwaitRelease()\n                            rightBackgroundColor = if (isDarkTheme) Color(0xFF1C1C1E) else Color(0xFFFFFFFF)\n                        },\n                        onTap = {\n                            navController.navigate(\"long_press/Right\")\n                        }\n                    )\n                },\n            contentAlignment = Alignment.Center\n        ) {\n            Row(\n                modifier = Modifier\n                    .padding(start = 16.dp),\n                verticalAlignment = Alignment.CenterVertically\n            ) {\n                Text(\n                    text = stringResource(R.string.right),\n                    style = TextStyle(\n                        fontSize = 18.sp,\n                        color = textColor,\n                        fontFamily = FontFamily(Font(R.font.sf_pro))\n                    ),\n                )\n                Spacer(modifier = Modifier.weight(1f))\n                Text(\n                    text = rightActionText,\n                    style = TextStyle(\n                        fontSize = 18.sp,\n                        color = textColor.copy(alpha = 0.6f),\n                        fontFamily = FontFamily(Font(R.font.sf_pro))\n                    ),\n                )\n                IconButton(\n                    onClick = {\n                        navController.navigate(\"long_press/Right\")\n                    }\n                ) {\n                    Icon(\n                        imageVector = Icons.AutoMirrored.Filled.KeyboardArrowRight,\n                        contentDescription = \"go\",\n                        tint = textColor\n                    )\n                }\n            }\n        }\n    }\n}\n\n@Preview\n@Composable\nfun PressAndHoldSettingsPreview() {\n    PressAndHoldSettings(navController = NavController(LocalContext.current))\n}\n"
        },
        {
          "name": "NoiseControlSettings.kt",
          "ext": ".kt",
          "size": 20414,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n *\n * Copyright (C) 2025 LibrePods contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\n@file:OptIn(ExperimentalEncodingApi::class)\n\npackage me.kavishdevar.librepods.composables\n\nimport android.annotation.SuppressLint\nimport android.content.BroadcastReceiver\nimport android.content.Context\nimport android.content.Intent\nimport android.content.IntentFilter\nimport android.os.Build\nimport androidx.compose.animation.core.AnimationSpec\nimport androidx.compose.animation.core.Spring\nimport androidx.compose.animation.core.SpringSpec\nimport androidx.compose.animation.core.animateFloatAsState\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.gestures.Orientation\nimport androidx.compose.foundation.gestures.draggable\nimport androidx.compose.foundation.gestures.rememberDraggableState\nimport androidx.compose.foundation.isSystemInDarkTheme\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.BoxWithConstraints\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.fillMaxHeight\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.offset\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.width\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.VerticalDivider\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableFloatStateOf\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.alpha\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.graphics.ImageBitmap\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.platform.LocalDensity\nimport androidx.compose.ui.res.imageResource\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.text.TextStyle\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.text.style.TextAlign\nimport androidx.compose.ui.tooling.preview.Preview\nimport androidx.compose.ui.unit.IntOffset\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport androidx.compose.ui.zIndex\nimport me.kavishdevar.librepods.R\nimport me.kavishdevar.librepods.constants.AirPodsNotifications\nimport me.kavishdevar.librepods.constants.NoiseControlMode\nimport me.kavishdevar.librepods.services.AirPodsService\nimport me.kavishdevar.librepods.utils.AACPManager\nimport kotlin.io.encoding.ExperimentalEncodingApi\nimport kotlin.math.roundToInt\n\n@SuppressLint(\"UnspecifiedRegisterReceiverFlag\", \"UnusedBoxWithConstraintsScope\")\n@Composable\nfun NoiseControlSettings(\n    service: AirPodsService,\n) {\n    val context = LocalContext.current\n    val offListeningModeConfigValue = service.aacpManager.controlCommandStatusList.find {\n        it.identifier == AACPManager.Companion.ControlCommandIdentifiers.ALLOW_OFF_OPTION\n    }?.value?.takeIf { it.isNotEmpty() }?.get(0) == 1.toByte()\n    val offListeningMode = remember { mutableStateOf(offListeningModeConfigValue) }\n\n    val offListeningModeListener = object: AACPManager.ControlCommandListener {\n        override fun onControlCommandReceived(controlCommand: AACPManager.ControlCommand) {\n            offListeningMode.value = controlCommand.value[0] == 1.toByte()\n        }\n    }\n\n    service.aacpManager.registerControlCommandListener(\n        AACPManager.Companion.ControlCommandIdentifiers.ALLOW_OFF_OPTION,\n        offListeningModeListener\n    )\n\n    val isDarkTheme = isSystemInDarkTheme()\n    val backgroundColor = if (isDarkTheme) Color(0xFF1C1C1E) else Color(0xFFE3E3E8)\n    val textColor = if (isDarkTheme) Color.White else Color.Black\n    val textColorSelected = if (isDarkTheme) Color.White else Color.Black\n    val selectedBackground = if (isDarkTheme) Color(0xBF5C5A5F) else Color(0xFFFFFFFF)\n\n    val noiseControlMode = remember { mutableStateOf(NoiseControlMode.OFF) }\n\n    val d1a = remember { mutableFloatStateOf(0f) }\n    val d2a = remember { mutableFloatStateOf(0f) }\n    val d3a = remember { mutableFloatStateOf(0f) }\n\n    fun onModeSelected(mode: NoiseControlMode, received: Boolean = false) {\n        val previousMode = noiseControlMode.value\n\n        val targetMode = if (!offListeningMode.value && mode == NoiseControlMode.OFF) {\n             NoiseControlMode.TRANSPARENCY\n        } else {\n            mode\n        }\n\n        noiseControlMode.value = targetMode\n\n        if (!received && targetMode != previousMode) {\n            service.aacpManager.sendControlCommand(identifier = AACPManager.Companion.ControlCommandIdentifiers.LISTENING_MODE.value, value = targetMode.ordinal + 1)\n        }\n\n        when (noiseControlMode.value) {\n            NoiseControlMode.NOISE_CANCELLATION -> {\n                d1a.floatValue = 1f\n                d2a.floatValue = 1f\n                d3a.floatValue = 0f\n            }\n            NoiseControlMode.OFF -> {\n                d1a.floatValue = 0f\n                d2a.floatValue = 1f\n                d3a.floatValue = 1f\n            }\n            NoiseControlMode.ADAPTIVE -> {\n                d1a.floatValue = 1f\n                d2a.floatValue = 0f\n                d3a.floatValue = 0f\n            }\n            NoiseControlMode.TRANSPARENCY -> {\n                d1a.floatValue = 0f\n                d2a.floatValue = 0f\n                d3a.floatValue = 1f\n            }\n        }\n    }\n\n    val noiseControlReceiver = remember {\n        object : BroadcastReceiver() {\n            override fun onReceive(context: Context, intent: Intent) {\n                if (intent.action == AirPodsNotifications.ANC_DATA) {\n                    noiseControlMode.value = NoiseControlMode.entries.toTypedArray()[intent.getIntExtra(\"data\", 3) - 1]\n                    onModeSelected(noiseControlMode.value, true)\n                } else if (intent.action == AirPodsNotifications.DISCONNECT_RECEIVERS) {\n                    try {\n                        context.unregisterReceiver(this)\n                    } catch (e: IllegalArgumentException) {\n                        e.printStackTrace()\n                    }\n                }\n            }\n        }\n    }\n\n    val noiseControlIntentFilter = IntentFilter().apply {\n        addAction(AirPodsNotifications.ANC_DATA)\n        addAction(AirPodsNotifications.DISCONNECT_RECEIVERS)\n    }\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\n        context.registerReceiver(noiseControlReceiver, noiseControlIntentFilter, Context.RECEIVER_EXPORTED)\n    } else {\n        context.registerReceiver(noiseControlReceiver, noiseControlIntentFilter)\n    }\n\n    Text(\n        text = stringResource(R.string.noise_control).uppercase(),\n        style = TextStyle(\n            fontSize = 14.sp,\n            fontWeight = FontWeight.Light,\n            color = textColor.copy(alpha = 0.6f),\n        ),\n        modifier = Modifier.padding(8.dp, bottom = 2.dp)\n    )\n    BoxWithConstraints(\n        modifier = Modifier\n            .fillMaxWidth()\n            .padding(vertical = 8.dp)\n    ) {\n        val density = LocalDensity.current\n        val buttonCount = if (offListeningMode.value) 4 else 3\n        val buttonWidth = maxWidth / buttonCount\n\n        val isDragging = remember { mutableStateOf(false) }\n        var dragOffset by remember {\n            mutableFloatStateOf(\n                with(density) {\n                    when(noiseControlMode.value) {\n                        NoiseControlMode.OFF -> if (offListeningMode.value) 0f else buttonWidth.toPx()\n                        NoiseControlMode.TRANSPARENCY -> if (offListeningMode.value) buttonWidth.toPx() else 0f\n                        NoiseControlMode.ADAPTIVE -> if (offListeningMode.value) (buttonWidth * 2).toPx() else buttonWidth.toPx()\n                        NoiseControlMode.NOISE_CANCELLATION -> if (offListeningMode.value) (buttonWidth * 3).toPx() else (buttonWidth * 2).toPx()\n                    }\n                }\n            )\n        }\n\n        val animationSpec: AnimationSpec<Float> = SpringSpec(\n            dampingRatio = Spring.DampingRatioLowBouncy,\n            stiffness = Spring.StiffnessMediumLow,\n            visibilityThreshold = 0.01f\n        )\n\n        val targetOffset = buttonWidth * when(noiseControlMode.value) {\n            NoiseControlMode.OFF -> if (offListeningMode.value) 0 else 1\n            NoiseControlMode.TRANSPARENCY -> if (offListeningMode.value) 1 else 0\n            NoiseControlMode.ADAPTIVE -> if (offListeningMode.value) 2 else 1\n            NoiseControlMode.NOISE_CANCELLATION -> if (offListeningMode.value) 3 else 2\n        }\n\n        val animatedOffset by animateFloatAsState(\n            targetValue = with(density) {\n                if (isDragging.value) dragOffset else targetOffset.toPx()\n            },\n            animationSpec = animationSpec,\n            label = \"selector\"\n        )\n\n        Column(\n            modifier = Modifier.fillMaxWidth()\n        ) {\n            Box(\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .height(60.dp)\n                    .background(backgroundColor, RoundedCornerShape(14.dp))\n            ) {\n                Row(\n                    modifier = Modifier.fillMaxWidth()\n                ) {\n                    if (offListeningMode.value) {\n                        NoiseControlButton(\n                            icon = ImageBitmap.imageResource(R.drawable.noise_cancellation),\n                            onClick = { onModeSelected(NoiseControlMode.OFF) },\n                            textColor = if (noiseControlMode.value == NoiseControlMode.OFF) textColorSelected else textColor,\n                            modifier = Modifier.weight(1f),\n                            usePadding = false\n                        )\n                        VerticalDivider(\n                            thickness = 1.dp,\n                            modifier = Modifier\n                                .padding(vertical = 10.dp)\n                                .alpha(d1a.floatValue),\n                            color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.12f)\n                        )\n                    }\n                    NoiseControlButton(\n                        icon = ImageBitmap.imageResource(R.drawable.transparency),\n                        onClick = { onModeSelected(NoiseControlMode.TRANSPARENCY) },\n                        textColor = if (noiseControlMode.value == NoiseControlMode.TRANSPARENCY) textColorSelected else textColor,\n                        modifier = Modifier.weight(1f),\n                        usePadding = false\n                    )\n                    VerticalDivider(\n                        thickness = 1.dp,\n                        modifier = Modifier\n                            .padding(vertical = 10.dp)\n                            .alpha(d2a.floatValue),\n                        color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.12f)\n                    )\n                    NoiseControlButton(\n                        icon = ImageBitmap.imageResource(R.drawable.adaptive),\n                        onClick = { onModeSelected(NoiseControlMode.ADAPTIVE) },\n                        textColor = if (noiseControlMode.value == NoiseControlMode.ADAPTIVE) textColorSelected else textColor,\n                        modifier = Modifier.weight(1f),\n                        usePadding = false\n                    )\n                    VerticalDivider(\n                        thickness = 1.dp,\n                        modifier = Modifier\n                            .padding(vertical = 10.dp)\n                            .alpha(d3a.floatValue),\n                        color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.12f)\n                    )\n                    NoiseControlButton(\n                        icon = ImageBitmap.imageResource(R.drawable.noise_cancellation),\n                        onClick = { onModeSelected(NoiseControlMode.NOISE_CANCELLATION) },\n                        textColor = if (noiseControlMode.value == NoiseControlMode.NOISE_CANCELLATION) textColorSelected else textColor,\n                        modifier = Modifier.weight(1f),\n                        usePadding = false\n                    )\n                }\n\n                Box(\n                    modifier = Modifier\n                        .width(buttonWidth)\n                        .fillMaxHeight()\n                        .offset { IntOffset(animatedOffset.roundToInt(), 0) }\n                        .zIndex(0f)\n                        .draggable(\n                            orientation = Orientation.Horizontal,\n                            state = rememberDraggableState { delta ->\n                                dragOffset = (dragOffset + delta).coerceIn(\n                                    0f,\n                                    with(density) { (buttonWidth * (buttonCount - 1)).toPx() }\n                                )\n                            },\n                            onDragStarted = { isDragging.value = true },\n                            onDragStopped = {\n                                isDragging.value = false\n                                val position = dragOffset / with(density) { buttonWidth.toPx() }\n                                val newIndex = position.roundToInt()\n                                val newMode = when(newIndex) {\n                                    0 -> if (offListeningMode.value) NoiseControlMode.OFF else NoiseControlMode.TRANSPARENCY\n                                    1 -> if (offListeningMode.value) NoiseControlMode.TRANSPARENCY else NoiseControlMode.ADAPTIVE\n                                    2 -> if (offListeningMode.value) NoiseControlMode.ADAPTIVE else NoiseControlMode.NOISE_CANCELLATION\n                                    3 -> NoiseControlMode.NOISE_CANCELLATION\n                                    else -> noiseControlMode.value // Keep current if index is invalid\n                                }\n                                // Call onModeSelected which now handles service call but not callback\n                                onModeSelected(newMode)\n                            }\n                        )\n                ) {\n                    Box(\n                        modifier = Modifier\n                            .fillMaxSize()\n                            .padding(3.dp)\n                            .background(selectedBackground, RoundedCornerShape(12.dp))\n                    )\n                }\n\n                Row(\n                    modifier = Modifier\n                        .fillMaxWidth()\n                        .zIndex(1f)\n                ) {\n                    if (offListeningMode.value) {\n                        NoiseControlButton(\n                            icon = ImageBitmap.imageResource(R.drawable.noise_cancellation),\n                            onClick = { onModeSelected(NoiseControlMode.OFF) },\n                            textColor = if (noiseControlMode.value == NoiseControlMode.OFF) textColorSelected else textColor,\n                            modifier = Modifier.weight(1f),\n                            usePadding = false\n                        )\n                        VerticalDivider(\n                            thickness = 1.dp,\n                            modifier = Modifier\n                                .padding(vertical = 10.dp)\n                                .alpha(d1a.floatValue),\n                            color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.12f)\n                        )\n                    }\n                    NoiseControlButton(\n                        icon = ImageBitmap.imageResource(R.drawable.transparency),\n                        onClick = { onModeSelected(NoiseControlMode.TRANSPARENCY) },\n                        textColor = if (noiseControlMode.value == NoiseControlMode.TRANSPARENCY) textColorSelected else textColor,\n                        modifier = Modifier.weight(1f),\n                        usePadding = false\n                    )\n                    VerticalDivider(\n                        thickness = 1.dp,\n                        modifier = Modifier\n                            .padding(vertical = 10.dp)\n                            .alpha(d2a.floatValue),\n                        color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.12f)\n                    )\n                    NoiseControlButton(\n                        icon = ImageBitmap.imageResource(R.drawable.adaptive),\n                        onClick = { onModeSelected(NoiseControlMode.ADAPTIVE) },\n                        textColor = if (noiseControlMode.value == NoiseControlMode.ADAPTIVE) textColorSelected else textColor,\n                        modifier = Modifier.weight(1f),\n                        usePadding = false\n                    )\n                    VerticalDivider(\n                        thickness = 1.dp,\n                        modifier = Modifier\n                            .padding(vertical = 10.dp)\n                            .alpha(d3a.floatValue),\n                        color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.12f)\n                    )\n                    NoiseControlButton(\n                        icon = ImageBitmap.imageResource(R.drawable.noise_cancellation),\n                        onClick = { onModeSelected(NoiseControlMode.NOISE_CANCELLATION) },\n                        textColor = if (noiseControlMode.value == NoiseControlMode.NOISE_CANCELLATION) textColorSelected else textColor,\n                        modifier = Modifier.weight(1f),\n                        usePadding = false\n                    )\n                }\n            }\n\n            Row(\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .padding(horizontal = 4.dp)\n                    .padding(top = 4.dp)\n            ) {\n                if (offListeningMode.value) {\n                    Text(\n                        text = stringResource(R.string.off),\n                        style = TextStyle(fontSize = 12.sp, color = textColor),\n                        textAlign = TextAlign.Center,\n                        fontWeight = FontWeight.Bold,\n                        modifier = Modifier.weight(1f)\n                    )\n                }\n                Text(\n                    text = stringResource(R.string.transparency),\n                    style = TextStyle(fontSize = 12.sp, color = textColor),\n                    textAlign = TextAlign.Center,\n                    fontWeight = FontWeight.Bold,\n                    modifier = Modifier.weight(1f)\n                )\n                Text(\n                    text = stringResource(R.string.adaptive),\n                    style = TextStyle(fontSize = 12.sp, color = textColor),\n                    textAlign = TextAlign.Center,\n                    fontWeight = FontWeight.Bold,\n                    modifier = Modifier.weight(1f)\n                )\n                Text(\n                    text = stringResource(R.string.noise_cancellation),\n                    style = TextStyle(fontSize = 12.sp, color = textColor),\n                    textAlign = TextAlign.Center,\n                    fontWeight = FontWeight.Bold,\n                    modifier = Modifier.weight(1f)\n                )\n            }\n        }\n    }\n}\n\n@Preview()\n@Composable\nfun NoiseControlSettingsPreview() {\n    NoiseControlSettings(AirPodsService())\n}\n"
        },
        {
          "name": "IndependentToggle.kt",
          "ext": ".kt",
          "size": 5327,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n *\n * Copyright (C) 2025 LibrePods contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\n@file:OptIn(ExperimentalEncodingApi::class)\n\npackage me.kavishdevar.librepods.composables\n\nimport android.content.SharedPreferences\nimport androidx.compose.animation.animateColorAsState\nimport androidx.compose.animation.core.tween\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.gestures.detectTapGestures\nimport androidx.compose.foundation.isSystemInDarkTheme\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.input.pointer.pointerInput\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.tooling.preview.Preview\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport me.kavishdevar.librepods.services.AirPodsService\nimport me.kavishdevar.librepods.utils.AACPManager\nimport kotlin.io.encoding.ExperimentalEncodingApi\n\n@Composable\nfun IndependentToggle(name: String, service: AirPodsService? = null, functionName: String? = null, sharedPreferences: SharedPreferences, default: Boolean = false, controlCommandIdentifier: AACPManager.Companion.ControlCommandIdentifiers? = null) {\n    val isDarkTheme = isSystemInDarkTheme()\n    val textColor = if (isDarkTheme) Color.White else Color.Black\n    val snakeCasedName =\n        controlCommandIdentifier?.name ?: name.replace(Regex(\"[\\\\W\\\\s]+\"), \"_\").lowercase()\n    var checked by remember { mutableStateOf(default) }\n\n    if (controlCommandIdentifier != null) {\n        checked = service!!.aacpManager.controlCommandStatusList.find {\n            it.identifier == controlCommandIdentifier\n        }?.value?.takeIf { it.isNotEmpty() }?.get(0) == 1.toByte()\n    }\n\n    var backgroundColor by remember { mutableStateOf(if (isDarkTheme) Color(0xFF1C1C1E) else Color(0xFFFFFFFF)) }\n    val animatedBackgroundColor by animateColorAsState(targetValue = backgroundColor, animationSpec = tween(durationMillis = 500))\n\n    fun cb() {\n        if (controlCommandIdentifier == null) {\n            sharedPreferences.edit().putBoolean(snakeCasedName, checked).apply()\n        }\n        if (functionName != null && service != null) {\n            val method =\n                service::class.java.getMethod(functionName, Boolean::class.java)\n            method.invoke(service, checked)\n        }\n        if (controlCommandIdentifier != null) {\n            service?.aacpManager?.sendControlCommand(identifier = controlCommandIdentifier.value, value = checked)\n        }\n    }\n\n    LaunchedEffect(sharedPreferences) {\n        checked = sharedPreferences.getBoolean(snakeCasedName, true)\n    }\n    Box (\n        modifier = Modifier\n            .padding(vertical = 8.dp)\n            .background(animatedBackgroundColor, RoundedCornerShape(14.dp))\n            .pointerInput(Unit) {\n                detectTapGestures(\n                    onPress = {\n                        backgroundColor = if (isDarkTheme) Color(0x40888888) else Color(0x40D9D9D9)\n                        tryAwaitRelease()\n                        backgroundColor = if (isDarkTheme) Color(0xFF1C1C1E) else Color(0xFFFFFFFF)\n                    },\n                    onTap = {\n                        checked = !checked\n                        cb()\n                    }\n                )\n            },\n    )\n    {\n        Row(\n            modifier = Modifier\n                .fillMaxWidth()\n                .height(55.dp)\n                .padding(horizontal = 12.dp),\n            verticalAlignment = Alignment.CenterVertically\n        ) {\n            Text(text = name, modifier = Modifier.weight(1f), fontSize = 16.sp, color = textColor)\n            StyledSwitch(\n                checked = checked,\n                onCheckedChange = {\n                    checked = it\n                    cb()\n                },\n            )\n        }\n    }\n}\n\n@Preview\n@Composable\nfun IndependentTogglePreview() {\n    IndependentToggle(\"Test\", AirPodsService(), \"test\", LocalContext.current.getSharedPreferences(\"preview\", 0), true)\n}"
        },
        {
          "name": "NameField.kt",
          "ext": ".kt",
          "size": 5870,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n * \n * Copyright (C) 2025 LibrePods contributors\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n * \n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\npackage me.kavishdevar.librepods.composables\n\nimport androidx.compose.animation.animateColorAsState\nimport androidx.compose.animation.core.tween\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.gestures.detectTapGestures\nimport androidx.compose.foundation.isSystemInDarkTheme\nimport androidx.compose.foundation.layout.Arrangement\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.size\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.foundation.text.BasicTextField\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.automirrored.filled.KeyboardArrowRight\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.focus.onFocusChanged\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.graphics.SolidColor\nimport androidx.compose.ui.input.pointer.pointerInput\nimport androidx.compose.ui.text.TextStyle\nimport androidx.compose.ui.text.style.TextAlign\nimport androidx.compose.ui.tooling.preview.Preview\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport androidx.navigation.NavController\nimport androidx.navigation.compose.rememberNavController\n\n@Composable\nfun NameField(\n    name: String,\n    value: String,\n    navController: NavController\n) {\n    var isFocused by remember { mutableStateOf(false) }\n\n    val isDarkTheme = isSystemInDarkTheme()\n\n    var backgroundColor by remember { mutableStateOf(if (isDarkTheme) Color(0xFF1C1C1E) else Color(0xFFFFFFFF)) }\n    val animatedBackgroundColor by animateColorAsState(targetValue = backgroundColor, animationSpec = tween(durationMillis = 500))\n\n    val textColor = if (isDarkTheme) Color.White else Color.Black\n    val cursorColor = if (isFocused) {\n        if (isDarkTheme) Color.White else Color.Black\n    } else {\n        Color.Transparent\n    }\n\n    Box (\n        modifier = Modifier\n            .background(animatedBackgroundColor, RoundedCornerShape(14.dp))\n            .pointerInput(Unit) {\n                detectTapGestures(\n                    onPress = {\n                        backgroundColor = if (isDarkTheme) Color(0x40888888) else Color(0x40D9D9D9)\n                        tryAwaitRelease()\n                        backgroundColor = if (isDarkTheme) Color(0xFF1C1C1E) else Color(0xFFFFFFFF)\n                    },\n                    onTap = {\n                        navController.navigate(\"rename\")\n                    }\n                )\n            }\n    ) {\n        Row(\n            verticalAlignment = Alignment.CenterVertically,\n            modifier = Modifier\n                .fillMaxWidth()\n                .height(55.dp)\n                .background(\n                    animatedBackgroundColor,\n                    RoundedCornerShape(14.dp)\n                )\n                .padding(horizontal = 16.dp, vertical = 8.dp)\n\n        ) {\n            Text(\n                text = name,\n                style = TextStyle(\n                    fontSize = 16.sp,\n                    color = textColor\n                )\n            )\n            BasicTextField(\n                value = value,\n                textStyle = TextStyle(\n                    color = textColor.copy(alpha = 0.75f),\n                    fontSize = 16.sp,\n                    textAlign = TextAlign.End\n                ),\n                onValueChange = {},\n                singleLine = true,\n                enabled = false,\n                cursorBrush = SolidColor(cursorColor),\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .padding(start = 8.dp)\n                    .onFocusChanged { focusState ->\n                        isFocused = focusState.isFocused\n                    },\n                decorationBox = { innerTextField ->\n                    Row(\n                        verticalAlignment = Alignment.CenterVertically,\n                        horizontalArrangement = Arrangement.End\n                    ) {\n                        innerTextField()\n                        Icon(\n                            imageVector = Icons.AutoMirrored.Filled.KeyboardArrowRight,\n                            contentDescription = \"Edit name\",\n                            tint = textColor.copy(alpha = 0.75f),\n                            modifier = Modifier\n                                .size(32.dp)\n                        )\n                    }\n                }\n            )\n        }\n    }\n}\n\n@Preview\n@Composable\nfun StyledTextFieldPreview() {\n    NameField(name = \"Name\", value = \"AirPods Pro\", rememberNavController())\n}"
        },
        {
          "name": "VerticalVolumeSlider.kt",
          "ext": ".kt",
          "size": 7332,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n *\n * Copyright (C) 2025 LibrePods Contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\npackage me.kavishdevar.librepods.composables\n\nimport androidx.compose.animation.core.Spring\nimport androidx.compose.animation.core.animateFloatAsState\nimport androidx.compose.animation.core.spring\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.gestures.Orientation\nimport androidx.compose.foundation.gestures.detectTapGestures\nimport androidx.compose.foundation.gestures.draggable\nimport androidx.compose.foundation.gestures.rememberDraggableState\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.fillMaxHeight\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.offset\nimport androidx.compose.foundation.layout.width\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableFloatStateOf\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.clip\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.input.pointer.pointerInput\nimport androidx.compose.ui.platform.LocalDensity\nimport androidx.compose.ui.unit.Dp\nimport androidx.compose.ui.unit.dp\nimport kotlin.math.abs\nimport kotlin.math.max\nimport kotlin.math.min\nimport kotlin.math.roundToInt\nimport kotlin.math.sign\n\n@Composable\nfun VerticalVolumeSlider(\n    displayFraction: Float,\n    maxVolume: Int,\n    onVolumeChange: (Int) -> Unit,\n    initialFraction: Float,\n    onDragStateChange: (Boolean) -> Unit,\n    modifier: Modifier = Modifier,\n    baseSliderHeight: Dp = 400.dp,\n    baseSliderWidth: Dp = 145.dp,\n    baseCornerRadius: Dp = 45.dp,\n    maxStretchFactor: Float = 1.15f,\n    minCompressionFactor: Float = 0.875f,\n    stretchSensitivity: Float = 1.0f,\n    compressionSensitivity: Float = 1.0f,\n    cornerRadiusChangeFactor: Float = 0.2f,\n    directionalStretchRatio: Float = 0.75f\n) {\n    val trackColor = Color(0x593C3C3E)\n    val progressColor = Color.White\n\n    var dragFraction by remember { mutableFloatStateOf(initialFraction) }\n    var isDragging by remember { mutableStateOf(false) }\n\n    var rawDragPosition by remember { mutableFloatStateOf(initialFraction) }\n    var overscrollAmount by remember { mutableFloatStateOf(0f) }\n\n    val baseHeightPx = with(LocalDensity.current) { baseSliderHeight.toPx() }\n\n    val animatedProgress by animateFloatAsState(\n        targetValue = dragFraction.coerceIn(0f, 1f),\n        animationSpec = spring(\n            dampingRatio = Spring.DampingRatioLowBouncy,\n            stiffness = Spring.StiffnessMedium\n        ),\n        label = \"ProgressAnimation\"\n    )\n\n    val animatedOverscroll by animateFloatAsState(\n        targetValue = overscrollAmount,\n        animationSpec = spring(\n            dampingRatio = Spring.DampingRatioMediumBouncy,\n            stiffness = Spring.StiffnessMediumLow\n        ),\n        label = \"OverscrollAnimation\"\n    )\n\n    val maxOverscrollEffect = (maxStretchFactor - 1f).coerceAtLeast(0f)\n\n    val stretchMultiplier = stretchSensitivity\n    val compressionMultiplier = compressionSensitivity\n\n    val overscrollDirection = sign(animatedOverscroll)\n\n    val totalStretchAmount = (min(maxOverscrollEffect, abs(animatedOverscroll) * stretchMultiplier) * baseSliderHeight.value).dp\n\n    val offsetY = if (abs(animatedOverscroll) > 0.001f) {\n        val asymmetricOffset = totalStretchAmount * (directionalStretchRatio - 0.5f)\n        (-overscrollDirection * asymmetricOffset.value).dp\n    } else {\n        0.dp\n    }\n\n    val heightStretch = baseSliderHeight + totalStretchAmount\n\n    val widthCompression = baseSliderWidth * max(\n        minCompressionFactor,\n        1f - min(1f - minCompressionFactor, abs(animatedOverscroll) * compressionMultiplier)\n    )\n\n    val dynamicCornerRadius = baseCornerRadius * (1f - min(cornerRadiusChangeFactor, abs(animatedOverscroll) * cornerRadiusChangeFactor * 2f))\n\n    Box(\n        modifier = modifier,\n        contentAlignment = Alignment.Center\n    ) {\n        Box(\n            modifier = Modifier\n                .height(heightStretch)\n                .width(widthCompression)\n                .offset(y = offsetY)\n                .clip(RoundedCornerShape(dynamicCornerRadius))\n                .background(trackColor)\n                .pointerInput(Unit) {\n                    detectTapGestures { offset ->\n                        val newFraction = 1f - (offset.y / size.height).coerceIn(0f, 1f)\n                        dragFraction = newFraction\n                        rawDragPosition = newFraction\n                        overscrollAmount = 0f\n\n                        val newVolume = (newFraction * maxVolume).roundToInt()\n                        onVolumeChange(newVolume)\n                    }\n                }\n                .draggable(\n                    orientation = Orientation.Vertical,\n                    state = rememberDraggableState { delta ->\n                        rawDragPosition -= (delta / baseHeightPx)\n\n                        dragFraction = rawDragPosition.coerceIn(0f, 1f)\n\n                        overscrollAmount = when {\n                            rawDragPosition > 1f -> min(1.0f, (rawDragPosition - 1f) * 2.0f)\n                            rawDragPosition < 0f -> max(-1.0f, rawDragPosition * 2.0f)\n                            else -> 0f\n                        }\n\n                        val newVolume = (dragFraction * maxVolume).roundToInt()\n                        onVolumeChange(newVolume)\n                    },\n                    onDragStarted = {\n                        isDragging = true\n                        dragFraction = displayFraction\n                        rawDragPosition = displayFraction\n                        overscrollAmount = 0f\n                        onDragStateChange(true)\n                    },\n                    onDragStopped = {\n                        isDragging = false\n                        overscrollAmount = 0f\n                        rawDragPosition = dragFraction\n                        onDragStateChange(false)\n                    }\n                ),\n            contentAlignment = Alignment.BottomCenter\n        ) {\n            Box(\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .fillMaxHeight(animatedProgress)\n                    .background(progressColor)\n            )\n        }\n    }\n}\n"
        },
        {
          "name": "ControlCenterNoiseControlSegmentedButton.kt",
          "ext": ".kt",
          "size": 8935,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n *\n * Copyright (C) 2025 LibrePods Contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\npackage me.kavishdevar.librepods.composables\n\nimport androidx.compose.animation.core.Spring\nimport androidx.compose.animation.core.animateDpAsState\nimport androidx.compose.animation.core.spring\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.clickable\nimport androidx.compose.foundation.interaction.MutableInteractionSource\nimport androidx.compose.foundation.layout.Arrangement\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.Spacer\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.offset\nimport androidx.compose.foundation.layout.size\nimport androidx.compose.foundation.layout.width\nimport androidx.compose.foundation.shape.CircleShape\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableFloatStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.clip\nimport androidx.compose.ui.graphics.Brush\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.layout.onSizeChanged\nimport androidx.compose.ui.platform.LocalDensity\nimport androidx.compose.ui.res.painterResource\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.text.style.TextAlign\nimport androidx.compose.ui.unit.Dp\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport me.kavishdevar.librepods.R\nimport me.kavishdevar.librepods.constants.NoiseControlMode\n\nprivate val ContainerColor = Color(0x593C3C3E)\nprivate val SelectedIndicatorColorGray = Color(0xFF6C6C6E)\nprivate val SelectedIndicatorColorBlue = Color(0xFF0A84FF)\nprivate val TextColor = Color.White\nprivate val IconTintUnselected = Color.White\nprivate val IconTintSelected = Color.White\n\ninternal val AdaptiveRainbowBrush = Brush.sweepGradient(\n    colors = listOf(\n        Color(0xFFB03A2F), Color(0xFFB07A2F), Color(0xFFB0A22F), Color(0xFF6AB02F),\n        Color(0xFF2FAAB0), Color(0xFF2F5EB0), Color(0xFF7D2FB0), Color(0xFFB02F7D),\n        Color(0xFFB03A2F)\n    )\n)\n\ninternal val IconAreaSize = 72.dp\nprivate val IconSize = 42.dp\nprivate val IconRowHeight = IconAreaSize + 12.dp\nprivate val TextRowHeight = 24.dp\nprivate val TextSize = 12.sp\n\n@Composable\nfun ControlCenterNoiseControlSegmentedButton(\n    modifier: Modifier = Modifier,\n    availableModes: List<NoiseControlMode>,\n    selectedMode: NoiseControlMode,\n    onModeSelected: (NoiseControlMode) -> Unit\n) {\n    val selectedIndex = availableModes.indexOf(selectedMode).coerceAtLeast(0)\n    val density = LocalDensity.current\n    var iconRowWidthPx by remember { mutableFloatStateOf(0f) }\n    val itemCount = availableModes.size\n\n    val itemSlotWidthPx = remember(iconRowWidthPx, itemCount) {\n        if (itemCount > 0 && iconRowWidthPx > 0) {\n            iconRowWidthPx / itemCount\n        } else {\n            0f\n        }\n    }\n    val itemSlotWidthDp = remember(itemSlotWidthPx) { with(density) { itemSlotWidthPx.toDp() } }\n    val iconAreaSizePx = remember { with(density) { IconAreaSize.toPx() } }\n\n    val targetIndicatorStartPx = remember(selectedIndex, itemSlotWidthPx, iconAreaSizePx) {\n        if (itemSlotWidthPx > 0) {\n            val slotCenterPx = (selectedIndex + 0.5f) * itemSlotWidthPx\n            slotCenterPx - (iconAreaSizePx / 2f)\n        } else {\n            0f\n        }\n    }\n\n    val indicatorOffset: Dp by animateDpAsState(\n        targetValue = with(density) { targetIndicatorStartPx.toDp() },\n        animationSpec = spring(\n            dampingRatio = Spring.DampingRatioLowBouncy,\n            stiffness = Spring.StiffnessMedium\n        ),\n        label = \"IndicatorOffset\"\n    )\n\n    val indicatorBackground = remember(selectedMode) {\n        when (selectedMode) {\n            NoiseControlMode.ADAPTIVE -> AdaptiveRainbowBrush\n            NoiseControlMode.OFF -> Brush.linearGradient(colors=listOf(SelectedIndicatorColorGray, SelectedIndicatorColorGray))\n            NoiseControlMode.TRANSPARENCY,\n            NoiseControlMode.NOISE_CANCELLATION -> Brush.linearGradient(colors=listOf(SelectedIndicatorColorBlue, SelectedIndicatorColorBlue))\n        }\n    }\n\n    Column(\n        modifier = modifier,\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        Box(\n            modifier = Modifier\n                .fillMaxWidth()\n                .height(IconRowHeight)\n                .clip(CircleShape)\n                .background(ContainerColor)\n                .onSizeChanged { iconRowWidthPx = it.width.toFloat() },\n            contentAlignment = Alignment.Center\n        ) {\n            Box(\n                Modifier\n                    .align(Alignment.CenterStart)\n                    .offset(x = indicatorOffset)\n                    .size(IconAreaSize)\n                    .clip(CircleShape)\n                    .background(indicatorBackground)\n            )\n\n            Row(\n                modifier = Modifier.fillMaxWidth().align(Alignment.Center),\n                verticalAlignment = Alignment.CenterVertically,\n                horizontalArrangement = Arrangement.SpaceAround\n            ) {\n                availableModes.forEach { mode ->\n                    val isSelected = selectedMode == mode\n                    NoiseControlIconItem(\n                        modifier = Modifier.size(IconAreaSize),\n                        mode = mode,\n                        isSelected = isSelected,\n                        onClick = { onModeSelected(mode) }\n                    )\n                }\n            }\n        }\n\n        Spacer(modifier = Modifier.height(4.dp))\n\n        Row(\n            modifier = Modifier\n                .fillMaxWidth()\n                .height(TextRowHeight),\n            horizontalArrangement = Arrangement.SpaceAround,\n            verticalAlignment = Alignment.CenterVertically\n        ) {\n            availableModes.forEach { mode ->\n                val isSelected = selectedMode == mode\n                Text(\n                    text = getModeLabel(mode),\n                    color = TextColor,\n                    fontSize = TextSize,\n                    fontWeight = if (isSelected) FontWeight.SemiBold else FontWeight.Normal,\n                    textAlign = TextAlign.Center,\n                    modifier = Modifier.width(itemSlotWidthDp.coerceAtLeast(1.dp))\n                )\n            }\n        }\n    }\n}\n\n@Composable\nprivate fun NoiseControlIconItem(\n    modifier: Modifier = Modifier,\n    mode: NoiseControlMode,\n    isSelected: Boolean,\n    onClick: () -> Unit\n) {\n    val iconRes = remember(mode) { getModeIconRes(mode) }\n\n    val tint = IconTintUnselected\n\n    Box(\n        modifier = modifier\n            .clip(CircleShape)\n            .clickable(\n                onClick = onClick,\n                indication = null,\n                interactionSource = remember { MutableInteractionSource() }\n            ),\n        contentAlignment = Alignment.Center\n    ) {\n        Icon(\n            painter = painterResource(id = iconRes),\n            contentDescription = getModeLabel(mode),\n            tint = if (isSelected && mode == NoiseControlMode.ADAPTIVE) IconTintSelected else tint,\n            modifier = Modifier.size(IconSize)\n        )\n    }\n}\n\n\nprivate fun getModeIconRes(mode: NoiseControlMode): Int {\n    return when (mode) {\n        NoiseControlMode.OFF -> R.drawable.noise_cancellation\n        NoiseControlMode.TRANSPARENCY -> R.drawable.transparency\n        NoiseControlMode.ADAPTIVE -> R.drawable.adaptive\n        NoiseControlMode.NOISE_CANCELLATION -> R.drawable.noise_cancellation\n    }\n}\n\nprivate fun getModeLabel(mode: NoiseControlMode): String {\n    return when (mode) {\n        NoiseControlMode.OFF -> \"Off\"\n        NoiseControlMode.TRANSPARENCY -> \"Transparency\"\n        NoiseControlMode.ADAPTIVE -> \"Adaptive\"\n        NoiseControlMode.NOISE_CANCELLATION -> \"Noise Cancellation\"\n    }\n}\n\n"
        },
        {
          "name": "BatteryView.kt",
          "ext": ".kt",
          "size": 7509,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n *\n * Copyright (C) 2025 LibrePods contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\n@file:OptIn(ExperimentalEncodingApi::class)\n\npackage me.kavishdevar.librepods.composables\n\nimport android.content.BroadcastReceiver\nimport android.content.Context\nimport android.content.Intent\nimport android.content.IntentFilter\nimport android.os.Build\nimport android.util.Log\nimport androidx.compose.foundation.Image\nimport androidx.compose.foundation.layout.Arrangement\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.Spacer\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.width\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.scale\nimport androidx.compose.ui.graphics.ImageBitmap\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.res.imageResource\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.tooling.preview.Preview\nimport androidx.compose.ui.unit.dp\nimport me.kavishdevar.librepods.R\nimport me.kavishdevar.librepods.constants.AirPodsNotifications\nimport me.kavishdevar.librepods.constants.Battery\nimport me.kavishdevar.librepods.constants.BatteryComponent\nimport me.kavishdevar.librepods.constants.BatteryStatus\nimport me.kavishdevar.librepods.services.AirPodsService\nimport kotlin.io.encoding.ExperimentalEncodingApi\n\n@Composable\nfun BatteryView(service: AirPodsService, preview: Boolean = false) {\n    val batteryStatus = remember { mutableStateOf<List<Battery>>(listOf()) }\n    @Suppress(\"DEPRECATION\") val batteryReceiver = remember {\n        object : BroadcastReceiver() {\n            override fun onReceive(context: Context, intent: Intent) {\n                if (intent.action == AirPodsNotifications.BATTERY_DATA) {\n                    batteryStatus.value =\n                        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\n                            intent.getParcelableArrayListExtra(\"data\", Battery::class.java)\n                        } else {\n                            intent.getParcelableArrayListExtra(\"data\")\n                        }?.toList() ?: listOf()\n                }\n                else if (intent.action == AirPodsNotifications.DISCONNECT_RECEIVERS) {\n                    try {\n                        context.unregisterReceiver(this)\n                    }\n                    catch (_: IllegalArgumentException) {\n                        Log.wtf(\"BatteryReceiver\", \"Receiver already unregistered\")\n                    }\n                }\n            }\n        }\n    }\n    val context = LocalContext.current\n\n    LaunchedEffect(context) {\n        val batteryIntentFilter = IntentFilter()\n            .apply {\n                addAction(AirPodsNotifications.BATTERY_DATA)\n                addAction(AirPodsNotifications.DISCONNECT_RECEIVERS)\n            }\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\n            context.registerReceiver(\n                batteryReceiver,\n                batteryIntentFilter,\n                Context.RECEIVER_EXPORTED\n            )\n        }\n    }\n\n    batteryStatus.value = service.getBattery()\n\n    if (preview) {\n        batteryStatus.value = listOf<Battery>(\n            Battery(BatteryComponent.LEFT, 100, BatteryStatus.CHARGING),\n            Battery(BatteryComponent.RIGHT, 50, BatteryStatus.NOT_CHARGING),\n            Battery(BatteryComponent.CASE, 5, BatteryStatus.CHARGING)\n        )\n    }\n\n    Row {\n        Column (\n            modifier = Modifier\n                .fillMaxWidth(0.5f),\n            horizontalAlignment = Alignment.CenterHorizontally\n        ) {\n            Image (\n                bitmap = ImageBitmap.imageResource(R.drawable.pro_2_buds),\n                contentDescription = stringResource(R.string.buds),\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .scale(0.80f)\n            )\n            val left = batteryStatus.value.find { it.component == BatteryComponent.LEFT }\n            val right = batteryStatus.value.find { it.component == BatteryComponent.RIGHT }\n            if ((right?.status == BatteryStatus.CHARGING && left?.status == BatteryStatus.CHARGING) || (left?.status == BatteryStatus.NOT_CHARGING && right?.status == BatteryStatus.NOT_CHARGING))\n            {\n                BatteryIndicator(right.level.let { left.level.coerceAtMost(it) }, left.status == BatteryStatus.CHARGING)\n            }\n            else {\n                Row (\n                    modifier = Modifier\n                        .fillMaxWidth(),\n                    horizontalArrangement = Arrangement.Center\n                ) {\n//                    if (left?.status != BatteryStatus.DISCONNECTED) {\n                    if (left?.level != null) {\n                        BatteryIndicator(\n                            left.level,\n                            left.status == BatteryStatus.CHARGING\n                        )\n                    }\n//                    }\n//                    if (left?.status != BatteryStatus.DISCONNECTED && right?.status != BatteryStatus.DISCONNECTED) {\n                    if (left?.level != null && right?.level != null)\n                    {\n                        Spacer(modifier = Modifier.width(16.dp))\n                    }\n//                    }\n//                    if (right?.status != BatteryStatus.DISCONNECTED) {\n                    if (right?.level != null)\n                    {\n                        BatteryIndicator(\n                            right.level,\n                            right.status == BatteryStatus.CHARGING\n                        )\n                    }\n//                    }\n                }\n            }\n        }\n\n        Column (\n            modifier = Modifier\n                .fillMaxWidth(),\n            horizontalAlignment = Alignment.CenterHorizontally\n        ) {\n            val case = batteryStatus.value.find { it.component == BatteryComponent.CASE }\n\n            Image(\n                bitmap = ImageBitmap.imageResource(R.drawable.pro_2_case),\n                contentDescription = stringResource(R.string.case_alt),\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .scale(1.25f)\n            )\n//            if (case?.status != BatteryStatus.DISCONNECTED) {\n                if (case?.level != null) {\n                    BatteryIndicator(case.level, case.status == BatteryStatus.CHARGING)\n                }\n//            }\n        }\n    }\n}\n\n@Preview\n@Composable\nfun BatteryViewPreview() {\n    BatteryView(AirPodsService(), preview = true)\n}\n"
        },
        {
          "name": "AudioSettings.kt",
          "ext": ".kt",
          "size": 3483,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n *\n * Copyright (C) 2025 LibrePods contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\n@file:OptIn(ExperimentalEncodingApi::class)\n\npackage me.kavishdevar.librepods.composables\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.isSystemInDarkTheme\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.text.TextStyle\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.tooling.preview.Preview\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport me.kavishdevar.librepods.R\nimport kotlin.io.encoding.ExperimentalEncodingApi\n\n@Composable\nfun AudioSettings() {\n    val isDarkTheme = isSystemInDarkTheme()\n    val textColor = if (isDarkTheme) Color.White else Color.Black\n\n    Text(\n        text = stringResource(R.string.audio).uppercase(),\n        style = TextStyle(\n            fontSize = 14.sp,\n            fontWeight = FontWeight.Light,\n            color = textColor.copy(alpha = 0.6f)\n        ),\n        modifier = Modifier.padding(8.dp, bottom = 2.dp)\n    )\n\n    val backgroundColor = if (isDarkTheme) Color(0xFF1C1C1E) else Color(0xFFFFFFFF)\n\n    Column(\n        modifier = Modifier\n            .fillMaxWidth()\n            .background(backgroundColor, RoundedCornerShape(14.dp))\n            .padding(top = 2.dp)\n    ) {\n\n        ConversationalAwarenessSwitch()\n\n        Column(\n            modifier = Modifier\n                .fillMaxWidth()\n                .padding(horizontal = 8.dp, vertical = 10.dp)\n        ) {\n            Text(\n                text = stringResource(R.string.adaptive_audio),\n                modifier = Modifier\n                    .padding(end = 8.dp, bottom = 2.dp, start = 2.dp)\n                    .fillMaxWidth(),\n                style = TextStyle(\n                    fontSize = 16.sp,\n                    color = textColor\n                )\n            )\n            Text(\n                text = stringResource(R.string.adaptive_audio_description),\n                modifier = Modifier\n                    .padding(bottom = 8.dp, top = 2.dp)\n                    .padding(end = 2.dp, start = 2.dp)\n                    .fillMaxWidth(),\n                style = TextStyle(\n                    fontSize = 12.sp,\n                    color = textColor.copy(alpha = 0.6f)\n                )\n            )\n\n            AdaptiveStrengthSlider()\n        }\n    }\n}\n\n@Preview\n@Composable\nfun AudioSettingsPreview() {\n    AudioSettings()\n}\n"
        },
        {
          "name": "VolumeControlSwitch.kt",
          "ext": ".kt",
          "size": 4792,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n *\n * Copyright (C) 2025 LibrePods contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\n@file:OptIn(ExperimentalEncodingApi::class)\n\npackage me.kavishdevar.librepods.composables\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.clickable\nimport androidx.compose.foundation.gestures.detectTapGestures\nimport androidx.compose.foundation.interaction.MutableInteractionSource\nimport androidx.compose.foundation.isSystemInDarkTheme\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.Spacer\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.input.pointer.pointerInput\nimport androidx.compose.ui.tooling.preview.Preview\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport me.kavishdevar.librepods.services.ServiceManager\nimport me.kavishdevar.librepods.utils.AACPManager\nimport kotlin.io.encoding.ExperimentalEncodingApi\n\n@Composable\nfun VolumeControlSwitch() {\n    val service = ServiceManager.getService()!!\n    val volumeControlEnabledValue = service.aacpManager.controlCommandStatusList.find {\n        it.identifier == AACPManager.Companion.ControlCommandIdentifiers.VOLUME_SWIPE_MODE\n    }?.value?.takeIf { it.isNotEmpty() }?.get(0)\n    var volumeControlEnabled by remember {\n        mutableStateOf(\n            volumeControlEnabledValue == 1.toByte()\n        )\n    }\n    fun updateVolumeControlEnabled(enabled: Boolean) {\n        volumeControlEnabled = enabled\n        service.aacpManager.sendControlCommand(\n            AACPManager.Companion.ControlCommandIdentifiers.VOLUME_SWIPE_MODE.value,\n            enabled\n        )\n    }\n\n    val isDarkTheme = isSystemInDarkTheme()\n    val textColor = if (isDarkTheme) Color.White else Color.Black\n\n    val isPressed = remember { mutableStateOf(false) }\n\n    Row(\n        modifier = Modifier\n            .fillMaxWidth()\n            .background(\n                shape = RoundedCornerShape(14.dp),\n                color = if (isPressed.value) Color(0xFFE0E0E0) else Color.Transparent\n            )\n            .padding(horizontal = 12.dp, vertical = 12.dp)\n            .pointerInput(Unit) {\n                detectTapGestures(\n                    onPress = {\n                        isPressed.value = true\n                        tryAwaitRelease()\n                        isPressed.value = false\n                    }\n                )\n            }\n            .clickable(\n                indication = null,\n                interactionSource = remember { MutableInteractionSource() }\n            ) {\n                updateVolumeControlEnabled(!volumeControlEnabled)\n            },\n        verticalAlignment = Alignment.CenterVertically\n    ) {\n        Column(\n            modifier = Modifier\n                .weight(1f)\n                .padding(end = 4.dp)\n        ) {\n            Text(\n                text = \"Volume Control\",\n                fontSize = 16.sp,\n                color = textColor\n            )\n            Spacer(modifier = Modifier.height(4.dp))\n            Text(\n                text = \"Adjust the volume by swiping up or down on the sensor located on the AirPods Pro stem.\",\n                fontSize = 12.sp,\n                color = textColor.copy(0.6f),\n                lineHeight = 14.sp,\n            )\n        }\n        StyledSwitch(\n            checked = volumeControlEnabled,\n            onCheckedChange = {\n                updateVolumeControlEnabled(it)\n            },\n        )\n    }\n}\n\n@Preview\n@Composable\nfun VolumeControlSwitchPreview() {\n    VolumeControlSwitch()\n}\n"
        },
        {
          "name": "AccessibilitySettings.kt",
          "ext": ".kt",
          "size": 8563,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n *\n * Copyright (C) 2025 LibrePods contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\n@file:OptIn(ExperimentalEncodingApi::class)\n\npackage me.kavishdevar.librepods.composables\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.clickable\nimport androidx.compose.foundation.isSystemInDarkTheme\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.material3.DropdownMenu\nimport androidx.compose.material3.DropdownMenuItem\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.text.TextStyle\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.tooling.preview.Preview\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport me.kavishdevar.librepods.R\nimport me.kavishdevar.librepods.services.ServiceManager\nimport me.kavishdevar.librepods.utils.AACPManager\nimport kotlin.io.encoding.ExperimentalEncodingApi\n\n@Composable\nfun AccessibilitySettings() {\n    val isDarkTheme = isSystemInDarkTheme()\n    val textColor = if (isDarkTheme) Color.White else Color.Black\n    val backgroundColor = if (isDarkTheme) Color(0xFF1C1C1E) else Color(0xFFFFFFFF)\n    val service = ServiceManager.getService()!!\n    Text(\n        text = stringResource(R.string.accessibility).uppercase(),\n        style = TextStyle(\n            fontSize = 14.sp,\n            fontWeight = FontWeight.Light,\n            color = textColor.copy(alpha = 0.6f)\n        ),\n        modifier = Modifier.padding(8.dp, bottom = 2.dp)\n    )\n\n    Column(\n        modifier = Modifier\n            .fillMaxWidth()\n            .background(backgroundColor, RoundedCornerShape(14.dp))\n            .padding(top = 2.dp)\n    ) {\n        Column(\n            modifier = Modifier\n                .fillMaxWidth()\n                .padding(12.dp)\n        ) {\n            Text(\n                text = stringResource(R.string.tone_volume),\n                modifier = Modifier\n                    .padding(end = 8.dp, bottom = 2.dp, start = 2.dp)\n                    .fillMaxWidth(),\n                style = TextStyle(\n                    fontSize = 16.sp,\n                    fontWeight = FontWeight.Medium,\n                    color = textColor\n                )\n            )\n\n            ToneVolumeSlider()\n        }\n\n        val pressSpeedOptions = mapOf(\n            0.toByte() to \"Default\",\n            1.toByte() to \"Slower\",\n            2.toByte() to \"Slowest\"\n        )\n        val selectedPressSpeedValue = service.aacpManager.controlCommandStatusList.find { it.identifier == AACPManager.Companion.ControlCommandIdentifiers.DOUBLE_CLICK_INTERVAL }?.value?.takeIf { it.isNotEmpty() }?.get(0)\n        var selectedPressSpeed by remember { mutableStateOf(pressSpeedOptions[selectedPressSpeedValue] ?: pressSpeedOptions[0]) }\n        DropdownMenuComponent(\n            label = \"Press Speed\",\n            options = pressSpeedOptions.values.toList(),\n            selectedOption = selectedPressSpeed.toString(),\n            onOptionSelected = { newValue ->\n                selectedPressSpeed = newValue\n                service.aacpManager.sendControlCommand(\n                    identifier = AACPManager.Companion.ControlCommandIdentifiers.DOUBLE_CLICK_INTERVAL.value,\n                    value = pressSpeedOptions.filterValues { it == newValue }.keys.firstOrNull() ?: 0.toByte()\n                )\n            },\n            textColor = textColor\n        )\n\n        val pressAndHoldDurationOptions = mapOf(\n            0.toByte() to \"Default\",\n            1.toByte() to \"Slower\",\n            2.toByte() to \"Slowest\"\n        )\n\n        val selectedPressAndHoldDurationValue = service.aacpManager.controlCommandStatusList.find { it.identifier == AACPManager.Companion.ControlCommandIdentifiers.CLICK_HOLD_INTERVAL }?.value?.takeIf { it.isNotEmpty() }?.get(0)\n        var selectedPressAndHoldDuration by remember { mutableStateOf(pressAndHoldDurationOptions[selectedPressAndHoldDurationValue] ?: pressAndHoldDurationOptions[0]) }\n        DropdownMenuComponent(\n            label = \"Press and Hold Duration\",\n            options = pressAndHoldDurationOptions.values.toList(),\n            selectedOption = selectedPressAndHoldDuration.toString(),\n            onOptionSelected = { newValue ->\n                selectedPressAndHoldDuration = newValue\n                service.aacpManager.sendControlCommand(\n                    identifier = AACPManager.Companion.ControlCommandIdentifiers.CLICK_HOLD_INTERVAL.value,\n                    value = pressAndHoldDurationOptions.filterValues { it == newValue }.keys.firstOrNull() ?: 0.toByte()\n                )\n            },\n            textColor = textColor\n        )\n\n        val volumeSwipeSpeedOptions = mapOf<Byte, String>(\n            1.toByte() to \"Default\",\n            2.toByte() to \"Longer\",\n            3.toByte() to \"Longest\"\n        )\n        val selectedVolumeSwipeSpeedValue = service.aacpManager.controlCommandStatusList.find { it.identifier == AACPManager.Companion.ControlCommandIdentifiers.VOLUME_SWIPE_INTERVAL }?.value?.takeIf { it.isNotEmpty() }?.get(0)\n        var selectedVolumeSwipeSpeed by remember { mutableStateOf(volumeSwipeSpeedOptions[selectedVolumeSwipeSpeedValue] ?: volumeSwipeSpeedOptions[1]) }\n        DropdownMenuComponent(\n            label = \"Volume Swipe Speed\",\n            options = volumeSwipeSpeedOptions.values.toList(),\n            selectedOption = selectedVolumeSwipeSpeed.toString(),\n            onOptionSelected = { newValue ->\n                selectedVolumeSwipeSpeed = newValue\n                service.aacpManager.sendControlCommand(\n                    identifier = AACPManager.Companion.ControlCommandIdentifiers.VOLUME_SWIPE_INTERVAL.value,\n                    value = volumeSwipeSpeedOptions.filterValues { it == newValue }.keys.firstOrNull() ?: 1.toByte()\n                )\n            },\n            textColor = textColor\n        )\n\n        SinglePodANCSwitch()\n        VolumeControlSwitch()\n    }\n}\n\n@Composable\nfun DropdownMenuComponent(\n    label: String,\n    options: List<String>,\n    selectedOption: String,\n    onOptionSelected: (String) -> Unit,\n    textColor: Color\n) {\n    var expanded by remember { mutableStateOf(false) }\n\n    Column (\n        modifier = Modifier\n            .fillMaxWidth()\n            .padding(horizontal = 12.dp)\n    ) {\n        Text(\n            text = label,\n            style = TextStyle(\n                fontSize = 16.sp,\n                fontWeight = FontWeight.Medium,\n                color = textColor\n            )\n        )\n\n        Box(\n            modifier = Modifier\n                .fillMaxWidth()\n                .clickable { expanded = true }\n                .padding(8.dp)\n        ) {\n            Text(\n                text = selectedOption,\n                modifier = Modifier.padding(16.dp),\n                color = textColor\n            )\n        }\n\n        DropdownMenu(\n            expanded = expanded,\n            onDismissRequest = { expanded = false }\n        ) {\n            options.forEach { option ->\n                DropdownMenuItem(\n                    onClick = {\n                        onOptionSelected(option)\n                        expanded = false\n                    },\n                    text = { Text(text = option) }\n                )\n            }\n        }\n    }\n}\n\n@Preview\n@Composable\nfun AccessibilitySettingsPreview() {\n    AccessibilitySettings()\n}\n"
        },
        {
          "name": "ToneVolumeSlider.kt",
          "ext": ".kt",
          "size": 6300,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n *\n * Copyright (C) 2025 LibrePods contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\n@file:OptIn(ExperimentalEncodingApi::class)\n\npackage me.kavishdevar.librepods.composables\n\nimport android.util.Log\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.isSystemInDarkTheme\nimport androidx.compose.foundation.layout.Arrangement\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.size\nimport androidx.compose.foundation.shape.CircleShape\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.Slider\nimport androidx.compose.material3.SliderDefaults\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.mutableFloatStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.shadow\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.text.TextStyle\nimport androidx.compose.ui.text.font.Font\nimport androidx.compose.ui.text.font.FontFamily\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.tooling.preview.Preview\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport me.kavishdevar.librepods.R\nimport me.kavishdevar.librepods.services.ServiceManager\nimport me.kavishdevar.librepods.utils.AACPManager\nimport kotlin.io.encoding.ExperimentalEncodingApi\nimport kotlin.math.roundToInt\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun ToneVolumeSlider() {\n    val service = ServiceManager.getService()!!\n    val sliderValueFromAACP = service.aacpManager.controlCommandStatusList.find {\n        it.identifier == AACPManager.Companion.ControlCommandIdentifiers.CHIME_VOLUME\n    }?.value?.takeIf { it.isNotEmpty() }?.get(0)\n    val sliderValue = remember { mutableFloatStateOf(\n        sliderValueFromAACP?.toFloat() ?: -1f\n    ) }\n    Log.d(\"ToneVolumeSlider\", \"Slider value: ${sliderValue.floatValue}\")\n\n    val isDarkTheme = isSystemInDarkTheme()\n\n    val trackColor = if (isDarkTheme) Color(0xFFB3B3B3) else Color(0xFF929491)\n    val activeTrackColor = if (isDarkTheme) Color(0xFF007AFF) else Color(0xFF3C6DF5)\n    val thumbColor = if (isDarkTheme) Color(0xFFFFFFFF) else Color(0xFFFFFFFF)\n    val labelTextColor = if (isDarkTheme) Color.White else Color.Black\n\n    Row(\n        modifier = Modifier\n            .fillMaxWidth(),\n        horizontalArrangement = Arrangement.SpaceBetween,\n        verticalAlignment = Alignment.CenterVertically\n    ) {\n        Text(\n            text = \"\\uDBC0\\uDEA1\",\n            style = TextStyle(\n                fontSize = 16.sp,\n                fontFamily = FontFamily(Font(R.font.sf_pro)),\n                fontWeight = FontWeight.Light,\n                color = labelTextColor\n            ),\n            modifier = Modifier.padding(start = 4.dp)\n        )\n        Slider(\n            value = sliderValue.floatValue,\n            onValueChange = {\n                sliderValue.floatValue = it\n            },\n            valueRange = 0f..100f,\n            onValueChangeFinished = {\n                sliderValue.floatValue = sliderValue.floatValue.roundToInt().toFloat()\n                service.aacpManager.sendControlCommand(\n                    identifier = AACPManager.Companion.ControlCommandIdentifiers.CHIME_VOLUME.value,\n                    value = byteArrayOf(sliderValue.floatValue.toInt().toByte(),\n                       0x50.toByte()\n                    )\n                )\n            },\n            modifier = Modifier\n                .weight(1f)\n                .height(36.dp),\n            colors = SliderDefaults.colors(\n                thumbColor = thumbColor,\n                activeTrackColor = activeTrackColor,\n                inactiveTrackColor = trackColor\n            ),\n            thumb = {\n                Box(\n                    modifier = Modifier\n                        .size(24.dp)\n                        .shadow(4.dp, CircleShape)\n                        .background(thumbColor, CircleShape)\n                )\n            },\n            track = {\n                Box (\n                    modifier = Modifier\n                        .fillMaxWidth()\n                        .height(12.dp),\n                    contentAlignment = Alignment.CenterStart\n                )\n                {\n                    Box(\n                        modifier = Modifier\n                            .fillMaxWidth()\n                            .height(4.dp)\n                            .background(trackColor, RoundedCornerShape(4.dp))\n                    )\n                    Box(\n                        modifier = Modifier\n                            .fillMaxWidth(sliderValue.floatValue / 100)\n                            .height(4.dp)\n                            .background(activeTrackColor, RoundedCornerShape(4.dp))\n                    )\n                }\n            }\n        )\n        Text(\n            text = \"\\uDBC0\\uDEA9\",\n            style = TextStyle(\n                fontSize = 16.sp,\n                fontFamily = FontFamily(Font(R.font.sf_pro)),\n                fontWeight = FontWeight.Light,\n                color = labelTextColor\n            ),\n            modifier = Modifier.padding(end = 4.dp)\n        )\n    }\n}\n\n@Preview\n@Composable\nfun ToneVolumeSliderPreview() {\n    ToneVolumeSlider()\n}\n"
        },
        {
          "name": "ConversationalAwarenessSwitch.kt",
          "ext": ".kt",
          "size": 4901,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n *\n * Copyright (C) 2025 LibrePods contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\n@file:OptIn(ExperimentalEncodingApi::class)\n\npackage me.kavishdevar.librepods.composables\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.clickable\nimport androidx.compose.foundation.gestures.detectTapGestures\nimport androidx.compose.foundation.interaction.MutableInteractionSource\nimport androidx.compose.foundation.isSystemInDarkTheme\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.Spacer\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.input.pointer.pointerInput\nimport androidx.compose.ui.tooling.preview.Preview\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport me.kavishdevar.librepods.services.ServiceManager\nimport me.kavishdevar.librepods.utils.AACPManager\nimport kotlin.io.encoding.ExperimentalEncodingApi\n\n@Composable\nfun ConversationalAwarenessSwitch() {\n    val service = ServiceManager.getService()!!\n    val conversationEnabledValue = service.aacpManager.controlCommandStatusList.find {\n        it.identifier == AACPManager.Companion.ControlCommandIdentifiers.CONVERSATION_DETECT_CONFIG\n    }?.value?.takeIf { it.isNotEmpty() }?.get(0)\n    var conversationalAwarenessEnabled by remember {\n        mutableStateOf(\n            conversationEnabledValue == 1.toByte()\n        )\n    }\n\n    fun updateConversationalAwareness(enabled: Boolean) {\n        conversationalAwarenessEnabled = enabled\n        service.aacpManager.sendControlCommand(\n            AACPManager.Companion.ControlCommandIdentifiers.CONVERSATION_DETECT_CONFIG.value,\n            enabled\n        )\n    }\n\n    val isDarkTheme = isSystemInDarkTheme()\n    val textColor = if (isDarkTheme) Color.White else Color.Black\n\n    val isPressed = remember { mutableStateOf(false) }\n\n    Row(\n        modifier = Modifier\n            .fillMaxWidth()\n            .background(\n                shape = RoundedCornerShape(14.dp),\n                color = if (isPressed.value) Color(0xFFE0E0E0) else Color.Transparent\n            )\n            .padding(horizontal = 12.dp, vertical = 12.dp)\n            .pointerInput(Unit) {\n                detectTapGestures(\n                    onPress = {\n                        isPressed.value = true\n                        tryAwaitRelease()\n                        isPressed.value = false\n                    }\n                )\n            }\n            .clickable(\n                indication = null,\n                interactionSource = remember { MutableInteractionSource() }\n            ) {\n                updateConversationalAwareness(!conversationalAwarenessEnabled)\n            },\n        verticalAlignment = Alignment.CenterVertically\n    ) {\n        Column(\n            modifier = Modifier\n                .weight(1f)\n                .padding(end = 4.dp)\n        ) {\n            Text(\n                text = \"Conversational Awareness\",\n                fontSize = 16.sp,\n                color = textColor\n            )\n            Spacer(modifier = Modifier.height(4.dp))\n            Text(\n                text = \"Lowers media volume and reduces background noise when you start speaking to other people.\",\n                fontSize = 12.sp,\n                color = textColor.copy(0.6f),\n                lineHeight = 14.sp,\n            )\n        }\n        StyledSwitch(\n            checked = conversationalAwarenessEnabled,\n            onCheckedChange = {\n                updateConversationalAwareness(it)\n            },\n        )\n    }\n}\n\n@Preview\n@Composable\nfun ConversationalAwarenessSwitchPreview() {\n    ConversationalAwarenessSwitch()\n}\n"
        }
      ]
    },
    {
      "dir": "android/app/src/main/java/me/kavishdevar/librepods/ui",
      "files": []
    },
    {
      "dir": "android/app/src/main/java/me/kavishdevar/librepods/ui/theme",
      "files": [
        {
          "name": "Theme.kt",
          "ext": ".kt",
          "size": 2090,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n * \n * Copyright (C) 2025 LibrePods contributors\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n * \n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\npackage me.kavishdevar.librepods.ui.theme\n\nimport android.os.Build\nimport androidx.compose.foundation.isSystemInDarkTheme\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.darkColorScheme\nimport androidx.compose.material3.dynamicDarkColorScheme\nimport androidx.compose.material3.dynamicLightColorScheme\nimport androidx.compose.material3.lightColorScheme\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.platform.LocalContext\n\nprivate val DarkColorScheme = darkColorScheme(\n    primary = Purple80,\n    secondary = PurpleGrey80,\n    tertiary = Pink80\n)\n\nprivate val LightColorScheme = lightColorScheme(\n    primary = Purple40,\n    secondary = PurpleGrey40,\n    tertiary = Pink40\n)\n\n@Composable\nfun LibrePodsTheme(\n    darkTheme: Boolean = isSystemInDarkTheme(),\n    dynamicColor: Boolean = true,\n    content: @Composable () -> Unit\n) {\n    val colorScheme = when {\n        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {\n            val context = LocalContext.current\n            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)\n        }\n\n        darkTheme -> DarkColorScheme\n        else -> LightColorScheme\n    }\n\n    MaterialTheme(\n        colorScheme = colorScheme,\n        typography = Typography,\n        content = content\n    )\n}"
        },
        {
          "name": "Type.kt",
          "ext": ".kt",
          "size": 1739,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n * \n * Copyright (C) 2025 LibrePods contributors\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n * \n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\npackage me.kavishdevar.librepods.ui.theme\n\nimport androidx.compose.material3.Typography\nimport androidx.compose.ui.text.TextStyle\nimport androidx.compose.ui.text.font.FontFamily\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.unit.sp\n\n// Set of Material typography styles to start with\nval Typography = Typography(\n    bodyLarge = TextStyle(\n        fontFamily = FontFamily.Default,\n        fontWeight = FontWeight.Normal,\n        fontSize = 16.sp,\n        lineHeight = 24.sp,\n        letterSpacing = 0.5.sp\n    )\n    /* Other default text styles to override\n    titleLarge = TextStyle(\n        fontFamily = FontFamily.Default,\n        fontWeight = FontWeight.Normal,\n        fontSize = 22.sp,\n        lineHeight = 28.sp,\n        letterSpacing = 0.sp\n    ),\n    labelSmall = TextStyle(\n        fontFamily = FontFamily.Default,\n        fontWeight = FontWeight.Medium,\n        fontSize = 11.sp,\n        lineHeight = 16.sp,\n        letterSpacing = 0.5.sp\n    )\n    */\n)"
        },
        {
          "name": "Color.kt",
          "ext": ".kt",
          "size": 1035,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n * \n * Copyright (C) 2025 LibrePods contributors\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n * \n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\n\npackage me.kavishdevar.librepods.ui.theme\n\nimport androidx.compose.ui.graphics.Color\n\nval Purple80 = Color(0xFFD0BCFF)\nval PurpleGrey80 = Color(0xFFCCC2DC)\nval Pink80 = Color(0xFFEFB8C8)\n\nval Purple40 = Color(0xFF6650a4)\nval PurpleGrey40 = Color(0xFF625b71)\nval Pink40 = Color(0xFF7D5260)"
        }
      ]
    },
    {
      "dir": "android/app/src/main/java/me/kavishdevar/librepods/screens",
      "files": [
        {
          "name": "HeadTrackingScreen.kt",
          "ext": ".kt",
          "size": 36377,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n *\n * Copyright (C) 2025 LibrePods contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\n@file:OptIn(ExperimentalEncodingApi::class)\n\npackage me.kavishdevar.librepods.screens\n\nimport android.content.Context\nimport android.os.Build\nimport android.util.Log\nimport androidx.annotation.RequiresApi\nimport androidx.compose.animation.AnimatedContent\nimport androidx.compose.animation.ExperimentalAnimationApi\nimport androidx.compose.animation.core.tween\nimport androidx.compose.animation.fadeIn\nimport androidx.compose.animation.fadeOut\nimport androidx.compose.animation.slideInVertically\nimport androidx.compose.animation.togetherWith\nimport androidx.compose.foundation.Canvas\nimport androidx.compose.foundation.isSystemInDarkTheme\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Spacer\nimport androidx.compose.foundation.layout.aspectRatio\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.width\nimport androidx.compose.foundation.rememberScrollState\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.foundation.verticalScroll\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.automirrored.filled.KeyboardArrowLeft\nimport androidx.compose.material.icons.filled.PlayArrow\nimport androidx.compose.material3.Button\nimport androidx.compose.material3.ButtonDefaults\nimport androidx.compose.material3.Card\nimport androidx.compose.material3.CardDefaults\nimport androidx.compose.material3.CenterAlignedTopAppBar\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.IconButton\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TextButton\nimport androidx.compose.material3.TopAppBarDefaults\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.DisposableEffect\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.collectAsState\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableFloatStateOf\nimport androidx.compose.runtime.mutableLongStateOf\nimport androidx.compose.runtime.mutableStateListOf\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.rememberCoroutineScope\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.drawBehind\nimport androidx.compose.ui.draw.scale\nimport androidx.compose.ui.geometry.CornerRadius\nimport androidx.compose.ui.geometry.Offset\nimport androidx.compose.ui.geometry.Size\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.graphics.Path\nimport androidx.compose.ui.graphics.SolidColor\nimport androidx.compose.ui.graphics.StrokeCap\nimport androidx.compose.ui.graphics.asAndroidPath\nimport androidx.compose.ui.graphics.drawscope.Stroke\nimport androidx.compose.ui.graphics.nativeCanvas\nimport androidx.compose.ui.graphics.toArgb\nimport androidx.compose.ui.graphics.vector.ImageVector\nimport androidx.compose.ui.graphics.vector.path\nimport androidx.compose.ui.input.nestedscroll.nestedScroll\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.text.TextStyle\nimport androidx.compose.ui.text.drawText\nimport androidx.compose.ui.text.font.Font\nimport androidx.compose.ui.text.font.FontFamily\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.text.rememberTextMeasurer\nimport androidx.compose.ui.text.style.TextAlign\nimport androidx.compose.ui.text.style.TextOverflow\nimport androidx.compose.ui.tooling.preview.Preview\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport androidx.navigation.NavController\nimport dev.chrisbanes.haze.HazeEffectScope\nimport dev.chrisbanes.haze.HazeState\nimport dev.chrisbanes.haze.hazeEffect\nimport dev.chrisbanes.haze.hazeSource\nimport dev.chrisbanes.haze.materials.CupertinoMaterials\nimport dev.chrisbanes.haze.materials.ExperimentalHazeMaterialsApi\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.launch\nimport me.kavishdevar.librepods.R\nimport me.kavishdevar.librepods.composables.IndependentToggle\nimport me.kavishdevar.librepods.services.ServiceManager\nimport me.kavishdevar.librepods.utils.HeadTracking\nimport kotlin.io.encoding.ExperimentalEncodingApi\nimport kotlin.math.abs\nimport kotlin.math.cos\nimport kotlin.math.sin\nimport kotlin.random.Random\n\n@ExperimentalHazeMaterialsApi\n@RequiresApi(Build.VERSION_CODES.Q)\n@OptIn(ExperimentalMaterial3Api::class, ExperimentalAnimationApi::class)\n@Composable\nfun HeadTrackingScreen(navController: NavController) {\n    DisposableEffect(Unit) {\n        ServiceManager.getService()?.startHeadTracking()\n        onDispose {\n            ServiceManager.getService()?.stopHeadTracking()\n        }\n    }\n    val sharedPreferences = LocalContext.current.getSharedPreferences(\"settings\", Context.MODE_PRIVATE)\n    val isDarkTheme = isSystemInDarkTheme()\n    val backgroundColor = if (isDarkTheme) Color(0xFF1C1C1E) else Color(0xFFFFFFFF)\n    val textColor = if (isDarkTheme) Color.White else Color.Black\n\n    val scrollState = rememberScrollState()\n    val scrollBehavior = TopAppBarDefaults.pinnedScrollBehavior()\n    val hazeState = remember { HazeState() }\n\n    var mDensity by remember { mutableFloatStateOf(0f) }\n    Scaffold(\n        modifier = Modifier.nestedScroll(scrollBehavior.nestedScrollConnection),\n        topBar = {\n            CenterAlignedTopAppBar(\n                modifier = Modifier.hazeEffect(\n                    state = hazeState,\n                    style = CupertinoMaterials.thick(),\n                    block = fun HazeEffectScope.() {\n                        alpha =\n                            if (scrollState.value > 60.dp.value * mDensity) 1f else 0f\n                    })\n                    .drawBehind {\n                        mDensity = density\n                        val strokeWidth = 0.7.dp.value * density\n                        val y = size.height - strokeWidth / 2\n                        if (scrollState.value > 60.dp.value * density) {\n                            drawLine(\n                                if (isDarkTheme) Color.DarkGray else Color.LightGray,\n                                Offset(0f, y),\n                                Offset(size.width, y),\n                                strokeWidth\n                            )\n                        }\n                    },\n                title = {\n                    Text(\n                        stringResource(R.string.head_tracking),\n                        fontFamily = FontFamily(Font(R.font.sf_pro)),\n                    )\n                },\n                navigationIcon = {\n                    TextButton(\n                        onClick = {\n                            navController.popBackStack()\n                            if (ServiceManager.getService()?.isHeadTrackingActive == true) ServiceManager.getService()?.stopHeadTracking()\n                        },\n                        shape = RoundedCornerShape(8.dp),\n                        modifier = Modifier.width(180.dp)\n                    ) {\n                        Icon(\n                            Icons.AutoMirrored.Filled.KeyboardArrowLeft,\n                            contentDescription = \"Back\",\n                            tint = if (isDarkTheme)  Color(0xFF007AFF) else Color(0xFF3C6DF5),\n                            modifier = Modifier.scale(1.5f)\n                        )\n                        Text(\n                            sharedPreferences.getString(\"name\", \"AirPods\")!!,\n                            style = TextStyle(\n                                fontSize = 18.sp,\n                                fontWeight = FontWeight.Medium,\n                                color = if (isDarkTheme) Color(0xFF007AFF) else Color(0xFF3C6DF5),\n                                fontFamily = FontFamily(Font(R.font.sf_pro))\n                            ),\n                            maxLines = 1,\n                            overflow = TextOverflow.Ellipsis,\n                            modifier = Modifier.weight(1f)\n                        )\n                    }\n                },\n                colors = TopAppBarDefaults.centerAlignedTopAppBarColors(\n                    containerColor = Color.Transparent\n                ),\n                actions = {\n                    var isActive by remember { mutableStateOf(ServiceManager.getService()?.isHeadTrackingActive == true) }\n                    IconButton(\n                        onClick = {\n                            if (ServiceManager.getService()?.isHeadTrackingActive == false) {\n                                ServiceManager.getService()?.startHeadTracking()\n                                Log.d(\"HeadTrackingScreen\", \"Head tracking started\")\n                                isActive = true\n                            } else {\n                                ServiceManager.getService()?.stopHeadTracking()\n                                Log.d(\"HeadTrackingScreen\", \"Head tracking stopped\")\n                                isActive = false\n                            }\n                      },\n                    ) {\n                        Icon(\n                            if (isActive) {\n                                ImageVector.Builder(\n                                    name = \"Pause\",\n                                    defaultWidth = 24.dp,\n                                    defaultHeight = 24.dp,\n                                    viewportWidth = 24f,\n                                    viewportHeight = 24f\n                                ).apply {\n                                    path(\n                                        fill = SolidColor(Color.Black),\n                                        pathBuilder = {\n                                            moveTo(6f, 5f)\n                                            lineTo(10f, 5f)\n                                            lineTo(10f, 19f)\n                                            lineTo(6f, 19f)\n                                            lineTo(6f, 5f)\n                                            moveTo(14f, 5f)\n                                            lineTo(18f, 5f)\n                                            lineTo(18f, 19f)\n                                            lineTo(14f, 19f)\n                                            lineTo(14f, 5f)\n                                        }\n                                    )\n                                }.build()\n                            } else Icons.Filled.PlayArrow,\n                            contentDescription = \"Start\",\n                            tint = if (isDarkTheme) Color(0xFF007AFF) else Color(0xFF3C6DF5),\n                            modifier = Modifier.scale(1.5f)\n                        )\n                    }\n                },\n                scrollBehavior = scrollBehavior\n            )\n        },\n        containerColor = if (isSystemInDarkTheme()) Color(0xFF000000)\n        else Color(0xFFF2F2F7),\n    ) { paddingValues ->\n        Column (\n            modifier = Modifier\n                .fillMaxSize()\n                .padding(paddingValues = paddingValues)\n                .padding(horizontal = 16.dp)\n                .padding(top = 8.dp)\n                .verticalScroll(scrollState)\n                .hazeSource(state = hazeState)\n        ) {\n            val sharedPreferences =\n                LocalContext.current.getSharedPreferences(\"settings\", Context.MODE_PRIVATE)\n\n            var gestureText by remember { mutableStateOf(\"\") }\n            val coroutineScope = rememberCoroutineScope()\n\n            IndependentToggle(name = \"Head Gestures\", sharedPreferences = sharedPreferences)\n            Spacer(modifier = Modifier.height(2.dp))\n            Text(\n                stringResource(R.string.head_gestures_details),\n                style = TextStyle(\n                    fontSize = 14.sp,\n                    fontWeight = FontWeight.Normal,\n                    fontFamily = FontFamily(Font(R.font.sf_pro)),\n                    color = textColor.copy(0.6f)\n                ),\n                modifier = Modifier.padding(start = 4.dp)\n            )\n\n            Spacer(modifier = Modifier.height(16.dp))\n            Text(\n                \"Head Orientation\",\n                style = TextStyle(\n                    fontSize = 18.sp,\n                    fontWeight = FontWeight.Medium,\n                    fontFamily = FontFamily(Font(R.font.sf_pro)),\n                    color = textColor\n                ),\n                modifier = Modifier.padding(start = 4.dp, bottom = 8.dp, top = 8.dp)\n            )\n            HeadVisualization()\n\n            Spacer(modifier = Modifier.height(16.dp))\n            Text(\n                \"Acceleration\",\n                style = TextStyle(\n                    fontSize = 18.sp,\n                    fontWeight = FontWeight.Medium,\n                    fontFamily = FontFamily(Font(R.font.sf_pro)),\n                    color = textColor\n                ),\n                modifier = Modifier.padding(start = 4.dp, bottom = 8.dp, top = 8.dp)\n            )\n            AccelerationPlot()\n\n            Spacer(modifier = Modifier.height(16.dp))\n            Button (\n                onClick = {\n                    gestureText = \"Shake your head or nod!\"\n                    coroutineScope.launch {\n                        val accepted = ServiceManager.getService()?.testHeadGestures() ?: false\n                        gestureText = if (accepted) \"\\\"Yes\\\" gesture detected.\" else \"\\\"No\\\" gesture detected.\"\n                    }\n                },\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .height(55.dp),\n                colors = ButtonDefaults.buttonColors(\n                    containerColor = backgroundColor\n                ),\n                shape = RoundedCornerShape(8.dp)\n            ) {\n                Text(\n                    \"Test Head Gestures\",\n                    style = TextStyle(\n                        fontSize = 16.sp,\n                        fontWeight = FontWeight.Medium,\n                        fontFamily = FontFamily(Font(R.font.sf_pro)),\n                        color = textColor\n                    ),\n                )\n            }\n            var lastClickTime by remember { mutableLongStateOf(0L) }\n            var shouldExplode by remember { mutableStateOf(false) }\n\n            LaunchedEffect(gestureText) {\n                if (gestureText.isNotEmpty()) {\n                    lastClickTime = System.currentTimeMillis()\n                    delay(3000)\n                    if (System.currentTimeMillis() - lastClickTime >= 3000) {\n                        shouldExplode = true\n                    }\n                }\n            }\n\n            Box(\n                contentAlignment = Alignment.Center,\n                modifier = Modifier.padding(top = 12.dp, bottom = 24.dp)\n            ) {\n                AnimatedContent(\n                    targetState = gestureText,\n                    transitionSpec = {\n                        (fadeIn(\n                            animationSpec = tween(300)\n                        ) + slideInVertically(\n                            initialOffsetY = { 40 },\n                            animationSpec = tween(300)\n                        )).togetherWith(fadeOut(animationSpec = tween(150)))\n                    }\n                ) { text ->\n                    if (shouldExplode) {\n                        LaunchedEffect(Unit) {\n                            CoroutineScope(coroutineScope.coroutineContext).launch {\n                                delay(750)\n                                gestureText = \"\"\n                            }\n                        }\n                        ParticleText(\n                            text = text,\n                            style = TextStyle(\n                                fontSize = 20.sp,\n                                fontWeight = FontWeight.Medium,\n                                fontFamily = FontFamily(Font(R.font.sf_pro)),\n                                color = textColor,\n                                textAlign = TextAlign.Center\n                            ),\n                            onAnimationComplete = {\n                                shouldExplode = false\n                            },\n                        )\n                    } else {\n                        Text(\n                            text = text,\n                            style = TextStyle(\n                                fontSize = 20.sp,\n                                fontWeight = FontWeight.Medium,\n                                fontFamily = FontFamily(Font(R.font.sf_pro)),\n                                color = textColor,\n                                textAlign = TextAlign.Center\n                            ),\n                            modifier = Modifier\n                                .fillMaxWidth()\n                        )\n                    }\n                }\n            }\n        }\n    }\n}\nprivate data class Particle(\n    val initialPosition: Offset,\n    val velocity: Offset,\n    var alpha: Float = 1f\n)\n\n@Composable\nprivate fun ParticleText(\n    text: String,\n    style: TextStyle,\n    onAnimationComplete: () -> Unit,\n) {\n    val particles = remember { mutableStateListOf<Particle>() }\n    val textMeasurer = rememberTextMeasurer()\n    var isAnimating by remember { mutableStateOf(true) }\n    var textVisible by remember { mutableStateOf(true) }\n\n    Canvas(modifier = Modifier.fillMaxWidth()) {\n        val textLayoutResult = textMeasurer.measure(text, style)\n        val textBounds = textLayoutResult.size\n        val centerX = (size.width - textBounds.width) / 2\n        val centerY = size.height / 2\n\n        if (textVisible && particles.isEmpty()) {\n            drawText(\n                textMeasurer = textMeasurer,\n                text = text,\n                style = style,\n                topLeft = Offset(centerX, centerY - textBounds.height / 2)\n            )\n        }\n\n        if (particles.isEmpty()) {\n            val random = Random(System.currentTimeMillis())\n            for (i in 0..100) {\n                val x = centerX + random.nextFloat() * textBounds.width\n                val y = centerY - textBounds.height / 2 + random.nextFloat() * textBounds.height\n                val vx = (random.nextFloat() - 0.5f) * 20\n                val vy = (random.nextFloat() - 0.5f) * 20\n                particles.add(Particle(Offset(x, y), Offset(vx, vy)))\n            }\n            textVisible = false\n        }\n\n        particles.forEach { particle ->\n            drawCircle(\n                color = style.color.copy(alpha = particle.alpha),\n                radius = 0.5.dp.toPx(),\n                center = particle.initialPosition\n            )\n        }\n    }\n\n    LaunchedEffect(text) {\n        while (isAnimating) {\n            delay(16)\n            particles.forEachIndexed { index, particle ->\n                particles[index] = particle.copy(\n                    initialPosition = particle.initialPosition + particle.velocity,\n                    alpha = (particle.alpha - 0.02f).coerceAtLeast(0f)\n                )\n            }\n\n            if (particles.all { it.alpha <= 0f }) {\n                isAnimating = false\n                onAnimationComplete()\n            }\n        }\n    }\n}\n\n@Composable\nprivate fun HeadVisualization() {\n    val orientation by HeadTracking.orientation.collectAsState()\n    val darkTheme = isSystemInDarkTheme()\n    val backgroundColor = if (darkTheme) Color(0xFF1C1C1E) else Color.White\n    val strokeColor = if (darkTheme) Color.White else Color.Black\n\n    Card(\n        modifier = Modifier\n            .fillMaxWidth()\n            .aspectRatio(2f),\n        colors = CardDefaults.cardColors(\n            containerColor = backgroundColor\n        )\n    ) {\n        Box(\n            modifier = Modifier.fillMaxSize(),\n            contentAlignment = Alignment.Center\n        ) {\n            Canvas(\n                modifier = Modifier\n                    .fillMaxSize()\n                    .padding(16.dp)\n            ) {\n                val width = size.width\n                val height = size.height\n                val center = Offset(width / 2, height / 2)\n                val faceRadius = height * 0.35f\n\n                val pitch = Math.toRadians(orientation.pitch.toDouble())\n                val yaw = Math.toRadians(orientation.yaw.toDouble())\n\n                val cosY = cos(yaw).toFloat()\n                val sinY = sin(yaw).toFloat()\n                val cosP = cos(pitch).toFloat()\n                val sinP = sin(pitch).toFloat()\n\n                fun rotate3D(point: Triple<Float, Float, Float>): Triple<Float, Float, Float> {\n                    val (x, y, z) = point\n                    val x1 = x * cosY - z * sinY\n                    val y1 = y\n                    val z1 = x * sinY + z * cosY\n\n                    val x2 = x1\n                    val y2 = y1 * cosP - z1 * sinP\n                    val z2 = y1 * sinP + z1 * cosP\n\n                    return Triple(x2, y2, z2)\n                }\n\n                fun project(point: Triple<Float, Float, Float>): Pair<Float, Float> {\n                    val (x, y, z) = point\n                    val scale = 1f + (z / width)\n                    return Pair(center.x + x * scale, center.y + y * scale)\n                }\n\n                val earWidth = height * 0.08f\n                val earHeight = height * 0.2f\n                val earOffsetX = height * 0.4f\n                val earOffsetY = 0f\n                val earZ = 0f\n\n                for (xSign in listOf(-1f, 1f)) {\n                    val rotated = rotate3D(Triple(earOffsetX * xSign, earOffsetY, earZ))\n                    val (earX, earY) = project(rotated)\n                    drawRoundRect(\n                        color = strokeColor,\n                        topLeft = Offset(earX - earWidth/2, earY - earHeight/2),\n                        size = Size(earWidth, earHeight),\n                        cornerRadius = CornerRadius(earWidth/2),\n                        style = Stroke(width = 4.dp.toPx())\n                    )\n                }\n\n                val spherePath = Path()\n                val firstPoint = project(rotate3D(Triple(faceRadius, 0f, 0f)))\n                spherePath.moveTo(firstPoint.first, firstPoint.second)\n\n                for (i in 1..32) {\n                    val angle = (i * 2 * Math.PI / 32).toFloat()\n                    val point = project(rotate3D(Triple(\n                        cos(angle) * faceRadius,\n                        sin(angle) * faceRadius,\n                        0f\n                    )))\n                    spherePath.lineTo(point.first, point.second)\n                }\n                spherePath.close()\n\n                drawContext.canvas.nativeCanvas.apply {\n                    val paint = android.graphics.Paint().apply {\n                        style = android.graphics.Paint.Style.FILL\n                        shader = android.graphics.RadialGradient(\n                            center.x + sinY * faceRadius * 0.3f,\n                            center.y - sinP * faceRadius * 0.3f,\n                            faceRadius * 1.4f,\n                            intArrayOf(\n                                backgroundColor.copy(alpha = 1f).toArgb(),\n                                backgroundColor.copy(alpha = 0.95f).toArgb(),\n                                backgroundColor.copy(alpha = 0.9f).toArgb(),\n                                backgroundColor.copy(alpha = 0.8f).toArgb(),\n                                backgroundColor.copy(alpha = 0.7f).toArgb()\n                            ),\n                            floatArrayOf(0.3f, 0.5f, 0.7f, 0.8f, 1f),\n                            android.graphics.Shader.TileMode.CLAMP\n                        )\n                    }\n                    drawPath(spherePath.asAndroidPath(), paint)\n\n                    val highlightPaint = android.graphics.Paint().apply {\n                        style = android.graphics.Paint.Style.FILL\n                        shader = android.graphics.RadialGradient(\n                            center.x - faceRadius * 0.4f - sinY * faceRadius * 0.5f,\n                            center.y - faceRadius * 0.4f - sinP * faceRadius * 0.5f,\n                            faceRadius * 0.9f,\n                            intArrayOf(\n                                android.graphics.Color.WHITE,\n                                android.graphics.Color.argb(100, 255, 255, 255),\n                                android.graphics.Color.TRANSPARENT\n                            ),\n                            floatArrayOf(0f, 0.3f, 1f),\n                            android.graphics.Shader.TileMode.CLAMP\n                        )\n                        alpha = if (darkTheme) 30 else 60\n                    }\n                    drawPath(spherePath.asAndroidPath(), highlightPaint)\n\n                    val secondaryHighlightPaint = android.graphics.Paint().apply {\n                        style = android.graphics.Paint.Style.FILL\n                        shader = android.graphics.RadialGradient(\n                            center.x + faceRadius * 0.3f + sinY * faceRadius * 0.3f,\n                            center.y + faceRadius * 0.3f - sinP * faceRadius * 0.3f,\n                            faceRadius * 0.7f,\n                            intArrayOf(\n                                android.graphics.Color.WHITE,\n                                android.graphics.Color.TRANSPARENT\n                            ),\n                            floatArrayOf(0f, 1f),\n                            android.graphics.Shader.TileMode.CLAMP\n                        )\n                        alpha = if (darkTheme) 15 else 30\n                    }\n                    drawPath(spherePath.asAndroidPath(), secondaryHighlightPaint)\n\n                    val shadowPaint = android.graphics.Paint().apply {\n                        style = android.graphics.Paint.Style.FILL\n                        shader = android.graphics.RadialGradient(\n                            center.x + sinY * faceRadius * 0.5f,\n                            center.y - sinP * faceRadius * 0.5f,\n                            faceRadius * 1.1f,\n                            intArrayOf(\n                                android.graphics.Color.TRANSPARENT,\n                                android.graphics.Color.BLACK\n                            ),\n                            floatArrayOf(0.7f, 1f),\n                            android.graphics.Shader.TileMode.CLAMP\n                        )\n                        alpha = if (darkTheme) 40 else 20\n                    }\n                    drawPath(spherePath.asAndroidPath(), shadowPaint)\n                }\n\n                drawPath(\n                    path = spherePath,\n                    color = strokeColor,\n                    style = Stroke(width = 4.dp.toPx())\n                )\n\n                val smileRadius = faceRadius * 0.5f\n                val smileStartAngle = -340f\n                val smileSweepAngle = 140f\n                val smileOffsetY = faceRadius * 0.1f\n\n                val smilePath = Path()\n                for (i in 0..32) {\n                    val angle = Math.toRadians(smileStartAngle + (smileSweepAngle * i / 32.0))\n                    val x = cos(angle.toFloat()) * smileRadius\n                    val y = sin(angle.toFloat()) * smileRadius + smileOffsetY\n\n                    val rotated = rotate3D(Triple(x, y, 0f))\n                    val projected = project(rotated)\n\n                    if (i == 0) {\n                        smilePath.moveTo(projected.first, projected.second)\n                    } else {\n                        smilePath.lineTo(projected.first, projected.second)\n                    }\n                }\n\n                drawPath(\n                    path = smilePath,\n                    color = strokeColor,\n                    style = Stroke(\n                        width = 4.dp.toPx(),\n                        cap = StrokeCap.Round\n                    )\n                )\n\n                val eyeOffsetX = height * 0.15f\n                val eyeOffsetY = height * 0.1f\n                val eyeLength = height * 0.08f\n\n                for (xSign in listOf(-1f, 1f)) {\n                    val rotated = rotate3D(Triple(eyeOffsetX * xSign, -eyeOffsetY, 0f))\n                    val (eyeX, eyeY) = project(rotated)\n                    drawLine(\n                        color = strokeColor,\n                        start = Offset(eyeX, eyeY - eyeLength/2),\n                        end = Offset(eyeX, eyeY + eyeLength/2),\n                        strokeWidth = 4.dp.toPx(),\n                        cap = StrokeCap.Round\n                    )\n                }\n\n                drawContext.canvas.nativeCanvas.apply {\n                    val paint = android.graphics.Paint().apply {\n                        color = if (darkTheme) android.graphics.Color.WHITE else android.graphics.Color.BLACK\n                        textSize = 12.sp.toPx()\n                        textAlign = android.graphics.Paint.Align.RIGHT\n                        typeface = android.graphics.Typeface.create(\n                            \"SF Pro\",\n                            android.graphics.Typeface.NORMAL\n                        )\n                    }\n\n                    val pitch = orientation.pitch.toInt()\n                    val yaw = orientation.yaw.toInt()\n                    val text = \"Pitch: ${pitch}\u00b0 Yaw: ${yaw}\u00b0\"\n\n                    drawText(\n                        text,\n                        width - 8.dp.toPx(),\n                        height - 8.dp.toPx(),\n                        paint\n                    )\n                }\n            }\n        }\n    }\n}\n\n@Composable\nprivate fun AccelerationPlot() {\n    val acceleration by HeadTracking.acceleration.collectAsState()\n    val maxPoints = 100\n    val points = remember { mutableStateListOf<Pair<Float, Float>>() }\n    val darkTheme = isSystemInDarkTheme()\n\n    var maxAbs by remember { mutableFloatStateOf(1000f) }\n\n    LaunchedEffect(acceleration) {\n        points.add(Pair(acceleration.horizontal, acceleration.vertical))\n        if (points.size > maxPoints) {\n            points.removeAt(0)\n        }\n\n        val currentMax = points.maxOf { maxOf(abs(it.first), abs(it.second)) }\n        maxAbs = maxOf(currentMax * 1.2f, 1000f)\n    }\n\n    Card(\n        modifier = Modifier\n            .fillMaxWidth()\n            .height(300.dp),\n        colors = CardDefaults.cardColors(\n            containerColor = if (darkTheme) Color(0xFF1C1C1E) else Color.White\n        )\n    ) {\n        Box(\n            modifier = Modifier\n                .fillMaxSize()\n                .padding(16.dp)\n        ) {\n            Canvas(\n                modifier = Modifier.fillMaxSize()\n            ) {\n                val width = size.width\n                val height = size.height\n                val xScale = width / maxPoints\n                val yScale = (height - 40.dp.toPx()) / (maxAbs * 2)\n                val zeroY = height / 2\n\n                val gridColor = if (darkTheme) Color.White.copy(alpha = 0.1f) else Color.Black.copy(alpha = 0.1f)\n\n                for (i in 0..maxPoints step 10) {\n                    val x = i * xScale\n                    drawLine(\n                        color = gridColor,\n                        start = Offset(x, 0f),\n                        end = Offset(x, height),\n                        strokeWidth = 1.dp.toPx()\n                    )\n                }\n\n                val gridStep = maxAbs / 4\n                for (value in (-maxAbs.toInt()..maxAbs.toInt()) step gridStep.toInt()) {\n                    val y = zeroY - value * yScale\n                    drawLine(\n                        color = gridColor,\n                        start = Offset(0f, y),\n                        end = Offset(width, y),\n                        strokeWidth = 1.dp.toPx()\n                    )\n                }\n\n                drawLine(\n                    color = if (darkTheme) Color.White.copy(alpha = 0.3f) else Color.Black.copy(alpha = 0.3f),\n                    start = Offset(0f, zeroY),\n                    end = Offset(width, zeroY),\n                    strokeWidth = 1.5f.dp.toPx()\n                )\n\n                if (points.size > 1) {\n                    for (i in 0 until points.size - 1) {\n                        val x1 = i * xScale\n                        val x2 = (i + 1) * xScale\n\n                        drawLine(\n                            color = Color(0xFF007AFF),\n                            start = Offset(x1, zeroY - points[i].first * yScale),\n                            end = Offset(x2, zeroY - points[i + 1].first * yScale),\n                            strokeWidth = 2.dp.toPx()\n                        )\n\n                        drawLine(\n                            color = Color(0xFFFF3B30),\n                            start = Offset(x1, zeroY - points[i].second * yScale),\n                            end = Offset(x2, zeroY - points[i + 1].second * yScale),\n                            strokeWidth = 2.dp.toPx()\n                        )\n                    }\n                }\n\n                drawContext.canvas.nativeCanvas.apply {\n                    val paint = android.graphics.Paint().apply {\n                        color = if (darkTheme) android.graphics.Color.WHITE else android.graphics.Color.BLACK\n                        textSize = 12.sp.toPx()\n                        textAlign = android.graphics.Paint.Align.RIGHT\n                    }\n\n                    drawText(\"${maxAbs.toInt()}\", 30.dp.toPx(), 20.dp.toPx(), paint)\n                    drawText(\"0\", 30.dp.toPx(), height/2, paint)\n                    drawText(\"-${maxAbs.toInt()}\", 30.dp.toPx(), height - 10.dp.toPx(), paint)\n                }\n\n                val legendY = 15.dp.toPx()\n                val textOffsetY = legendY + 5.dp.toPx() / 2\n\n                drawCircle(Color(0xFF007AFF), 5.dp.toPx(), Offset(width - 150.dp.toPx(), legendY))\n                drawContext.canvas.nativeCanvas.apply {\n                    val paint = android.graphics.Paint().apply {\n                        color = if (darkTheme) android.graphics.Color.WHITE else android.graphics.Color.BLACK\n                        textSize = 12.sp.toPx()\n                        textAlign = android.graphics.Paint.Align.LEFT\n                    }\n                    drawText(\"Horizontal\", width - 140.dp.toPx(), textOffsetY, paint)\n                }\n\n                drawCircle(Color(0xFFFF3B30), 5.dp.toPx(), Offset(width - 70.dp.toPx(), legendY))\n                drawContext.canvas.nativeCanvas.apply {\n                    val paint = android.graphics.Paint().apply {\n                        color = if (darkTheme) android.graphics.Color.WHITE else android.graphics.Color.BLACK\n                        textSize = 12.sp.toPx()\n                        textAlign = android.graphics.Paint.Align.LEFT\n                    }\n                    drawText(\"Vertical\", width - 60.dp.toPx(), textOffsetY, paint)\n                }\n            }\n        }\n    }\n}\n\n@ExperimentalHazeMaterialsApi\n@RequiresApi(Build.VERSION_CODES.Q)\n@Preview\n@Composable\nfun HeadTrackingScreenPreview() {\n    HeadTrackingScreen(navController = NavController(LocalContext.current))\n}\n"
        },
        {
          "name": "TroubleshootingScreen.kt",
          "ext": ".kt",
          "size": 49627,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple's ecosystem\n *\n * Copyright (C) 2025 LibrePods contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\npackage me.kavishdevar.librepods.screens\n\nimport android.content.Intent\nimport android.widget.Toast\nimport androidx.activity.compose.rememberLauncherForActivityResult\nimport androidx.activity.result.contract.ActivityResultContracts\nimport androidx.compose.animation.AnimatedVisibility\nimport androidx.compose.animation.core.Spring\nimport androidx.compose.animation.core.animateFloatAsState\nimport androidx.compose.animation.core.spring\nimport androidx.compose.animation.core.tween\nimport androidx.compose.animation.expandVertically\nimport androidx.compose.animation.fadeIn\nimport androidx.compose.animation.fadeOut\nimport androidx.compose.animation.slideInVertically\nimport androidx.compose.animation.slideOutVertically\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.clickable\nimport androidx.compose.foundation.horizontalScroll\nimport androidx.compose.foundation.isSystemInDarkTheme\nimport androidx.compose.foundation.layout.Arrangement\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.Spacer\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.width\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.foundation.lazy.rememberLazyListState\nimport androidx.compose.foundation.rememberScrollState\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.foundation.verticalScroll\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.automirrored.filled.KeyboardArrowLeft\nimport androidx.compose.material.icons.filled.Clear\nimport androidx.compose.material.icons.filled.Delete\nimport androidx.compose.material.icons.filled.PlayArrow\nimport androidx.compose.material.icons.filled.Share\nimport androidx.compose.material3.AlertDialog\nimport androidx.compose.material3.Button\nimport androidx.compose.material3.ButtonDefaults\nimport androidx.compose.material3.CenterAlignedTopAppBar\nimport androidx.compose.material3.CircularProgressIndicator\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.IconButton\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.ModalBottomSheet\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TextButton\nimport androidx.compose.material3.TopAppBarDefaults\nimport androidx.compose.material3.rememberModalBottomSheetState\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.DisposableEffect\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.derivedStateOf\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableFloatStateOf\nimport androidx.compose.runtime.mutableIntStateOf\nimport androidx.compose.runtime.mutableStateListOf\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.rememberCoroutineScope\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.drawBehind\nimport androidx.compose.ui.draw.scale\nimport androidx.compose.ui.geometry.Offset\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.graphics.SolidColor\nimport androidx.compose.ui.graphics.graphicsLayer\nimport androidx.compose.ui.graphics.vector.ImageVector\nimport androidx.compose.ui.graphics.vector.path\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.res.painterResource\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.text.TextStyle\nimport androidx.compose.ui.text.font.Font\nimport androidx.compose.ui.text.font.FontFamily\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.text.style.TextAlign\nimport androidx.compose.ui.text.style.TextOverflow\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport androidx.core.content.FileProvider\nimport androidx.navigation.NavController\nimport dev.chrisbanes.haze.HazeEffectScope\nimport dev.chrisbanes.haze.HazeState\nimport dev.chrisbanes.haze.hazeEffect\nimport dev.chrisbanes.haze.hazeSource\nimport dev.chrisbanes.haze.materials.CupertinoMaterials\nimport dev.chrisbanes.haze.materials.ExperimentalHazeMaterialsApi\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.withContext\nimport me.kavishdevar.librepods.R\nimport me.kavishdevar.librepods.utils.LogCollector\nimport java.io.File\nimport java.text.SimpleDateFormat\nimport java.util.Date\nimport java.util.Locale\n\n@Composable\nfun CustomIconButton(\n    onClick: () -> Unit,\n    content: @Composable () -> Unit\n) {\n    Box(\n        modifier = Modifier\n            .clickable(onClick = onClick)\n            .padding(8.dp),\n        contentAlignment = Alignment.Center\n    ) {\n        content()\n    }\n}\n\n@OptIn(ExperimentalMaterial3Api::class, ExperimentalHazeMaterialsApi::class)\n@Composable\nfun TroubleshootingScreen(navController: NavController) {\n    val context = LocalContext.current\n    val scrollState = rememberScrollState()\n    val scrollBehavior = TopAppBarDefaults.pinnedScrollBehavior()\n    val hazeState = remember { HazeState() }\n    val coroutineScope = rememberCoroutineScope()\n\n    val logCollector = remember { LogCollector(context) }\n    val savedLogs = remember { mutableStateListOf<File>() }\n\n    var isCollectingLogs by remember { mutableStateOf(false) }\n    var showTroubleshootingSteps by remember { mutableStateOf(false) }\n    var currentStep by remember { mutableIntStateOf(0) }\n    var logContent by remember { mutableStateOf(\"\") }\n    var selectedLogFile by remember { mutableStateOf<File?>(null) }\n    var showDeleteDialog by remember { mutableStateOf(false) }\n    var showDeleteAllDialog by remember { mutableStateOf(false) }\n    var isLoadingLogContent by remember { mutableStateOf(false) }\n    var logContentLoaded by remember { mutableStateOf(false) }\n\n    LaunchedEffect(isCollectingLogs) {\n        while (isCollectingLogs) {\n            delay(250)\n            delay(250)\n        }\n    }\n\n    val sheetState = rememberModalBottomSheetState(skipPartiallyExpanded = false)\n    var showBottomSheet by remember { mutableStateOf(false) }\n\n    val sheetProgress by remember {\n        derivedStateOf {\n            if (!showBottomSheet) 0f else sheetState.targetValue.ordinal.toFloat() / 2f\n        }\n    }\n\n    val contentScaleFactor by remember {\n        derivedStateOf {\n            1.0f - (0.12f * sheetProgress)\n        }\n    }\n\n    val contentScale by animateFloatAsState(\n        targetValue = contentScaleFactor,\n        animationSpec = spring(\n            dampingRatio = Spring.DampingRatioMediumBouncy,\n            stiffness = Spring.StiffnessMedium\n        ),\n        label = \"contentScale\"\n    )\n\n    val backgroundColor = if (isSystemInDarkTheme()) Color(0xFF1C1C1E) else Color(0xFFFFFFFF)\n    val textColor = if (isSystemInDarkTheme()) Color.White else Color.Black\n    val accentColor = if (isSystemInDarkTheme()) Color(0xFF007AFF) else Color(0xFF3C6DF5)\n    val buttonBgColor = if (isSystemInDarkTheme()) Color(0xFF333333) else Color(0xFFDDDDDD)\n\n    var instructionText by remember { mutableStateOf(\"\") }\n    var isDarkTheme = isSystemInDarkTheme()\n    var mDensity by remember { mutableFloatStateOf(0f) }\n\n    LaunchedEffect(Unit) {\n        withContext(Dispatchers.IO) {\n            val logsDir = File(context.filesDir, \"logs\")\n            if (logsDir.exists()) {\n                savedLogs.clear()\n                savedLogs.addAll(logsDir.listFiles()?.filter { it.name.endsWith(\".txt\") }\n                    ?.sortedByDescending { it.lastModified() } ?: emptyList())\n            }\n        }\n    }\n\n    val saveLauncher = rememberLauncherForActivityResult(\n        contract = ActivityResultContracts.CreateDocument(\"text/plain\")\n    ) { uri ->\n        if (uri != null) {\n            coroutineScope.launch(Dispatchers.IO) {\n                try {\n                    context.contentResolver.openOutputStream(uri)?.use { outputStream ->\n                        outputStream.write(logContent.toByteArray())\n                    }\n                    withContext(Dispatchers.Main) {\n                        Toast.makeText(context, \"Log saved successfully\", Toast.LENGTH_SHORT).show()\n                    }\n                } catch (e: Exception) {\n                    withContext(Dispatchers.Main) {\n                        Toast.makeText(\n                            context,\n                            \"Failed to save log: ${e.localizedMessage}\",\n                            Toast.LENGTH_SHORT\n                        ).show()\n                    }\n                }\n            }\n        }\n    }\n\n    LaunchedEffect(currentStep) {\n        instructionText = when (currentStep) {\n            0 -> \"First, let's ensure Xposed module is properly configured. Tap the button below to check Xposed scope settings.\"\n            1 -> \"Please put your AirPods in the case and close it, so they disconnect completely.\"\n            2 -> \"Preparing to collect logs... Please wait.\"\n            3 -> \"Now, open the AirPods case and connect your AirPods. Logs are being collected. Connection will be detected automatically, or you can manually stop logging when you're done.\"\n            4 -> \"Log collection complete! You can now save or share the logs.\"\n            else -> \"\"\n        }\n    }\n\n    fun openLogBottomSheet(file: File) {\n        selectedLogFile = file\n        logContent = \"\"\n        isLoadingLogContent = false\n        logContentLoaded = false\n        showBottomSheet = true\n    }\n\n    Box(\n        modifier = Modifier.fillMaxSize()\n    ) {\n        Scaffold(\n            modifier = Modifier\n                .fillMaxSize()\n                .graphicsLayer {\n                    scaleX = contentScale\n                    scaleY = contentScale\n                    transformOrigin = androidx.compose.ui.graphics.TransformOrigin(0.5f, 0.3f)\n                },\n            topBar = {\n                CenterAlignedTopAppBar(\n                    modifier = Modifier.hazeEffect(\n                        state = hazeState,\n                        style = CupertinoMaterials.thick(),\n                        block = fun HazeEffectScope.() {\n                            alpha = if (scrollState.value > 60.dp.value * mDensity) 1f else 0f\n                        })\n                        .drawBehind {\n                            mDensity = density\n                            val strokeWidth = 0.7.dp.value * density\n                            val y = size.height - strokeWidth / 2\n                            if (scrollState.value > 60.dp.value * density) {\n                                drawLine(\n                                    if (isDarkTheme) Color.DarkGray else Color.LightGray,\n                                    Offset(0f, y),\n                                    Offset(size.width, y),\n                                    strokeWidth\n                                )\n                            }\n                        },\n                    title = {\n                        Text(\n                            text = stringResource(R.string.troubleshooting),\n                            fontFamily = FontFamily(Font(R.font.sf_pro)),\n                            maxLines = 1,\n                            overflow = TextOverflow.Ellipsis\n                        )\n                    },\n                    navigationIcon = {\n                        TextButton(\n                            onClick = {\n                                navController.popBackStack()\n                            },\n                            shape = RoundedCornerShape(8.dp),\n                        ) {\n                            Icon(\n                                Icons.AutoMirrored.Filled.KeyboardArrowLeft,\n                                contentDescription = \"Back\",\n                                tint = accentColor,\n                                modifier = Modifier.scale(1.5f)\n                            )\n                        }\n                    },\n                    colors = TopAppBarDefaults.centerAlignedTopAppBarColors(\n                        containerColor = Color.Transparent\n                    ),\n                    scrollBehavior = scrollBehavior\n                )\n            },\n            containerColor = if (isSystemInDarkTheme()) Color(0xFF000000) else Color(0xFFF2F2F7),\n        ) { paddingValues ->\n            Column(\n                modifier = Modifier\n                    .fillMaxSize()\n                    .padding(paddingValues)\n                    .padding(horizontal = 16.dp)\n                    .verticalScroll(scrollState)\n                    .hazeSource(state = hazeState)\n            ) {\n                Spacer(modifier = Modifier.height(8.dp))\n\n                Text(\n                    text = stringResource(R.string.saved_logs).uppercase(),\n                    style = TextStyle(\n                        fontSize = 14.sp,\n                        fontWeight = FontWeight.Light,\n                        color = textColor.copy(alpha = 0.6f),\n                        fontFamily = FontFamily(Font(R.font.sf_pro))\n                    ),\n                    modifier = Modifier.padding(8.dp, bottom = 2.dp, top = 8.dp)\n                )\n\n                Spacer(modifier = Modifier.height(2.dp))\n\n                if (savedLogs.isEmpty()) {\n                    Column(\n                        modifier = Modifier\n                            .fillMaxWidth()\n                            .background(\n                                backgroundColor,\n                                RoundedCornerShape(14.dp)\n                            )\n                            .padding(16.dp),\n                        horizontalAlignment = Alignment.CenterHorizontally\n                    ) {\n                        Text(\n                            text = stringResource(R.string.no_logs_found),\n                            fontSize = 16.sp,\n                            color = textColor\n                        )\n                    }\n                } else {\n                    Column(\n                        modifier = Modifier\n                            .fillMaxWidth()\n                            .background(\n                                backgroundColor,\n                                RoundedCornerShape(14.dp)\n                            )\n                            .padding(horizontal = 16.dp, vertical = 8.dp)\n                    ) {\n                        Row(\n                            modifier = Modifier\n                                .fillMaxWidth()\n                                .padding(vertical = 8.dp),\n                            horizontalArrangement = Arrangement.SpaceBetween,\n                            verticalAlignment = Alignment.CenterVertically\n                        ) {\n                            Text(\n                                text = \"Total Logs: ${savedLogs.size}\",\n                                fontSize = 16.sp,\n                                fontWeight = FontWeight.Medium,\n                                color = textColor\n                            )\n\n                            if (savedLogs.size > 1) {\n                                TextButton(\n                                    onClick = { showDeleteAllDialog = true },\n                                    colors = ButtonDefaults.textButtonColors(\n                                        contentColor = MaterialTheme.colorScheme.error\n                                    )\n                                ) {\n                                    Text(\"Delete All\")\n                                }\n                            }\n                        }\n\n                        savedLogs.forEach { logFile ->\n                            Row(\n                                modifier = Modifier\n                                    .fillMaxWidth()\n                                    .padding(vertical = 8.dp)\n                                    .clickable {\n                                        openLogBottomSheet(logFile)\n                                    },\n                                verticalAlignment = Alignment.CenterVertically\n                            ) {\n                                Column(modifier = Modifier.weight(1f)) {\n                                    Text(\n                                        text = logFile.name,\n                                        fontSize = 16.sp,\n                                        color = textColor,\n                                        maxLines = 1,\n                                        overflow = TextOverflow.Ellipsis\n                                    )\n\n                                    Text(\n                                        text = SimpleDateFormat(\"MMM dd, yyyy HH:mm\", Locale.US)\n                                            .format(Date(logFile.lastModified())),\n                                        fontSize = 14.sp,\n                                        color = textColor.copy(alpha = 0.6f)\n                                    )\n                                }\n\n                                CustomIconButton(\n                                    onClick = {\n                                        selectedLogFile = logFile\n                                        showDeleteDialog = true\n                                    }\n                                ) {\n                                    Icon(\n                                        Icons.Default.Delete,\n                                        contentDescription = \"Delete\",\n                                        tint = MaterialTheme.colorScheme.error\n                                    )\n                                }\n                            }\n                        }\n                    }\n                }\n\n                Spacer(modifier = Modifier.height(16.dp))\n\n                AnimatedVisibility(\n                    visible = !showTroubleshootingSteps,\n                    enter = fadeIn(animationSpec = tween(300)),\n                    exit = fadeOut(animationSpec = tween(300))\n                ) {\n                    Button(\n                        onClick = { showTroubleshootingSteps = true },\n                        modifier = Modifier.fillMaxWidth(),\n                        shape = RoundedCornerShape(10.dp),\n                        colors = ButtonDefaults.buttonColors(\n                            containerColor = buttonBgColor,\n                            contentColor = textColor\n                        ),\n                        enabled = !isCollectingLogs\n                    ) {\n                        Text(stringResource(R.string.collect_logs))\n                    }\n                }\n\n                AnimatedVisibility(\n                    visible = showTroubleshootingSteps,\n                    enter = fadeIn(animationSpec = tween(300)) +\n                        slideInVertically(animationSpec = tween(300)) { it / 2 },\n                    exit = fadeOut(animationSpec = tween(300)) +\n                        slideOutVertically(animationSpec = tween(300)) { it / 2 }\n                ) {\n                    Column {\n                        Spacer(modifier = Modifier.height(16.dp))\n\n                        Text(\n                            text = \"TROUBLESHOOTING STEPS\".uppercase(),\n                            style = TextStyle(\n                                fontSize = 14.sp,\n                                fontWeight = FontWeight.Light,\n                                color = textColor.copy(alpha = 0.6f),\n                                fontFamily = FontFamily(Font(R.font.sf_pro))\n                            ),\n                            modifier = Modifier.padding(8.dp, bottom = 2.dp, top = 8.dp)\n                        )\n\n                        Spacer(modifier = Modifier.height(2.dp))\n\n                        Column(\n                            modifier = Modifier\n                                .fillMaxWidth()\n                                .background(\n                                    backgroundColor,\n                                    RoundedCornerShape(14.dp)\n                                )\n                                .padding(16.dp)\n                        ) {\n                            val textAlpha = animateFloatAsState(\n                                targetValue = 1f,\n                                animationSpec = tween(durationMillis = 300),\n                                label = \"textAlpha\"\n                            )\n\n                            Text(\n                                text = instructionText,\n                                fontSize = 16.sp,\n                                color = textColor.copy(alpha = textAlpha.value),\n                                lineHeight = 22.sp\n                            )\n\n                            Spacer(modifier = Modifier.height(16.dp))\n\n                            when (currentStep) {\n                                0 -> {\n                                    Button(\n                                        onClick = {\n                                            coroutineScope.launch {\n                                                logCollector.openXposedSettings(context)\n                                                delay(2000)\n                                                currentStep = 1\n                                            }\n                                        },\n                                        modifier = Modifier.fillMaxWidth(),\n                                        shape = RoundedCornerShape(10.dp),\n                                        colors = ButtonDefaults.buttonColors(\n                                            containerColor = buttonBgColor,\n                                            contentColor = textColor\n                                        )\n                                    ) {\n                                        Text(\"Open Xposed Settings\")\n                                    }\n                                }\n\n                                1 -> {\n                                    Button(\n                                        onClick = {\n                                            currentStep = 2\n                                            isCollectingLogs = true\n\n                                            coroutineScope.launch {\n                                                try {\n                                                    logCollector.clearLogs()\n\n                                                    logCollector.addLogMarker(LogCollector.LogMarkerType.START)\n\n                                                    logCollector.killBluetoothService()\n\n                                                    withContext(Dispatchers.Main) {\n                                                        delay(500)\n                                                        currentStep = 3\n                                                    }\n\n                                                    val timestamp = SimpleDateFormat(\n                                                        \"yyyyMMdd_HHmmss\",\n                                                        Locale.US\n                                                    ).format(Date())\n\n                                                    logContent =\n                                                        logCollector.startLogCollection(\n                                                            listener = { /* Removed live log display */ },\n                                                            connectionDetectedCallback = {\n                                                                launch {\n                                                                    delay(5000)\n                                                                    withContext(Dispatchers.Main) {\n                                                                        if (isCollectingLogs) {\n                                                                            logCollector.stopLogCollection()\n                                                                            currentStep = 4\n                                                                            isCollectingLogs =\n                                                                                false\n                                                                        }\n                                                                    }\n                                                                }\n                                                            }\n                                                        )\n\n                                                    val logFile =\n                                                        logCollector.saveLogToInternalStorage(\n                                                            \"airpods_log_$timestamp.txt\",\n                                                            logContent\n                                                        )\n                                                    logFile?.let {\n                                                        withContext(Dispatchers.Main) {\n                                                            savedLogs.add(0, it)\n                                                            selectedLogFile = it\n                                                            Toast.makeText(\n                                                                context,\n                                                                \"Log saved: ${it.name}\",\n                                                                Toast.LENGTH_SHORT\n                                                            ).show()\n                                                        }\n                                                    }\n                                                } catch (e: Exception) {\n                                                    withContext(Dispatchers.Main) {\n                                                        Toast.makeText(\n                                                            context,\n                                                            \"Error collecting logs: ${e.message}\",\n                                                            Toast.LENGTH_SHORT\n                                                        ).show()\n                                                        isCollectingLogs = false\n                                                        currentStep = 0\n                                                    }\n                                                }\n                                            }\n                                        },\n                                        modifier = Modifier.fillMaxWidth(),\n                                        shape = RoundedCornerShape(10.dp),\n                                        colors = ButtonDefaults.buttonColors(\n                                            containerColor = buttonBgColor,\n                                            contentColor = textColor\n                                        )\n                                    ) {\n                                        Text(\"Continue\")\n                                    }\n                                }\n\n                                2, 3 -> {\n                                    Column(\n                                        modifier = Modifier.fillMaxWidth(),\n                                        horizontalAlignment = Alignment.CenterHorizontally\n                                    ) {\n                                        CircularProgressIndicator(\n                                            color = accentColor\n                                        )\n\n                                        Spacer(modifier = Modifier.height(8.dp))\n\n                                        Text(\n                                            text = if (currentStep == 2) \"Preparing...\" else \"Collecting logs...\",\n                                            fontSize = 14.sp,\n                                            color = textColor\n                                        )\n\n                                        if (currentStep == 3) {\n                                            Spacer(modifier = Modifier.height(16.dp))\n\n                                            Button(\n                                                onClick = {\n                                                    coroutineScope.launch {\n                                                        logCollector.addLogMarker(\n                                                            LogCollector.LogMarkerType.CUSTOM,\n                                                            \"Manual stop requested by user\"\n                                                        )\n                                                        delay(1000)\n                                                        logCollector.stopLogCollection()\n                                                        delay(500)\n\n                                                        withContext(Dispatchers.Main) {\n                                                            currentStep = 4\n                                                            isCollectingLogs = false\n                                                            Toast.makeText(\n                                                                context,\n                                                                \"Log collection stopped\",\n                                                                Toast.LENGTH_SHORT\n                                                            ).show()\n                                                        }\n                                                    }\n                                                },\n                                                shape = RoundedCornerShape(10.dp),\n                                                colors = ButtonDefaults.buttonColors(\n                                                    containerColor = buttonBgColor,\n                                                    contentColor = textColor\n                                                ),\n                                                modifier = Modifier\n                                                    .fillMaxWidth()\n                                            ) {\n                                                Text(\"Stop Collection\")\n                                            }\n                                        }\n                                    }\n                                }\n\n                                4 -> {\n                                    Row(\n                                        modifier = Modifier.fillMaxWidth(),\n                                        horizontalArrangement = Arrangement.Center\n                                    ) {\n                                        Button(\n                                            onClick = {\n                                                selectedLogFile?.let { file ->\n                                                    val fileUri = FileProvider.getUriForFile(\n                                                        context,\n                                                        \"${context.packageName}.provider\",\n                                                        file\n                                                    )\n                                                    val shareIntent =\n                                                        Intent(Intent.ACTION_SEND).apply {\n                                                            type = \"text/plain\"\n                                                            putExtra(\n                                                                Intent.EXTRA_STREAM,\n                                                                fileUri\n                                                            )\n                                                            addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)\n                                                        }\n                                                    context.startActivity(\n                                                        Intent.createChooser(\n                                                            shareIntent,\n                                                            \"Share log file\"\n                                                        )\n                                                    )\n                                                }\n                                            },\n                                            shape = RoundedCornerShape(10.dp),\n                                            colors = ButtonDefaults.buttonColors(\n                                                containerColor = buttonBgColor,\n                                                contentColor = textColor\n                                            ),\n                                            modifier = Modifier.width(150.dp)\n                                        ) {\n                                            Icon(\n                                                imageVector = Icons.Default.Share,\n                                                contentDescription = \"Share\"\n                                            )\n                                            Spacer(modifier = Modifier.width(8.dp))\n                                            Text(\"Share\")\n                                        }\n\n                                        Spacer(modifier = Modifier.width(16.dp))\n\n                                        Button(\n                                            onClick = {\n                                                selectedLogFile?.let { file ->\n                                                    saveLauncher.launch(\"airpods_log_${System.currentTimeMillis()}.txt\")\n                                                }\n                                            },\n                                            shape = RoundedCornerShape(10.dp),\n                                            colors = ButtonDefaults.buttonColors(\n                                                containerColor = buttonBgColor,\n                                                contentColor = textColor\n                                            ),\n                                            modifier = Modifier.width(150.dp)\n                                        ) {\n                                            Icon(\n                                                painter = painterResource(id = R.drawable.ic_save),\n                                                contentDescription = \"Save\"\n                                            )\n                                            Spacer(modifier = Modifier.width(8.dp))\n                                            Text(\"Save\")\n                                        }\n                                    }\n\n                                    Spacer(modifier = Modifier.height(16.dp))\n\n                                    Button(\n                                        onClick = {\n                                            currentStep = 0\n                                            showTroubleshootingSteps = false\n                                        },\n                                        modifier = Modifier.fillMaxWidth(),\n                                        shape = RoundedCornerShape(10.dp),\n                                        colors = ButtonDefaults.buttonColors(\n                                            containerColor = buttonBgColor,\n                                            contentColor = textColor\n                                        )\n                                    ) {\n                                        Text(\"Done\")\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (showDeleteDialog && selectedLogFile != null) {\n                    AlertDialog(\n                        onDismissRequest = { showDeleteDialog = false },\n                        title = { Text(\"Delete Log File\") },\n                        text = {\n                            Text(\"Are you sure you want to delete this log file? This action cannot be undone.\")\n                        },\n                        confirmButton = {\n                            TextButton(\n                                onClick = {\n                                    selectedLogFile?.let { file ->\n                                        if (file.delete()) {\n                                            savedLogs.remove(file)\n                                            Toast.makeText(\n                                                context,\n                                                \"Log file deleted\",\n                                                Toast.LENGTH_SHORT\n                                            )\n                                                .show()\n                                        } else {\n                                            Toast.makeText(\n                                                context,\n                                                \"Failed to delete log file\",\n                                                Toast.LENGTH_SHORT\n                                            ).show()\n                                        }\n                                    }\n                                    showDeleteDialog = false\n                                }\n                            ) {\n                                Text(\"Delete\", color = MaterialTheme.colorScheme.error)\n                            }\n                        },\n                        dismissButton = {\n                            TextButton(onClick = { showDeleteDialog = false }) {\n                                Text(\"Cancel\")\n                            }\n                        }\n                    )\n                }\n\n                if (showDeleteAllDialog) {\n                    AlertDialog(\n                        onDismissRequest = { showDeleteAllDialog = false },\n                        title = { Text(\"Delete All Logs\") },\n                        text = {\n                            Text(\"Are you sure you want to delete all log files? This action cannot be undone and will remove ${savedLogs.size} log files.\")\n                        },\n                        confirmButton = {\n                            TextButton(\n                                onClick = {\n         "
        },
        {
          "name": "DebugScreen.kt",
          "ext": ".kt",
          "size": 31583,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n *\n * Copyright (C) 2025 LibrePods contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\n@file:OptIn(ExperimentalHazeMaterialsApi::class, ExperimentalEncodingApi::class)\n\npackage me.kavishdevar.librepods.screens\n\nimport android.annotation.SuppressLint\nimport android.content.ClipData\nimport android.content.ClipboardManager\nimport android.content.Context\nimport android.os.Build\nimport android.widget.Toast\nimport androidx.annotation.RequiresApi\nimport androidx.compose.foundation.ExperimentalFoundationApi\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.clickable\nimport androidx.compose.foundation.combinedClickable\nimport androidx.compose.foundation.isSystemInDarkTheme\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.ExperimentalLayoutApi\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.Spacer\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.navigationBarsPadding\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.size\nimport androidx.compose.foundation.layout.width\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.rememberLazyListState\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.automirrored.filled.KeyboardArrowLeft\nimport androidx.compose.material.icons.automirrored.filled.KeyboardArrowRight\nimport androidx.compose.material.icons.filled.Check\nimport androidx.compose.material.icons.filled.Delete\nimport androidx.compose.material.icons.filled.MoreVert\nimport androidx.compose.material.icons.filled.Send\nimport androidx.compose.material3.Card\nimport androidx.compose.material3.CardDefaults\nimport androidx.compose.material3.CenterAlignedTopAppBar\nimport androidx.compose.material3.DropdownMenu\nimport androidx.compose.material3.DropdownMenuItem\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.HorizontalDivider\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.IconButton\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TextButton\nimport androidx.compose.material3.TextField\nimport androidx.compose.material3.TextFieldDefaults\nimport androidx.compose.material3.TopAppBarDefaults\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.collectAsState\nimport androidx.compose.runtime.derivedStateOf\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.rememberCoroutineScope\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.scale\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.platform.LocalFocusManager\nimport androidx.compose.ui.text.TextStyle\nimport androidx.compose.ui.text.font.Font\nimport androidx.compose.ui.text.font.FontFamily\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.text.input.TextFieldValue\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport androidx.navigation.NavController\nimport dev.chrisbanes.haze.HazeEffectScope\nimport dev.chrisbanes.haze.HazeState\nimport dev.chrisbanes.haze.hazeEffect\nimport dev.chrisbanes.haze.hazeSource\nimport dev.chrisbanes.haze.materials.CupertinoMaterials\nimport dev.chrisbanes.haze.materials.ExperimentalHazeMaterialsApi\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.launch\nimport me.kavishdevar.librepods.R\nimport me.kavishdevar.librepods.constants.BatteryStatus\nimport me.kavishdevar.librepods.constants.isHeadTrackingData\nimport me.kavishdevar.librepods.services.ServiceManager\nimport kotlin.io.encoding.ExperimentalEncodingApi\n\ndata class PacketInfo(\n    val type: String,\n    val description: String,\n    val rawData: String,\n    val parsedData: Map<String, String> = emptyMap(),\n    val isUnknown: Boolean = false\n)\n\nfun parsePacket(message: String): PacketInfo {\n    val rawData = if (message.startsWith(\"Sent\")) message.substring(5) else message.substring(9)\n    val bytes = rawData.split(\" \").mapNotNull {\n        it.takeIf { it.isNotEmpty() }?.toIntOrNull(16)?.toByte()\n    }.toByteArray()\n\n    val airPodsService = ServiceManager.getService()\n    if (airPodsService != null) {\n        return when {\n            message.startsWith(\"Sent\") -> parseOutgoingPacket(bytes, rawData)\n            airPodsService.batteryNotification.isBatteryData(bytes) -> {\n                val batteryInfo = mutableMapOf<String, String>()\n                airPodsService.batteryNotification.setBattery(bytes)\n                val batteries = airPodsService.batteryNotification.getBattery()\n                val batteryInfoString = batteries.joinToString(\", \") { battery ->\n                    \"${battery.getComponentName() ?: \"Unknown\"}: ${battery.level}% ${if (battery.status == BatteryStatus.CHARGING) \"(Charging)\" else \"\"}\"\n                }\n                batteries.forEach { battery ->\n                    if (battery.status != BatteryStatus.DISCONNECTED) {\n                        batteryInfo[battery.getComponentName() ?: \"Unknown\"] =\n                            \"${battery.level}% ${if (battery.status == BatteryStatus.CHARGING) \"(Charging)\" else \"\"}\"\n                    }\n                }\n\n                PacketInfo(\n                    \"Battery\",\n                    batteryInfoString,\n                    rawData,\n                    batteryInfo\n                )\n            }\n            airPodsService.ancNotification.isANCData(bytes) -> {\n                airPodsService.ancNotification.setStatus(bytes)\n                val mode = when (airPodsService.ancNotification.status) {\n                    1 -> \"Off\"\n                    2 -> \"Noise Cancellation\"\n                    3 -> \"Transparency\"\n                    4 -> \"Adaptive\"\n                    else -> \"Unknown\"\n                }\n\n                PacketInfo(\n                    \"Noise Control\",\n                    \"Mode: $mode\",\n                    rawData,\n                    mapOf(\"Mode\" to mode)\n                )\n            }\n            airPodsService.earDetectionNotification.isEarDetectionData(bytes) -> {\n                airPodsService.earDetectionNotification.setStatus(bytes)\n                val status = airPodsService.earDetectionNotification.status\n                val primaryStatus = if (status[0] == 0.toByte()) \"In ear\" else \"Out of ear\"\n                val secondaryStatus = if (status[1] == 0.toByte()) \"In ear\" else \"Out of ear\"\n\n                PacketInfo(\n                    \"Ear Detection\",\n                    \"Primary: $primaryStatus, Secondary: $secondaryStatus\",\n                    rawData,\n                    mapOf(\"Primary\" to primaryStatus, \"Secondary\" to secondaryStatus)\n                )\n            }\n            airPodsService.conversationAwarenessNotification.isConversationalAwarenessData(bytes) -> {\n                airPodsService.conversationAwarenessNotification.setData(bytes)\n                val statusMap = mapOf(\n                    1.toByte() to \"Started speaking\",\n                    2.toByte() to \"Speaking\",\n                    8.toByte() to \"Stopped speaking\",\n                    9.toByte() to \"Not speaking\"\n                )\n                val status = statusMap[airPodsService.conversationAwarenessNotification.status] ?:\n                    \"Unknown (${airPodsService.conversationAwarenessNotification.status})\"\n\n                PacketInfo(\n                    \"Conversation Awareness\",\n                    \"Status: $status\",\n                    rawData,\n                    mapOf(\"Status\" to status)\n                )\n            }\n            isHeadTrackingData(bytes) -> {\n                val horizontal = if (bytes.size >= 53)\n                    \"${bytes[51].toInt() and 0xFF or (bytes[52].toInt() shl 8)}\" else \"Unknown\"\n                val vertical = if (bytes.size >= 55)\n                    \"${bytes[53].toInt() and 0xFF or (bytes[54].toInt() shl 8)}\" else \"Unknown\"\n\n                PacketInfo(\n                    \"Head Tracking\",\n                    \"Position data\",\n                    rawData,\n                    mapOf(\"Horizontal\" to horizontal, \"Vertical\" to vertical)\n                )\n            }\n            else -> PacketInfo(\"Unknown\", \"Unknown packet format\", rawData, emptyMap(), true)\n        }\n    } else {\n        return if (message.startsWith(\"Sent\")) {\n            parseOutgoingPacket(bytes, rawData)\n        } else {\n            PacketInfo(\"Unknown\", \"Unknown packet format\", rawData, emptyMap(), true)\n        }\n    }\n}\n\nfun parseOutgoingPacket(bytes: ByteArray, rawData: String): PacketInfo {\n    if (bytes.size < 7) {\n        return PacketInfo(\"Unknown\", \"Unknown outgoing packet\", rawData, emptyMap(), true)\n    }\n\n    return when {\n        bytes.size >= 16 &&\n        bytes[0] == 0x00.toByte() &&\n        bytes[1] == 0x00.toByte() &&\n        bytes[2] == 0x04.toByte() &&\n        bytes[3] == 0x00.toByte() -> {\n            PacketInfo(\"Handshake\", \"Initial handshake with AirPods\", rawData)\n        }\n\n        bytes.size >= 11 &&\n        bytes[0] == 0x04.toByte() &&\n        bytes[1] == 0x00.toByte() &&\n        bytes[2] == 0x04.toByte() &&\n        bytes[3] == 0x00.toByte() &&\n        bytes[4] == 0x09.toByte() &&\n        bytes[5] == 0x00.toByte() &&\n        bytes[6] == 0x0d.toByte() -> {\n            val mode = when (bytes[7].toInt()) {\n                1 -> \"Off\"\n                2 -> \"Noise Cancellation\"\n                3 -> \"Transparency\"\n                4 -> \"Adaptive\"\n                else -> \"Unknown\"\n            }\n            PacketInfo(\"Noise Control\", \"Set mode to $mode\", rawData, mapOf(\"Mode\" to mode))\n        }\n\n        bytes.size >= 11 &&\n        bytes[0] == 0x04.toByte() &&\n        bytes[1] == 0x00.toByte() &&\n        bytes[2] == 0x04.toByte() &&\n        bytes[3] == 0x00.toByte() &&\n        bytes[4] == 0x09.toByte() &&\n        bytes[5] == 0x00.toByte() &&\n        bytes[6] == 0x28.toByte() -> {\n            val mode = if (bytes[7].toInt() == 1) \"On\" else \"Off\"\n            PacketInfo(\"Conversation Awareness\", \"Set mode to $mode\", rawData, mapOf(\"Mode\" to mode))\n        }\n\n        bytes.size > 10 &&\n        bytes[0] == 0x04.toByte() &&\n        bytes[1] == 0x00.toByte() &&\n        bytes[2] == 0x04.toByte() &&\n        bytes[3] == 0x00.toByte() &&\n        bytes[4] == 0x17.toByte() -> {\n            val action = if (bytes.joinToString(\" \") { \"%02X\".format(it) }.contains(\"A1 02\")) \"Start\" else \"Stop\"\n            PacketInfo(\"Head Tracking\", \"$action head tracking\", rawData)\n        }\n\n        bytes.size >= 11 &&\n        bytes[0] == 0x04.toByte() &&\n        bytes[1] == 0x00.toByte() &&\n        bytes[2] == 0x04.toByte() &&\n        bytes[3] == 0x00.toByte() &&\n        bytes[4] == 0x09.toByte() &&\n        bytes[5] == 0x00.toByte() &&\n        bytes[6] == 0x1A.toByte() -> {\n            PacketInfo(\"Long Press Config\", \"Change long press modes\", rawData)\n        }\n\n        bytes.size >= 9 &&\n        bytes[0] == 0x04.toByte() &&\n        bytes[1] == 0x00.toByte() &&\n        bytes[2] == 0x04.toByte() &&\n        bytes[3] == 0x00.toByte() &&\n        bytes[4] == 0x4d.toByte() -> {\n            PacketInfo(\"Feature Request\", \"Set specific features\", rawData)\n        }\n\n        bytes.size >= 9 &&\n        bytes[0] == 0x04.toByte() &&\n        bytes[1] == 0x00.toByte() &&\n        bytes[2] == 0x04.toByte() &&\n        bytes[3] == 0x00.toByte() &&\n        bytes[4] == 0x0f.toByte() -> {\n            PacketInfo(\"Notifications\", \"Request notifications\", rawData)\n        }\n\n        else -> PacketInfo(\"Unknown\", \"Unknown outgoing packet\", rawData, emptyMap(), true)\n    }\n}\n\n@Composable\nfun IOSCheckbox(\n    checked: Boolean,\n    onCheckedChange: (Boolean) -> Unit,\n    modifier: Modifier = Modifier\n) {\n    Box(\n        modifier = modifier\n            .size(24.dp)\n            .clickable { onCheckedChange(!checked) },\n        contentAlignment = Alignment.Center\n    ) {\n        if (checked) {\n            Icon(\n                imageVector = Icons.Default.Check,\n                contentDescription = \"Checked\",\n                tint = if (isSystemInDarkTheme()) Color(0xFF007AFF) else Color(0xFF3C6DF5),\n                modifier = Modifier.size(20.dp)\n            )\n        }\n    }\n}\n\n@RequiresApi(Build.VERSION_CODES.Q)\n@OptIn(ExperimentalMaterial3Api::class, ExperimentalLayoutApi::class, ExperimentalFoundationApi::class)\n@SuppressLint(\"UnusedMaterial3ScaffoldPaddingParameter\", \"UnspecifiedRegisterReceiverFlag\")\n@Composable\nfun DebugScreen(navController: NavController) {\n    val hazeState = remember { HazeState() }\n    val context = LocalContext.current\n    val listState = rememberLazyListState()\n    val scrollOffset by remember { derivedStateOf { listState.firstVisibleItemScrollOffset } }\n    val focusManager = LocalFocusManager.current\n    val coroutineScope = rememberCoroutineScope()\n\n    val showMenu = remember { mutableStateOf(false) }\n\n    val airPodsService = remember { ServiceManager.getService() }\n    val packetLogs = airPodsService?.packetLogsFlow?.collectAsState(emptySet())?.value ?: emptySet()\n    val shouldScrollToBottom = remember { mutableStateOf(true) }\n\n    val refreshTrigger = remember { mutableStateOf(0) }\n    LaunchedEffect(refreshTrigger.value) {\n        while(true) {\n            delay(1000)\n            refreshTrigger.value = refreshTrigger.value + 1\n        }\n    }\n\n    val expandedItems = remember { mutableStateOf(setOf<Int>()) }\n\n    fun copyToClipboard(text: String) {\n        val clipboard = context.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager\n        val clip = ClipData.newPlainText(\"Packet Data\", text)\n        clipboard.setPrimaryClip(clip)\n        Toast.makeText(context, \"Packet copied to clipboard\", Toast.LENGTH_SHORT).show()\n    }\n\n    LaunchedEffect(packetLogs.size, refreshTrigger.value) {\n        if (shouldScrollToBottom.value && packetLogs.isNotEmpty()) {\n            listState.animateScrollToItem(packetLogs.size - 1)\n        }\n    }\n\n    Scaffold(\n        topBar = {\n            CenterAlignedTopAppBar(\n                title = { Text(\"Debug\") },\n                navigationIcon = {\n                    TextButton(\n                        onClick = { navController.popBackStack() },\n                        shape = RoundedCornerShape(8.dp),\n                    ) {\n                        val sharedPreferences = context.getSharedPreferences(\"settings\", Context.MODE_PRIVATE)\n                        Icon(\n                            Icons.AutoMirrored.Filled.KeyboardArrowLeft,\n                            contentDescription = \"Back\",\n                            tint = if (isSystemInDarkTheme()) Color(0xFF007AFF) else Color(0xFF3C6DF5),\n                            modifier = Modifier.scale(1.5f)\n                        )\n                        Text(\n                            sharedPreferences.getString(\"name\", \"AirPods\")!!,\n                            style = TextStyle(\n                                fontSize = 18.sp,\n                                fontWeight = FontWeight.Medium,\n                                color = if (isSystemInDarkTheme()) Color(0xFF007AFF) else Color(0xFF3C6DF5),\n                                fontFamily = FontFamily(Font(R.font.sf_pro))\n                            ),\n                        )\n                    }\n                },\n                actions = {\n                    Box {\n                        IconButton(onClick = { showMenu.value = true }) {\n                            Icon(\n                                imageVector = Icons.Default.MoreVert,\n                                contentDescription = \"More Options\",\n                                tint = if (isSystemInDarkTheme()) Color.White else Color.Black\n                            )\n                        }\n\n                        DropdownMenu(\n                            expanded = showMenu.value,\n                            onDismissRequest = { showMenu.value = false },\n                            modifier = Modifier\n                                .width(250.dp)\n                                .background(\n                                    if (isSystemInDarkTheme()) Color(0xFF1C1B20) else Color(0xFFF2F2F7)\n                                )\n                                .padding(vertical = 4.dp)\n                        ) {\n                            DropdownMenuItem(\n                                text = {\n                                    Row(\n                                        verticalAlignment = Alignment.CenterVertically,\n                                        modifier = Modifier.fillMaxWidth()\n                                    ) {\n                                        Text(\n                                            \"Auto-scroll\",\n                                            style = TextStyle(\n                                                fontSize = 16.sp,\n                                                fontWeight = FontWeight.Normal\n                                            )\n                                        )\n                                        Spacer(modifier = Modifier.weight(1f))\n                                        IOSCheckbox(\n                                            checked = shouldScrollToBottom.value,\n                                            onCheckedChange = { shouldScrollToBottom.value = it }\n                                        )\n                                    }\n                                },\n                                onClick = {\n                                    shouldScrollToBottom.value = !shouldScrollToBottom.value\n                                    showMenu.value = false\n                                }\n                            )\n\n                            HorizontalDivider(\n                                color = if (isSystemInDarkTheme()) Color(0xFF3A3A3C) else Color(0xFFE5E5EA),\n                                thickness = 0.5.dp\n                            )\n\n                            DropdownMenuItem(\n                                text = {\n                                    Row(\n                                        verticalAlignment = Alignment.CenterVertically,\n                                        modifier = Modifier.fillMaxWidth()\n                                    ) {\n                                        Text(\n                                            \"Clear logs\",\n                                            style = TextStyle(\n                                                fontSize = 16.sp,\n                                                fontWeight = FontWeight.Normal\n                                            )\n                                        )\n                                        Spacer(modifier = Modifier.weight(1f))\n                                        Icon(\n                                            imageVector = Icons.Default.Delete,\n                                            contentDescription = \"Clear logs\",\n                                            tint = if (isSystemInDarkTheme()) Color(0xFF007AFF) else Color(0xFF3C6DF5)\n                                        )\n                                    }\n                                },\n                                onClick = {\n                                    ServiceManager.getService()?.clearLogs()\n                                    expandedItems.value = emptySet()\n                                    showMenu.value = false\n                                }\n                            )\n                        }\n                    }\n                },\n                modifier = Modifier.hazeEffect(\n                    state = hazeState,\n                    style = CupertinoMaterials.thick(),\n                    block = fun HazeEffectScope.() {\n                        alpha = if (scrollOffset > 0) 1f else 0f\n                    }),\n                colors = TopAppBarDefaults.topAppBarColors(containerColor = Color.Transparent),\n            )\n        },\n        containerColor = if (isSystemInDarkTheme()) Color(0xFF000000) else Color(0xFFF2F2F7),\n    ) { paddingValues ->\n        Column(\n            modifier = Modifier\n                .fillMaxSize()\n                .hazeSource(hazeState)\n                .padding(top = paddingValues.calculateTopPadding())\n                .navigationBarsPadding()\n        ) {\n            LazyColumn(\n                state = listState,\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .weight(1f),\n                content = {\n                    items(packetLogs.size) { index ->\n                        val message = packetLogs.elementAt(index)\n                        val isSent = message.startsWith(\"Sent\")\n                        val isExpanded = expandedItems.value.contains(index)\n                        val packetInfo = parsePacket(message)\n\n                        Card(\n                            modifier = Modifier\n                                .fillMaxWidth()\n                                .padding(vertical = 2.dp, horizontal = 4.dp)\n                                .combinedClickable(\n                                    onClick = {\n                                        expandedItems.value = if (isExpanded) {\n                                            expandedItems.value - index\n                                        } else {\n                                            expandedItems.value + index\n                                        }\n                                    },\n                                    onLongClick = {\n                                        copyToClipboard(packetInfo.rawData)\n                                    }\n                                ),\n                            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp),\n                            shape = RoundedCornerShape(4.dp),\n                            colors = CardDefaults.cardColors(\n                                containerColor = if (isSystemInDarkTheme()) Color(0xFF1C1B20) else Color(0xFFF2F2F7),\n                            )\n                        ) {\n                            Column(modifier = Modifier.padding(8.dp)) {\n                                Row(verticalAlignment = Alignment.CenterVertically) {\n                                    Icon(\n                                        imageVector = if (isSent) Icons.AutoMirrored.Filled.KeyboardArrowLeft else Icons.AutoMirrored.Filled.KeyboardArrowRight,\n                                        contentDescription = null,\n                                        tint = if (isSent) Color.Green else Color.Red,\n                                        modifier = Modifier.size(24.dp)\n                                    )\n                                    Spacer(modifier = Modifier.width(4.dp))\n                                    Column {\n                                        Text(\n                                            text = if (packetInfo.isUnknown) {\n                                                val shortenedData = packetInfo.rawData.take(60) +\n                                                    (if (packetInfo.rawData.length > 60) \"...\" else \"\")\n                                                shortenedData\n                                            } else {\n                                                \"${packetInfo.type}: ${packetInfo.description}\"\n                                            },\n                                            style = TextStyle(\n                                                fontSize = 12.sp,\n                                                fontWeight = FontWeight.Medium,\n                                                fontFamily = FontFamily(Font(R.font.hack))\n                                            )\n                                        )\n                                        if (isExpanded) {\n                                            Spacer(modifier = Modifier.height(4.dp))\n\n                                            if (packetInfo.parsedData.isNotEmpty()) {\n                                                packetInfo.parsedData.forEach { (key, value) ->\n                                                    Row {\n                                                        Text(\n                                                            text = \"$key: \",\n                                                            style = TextStyle(\n                                                                fontSize = 12.sp,\n                                                                fontWeight = FontWeight.Bold,\n                                                                fontFamily = FontFamily(Font(R.font.hack))\n                                                            ),\n                                                            color = Color.Gray\n                                                        )\n                                                        Text(\n                                                            text = value,\n                                                            style = TextStyle(\n                                                                fontSize = 12.sp,\n                                                                fontFamily = FontFamily(Font(R.font.hack))\n                                                            ),\n                                                            color = Color.Gray\n                                                        )\n                                                    }\n                                                }\n                                                Spacer(modifier = Modifier.height(4.dp))\n                                            }\n\n                                            Text(\n                                                text = \"Raw: ${packetInfo.rawData}\",\n                                                style = TextStyle(\n                                                    fontSize = 12.sp,\n                                                    fontFamily = FontFamily(Font(R.font.hack))\n                                                ),\n                                                color = Color.Gray\n                                            )\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            )\n            Spacer(modifier = Modifier.height(8.dp))\n            val airPodsService = ServiceManager.getService()?.let { mutableStateOf(it) }\n            HorizontalDivider()\n            Row(\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .background(if (isSystemInDarkTheme()) Color(0xFF1C1B20) else Color(0xFFF2F2F7)),\n                verticalAlignment = Alignment.CenterVertically\n            ) {\n                val packet = remember { mutableStateOf(TextFieldValue(\"\")) }\n                TextField(\n                    value = packet.value,\n                    onValueChange = { packet.value = it },\n                    label = { Text(\"Packet\") },\n                    modifier = Modifier\n                        .fillMaxWidth()\n                        .padding(horizontal = 8.dp)\n                        .padding(bottom = 5.dp),\n                    trailingIcon = {\n                        IconButton(\n                            onClick = {\n                                if (packet.value.text.isNotBlank()) {\n                                    airPodsService?.value?.aacpManager?.sendPacket(\n                                        packet.value.text\n                                            .split(\" \")\n                                            .map { it.toInt(16).toByte() }\n                                            .toByteArray()\n                                    )\n                                    packet.value = TextFieldValue(\"\")\n                                    focusManager.clearFocus()\n\n                                    if (shouldScrollToBottom.value && packetLogs.isNotEmpty()) {\n                                        coroutineScope.launch {\n                                            try {\n                                                delay(100)\n                                                listState.animateScrollToItem(\n                                                    index = (packetLogs.size - 1).coerceAtLeast(0),\n                                                    scrollOffset = 0\n                                                )\n                                            } catch (e: Exception) {\n                                                e.printStackTrace()\n                                                listState.scrollToItem(\n                                                    index = (packetLogs.size - 1).coerceAtLeast(0)\n                                                )\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        ) {\n                            @Suppress(\"DEPRECATION\")\n                            Icon(Icons.Filled.Send, contentDescription = \"Send\")\n                        }\n                    },\n                    colors = TextFieldDefaults.colors(\n                        focusedContainerColor = if (isSystemInDarkTheme()) Color(0xFF1C1B20) else Color(0xFFF2F2F7),\n                        unfocusedContainerColor = if (isSystemInDarkTheme()) Color(0xFF1C1B20) else Color(0xFFF2F2F7),\n                        focusedIndicatorColor = Color.Transparent,\n                        unfocusedIndicatorColor = Color.Transparent,\n                        focusedTextColor =  if (isSystemInDarkTheme()) Color.White else Color.Black,\n                        unfocusedTextColor =  if (isSystemInDarkTheme()) Color.White else Color.Black.copy(alpha = 0.6f),\n                        focusedLabelColor =  if (isSystemInDarkTheme()) Color.White.copy(alpha = 0.6f) else Color.Black,\n                        unfocusedLabelColor =  if (isSystemInDarkTheme()) Color.White.copy(alpha = 0.6f) else Color.Black.copy(alpha = 0.6f),\n                    ),\n                    shape = RoundedCornerShape(12.dp)\n                )\n            }\n        }\n    }\n}\n"
        },
        {
          "name": "AirPodsSettingsScreen.kt",
          "ext": ".kt",
          "size": 21882,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n *\n * Copyright (C) 2025 LibrePods contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\n@file:OptIn(ExperimentalEncodingApi::class)\n\npackage me.kavishdevar.librepods.screens\n\nimport android.annotation.SuppressLint\nimport android.bluetooth.BluetoothDevice\nimport android.content.BroadcastReceiver\nimport android.content.Context\nimport android.content.Context.MODE_PRIVATE\nimport android.content.Context.RECEIVER_EXPORTED\nimport android.content.Intent\nimport android.content.IntentFilter\nimport android.content.SharedPreferences\nimport android.os.Build\nimport androidx.compose.foundation.isSystemInDarkTheme\nimport androidx.compose.foundation.layout.Arrangement\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Spacer\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.rememberScrollState\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.foundation.verticalScroll\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.Info\nimport androidx.compose.material.icons.filled.Settings\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.runtime.*\nimport androidx.compose.material3.*\nimport androidx.compose.material3.Button\nimport androidx.compose.material3.ButtonDefaults\nimport androidx.compose.material3.CenterAlignedTopAppBar\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.IconButton\nimport androidx.compose.material3.IconButtonDefaults\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.SnackbarHost\nimport androidx.compose.material3.SnackbarHostState\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TopAppBarDefaults\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.DisposableEffect\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableFloatStateOf\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.rememberCoroutineScope\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.drawBehind\nimport androidx.compose.ui.geometry.Offset\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.text.TextStyle\nimport androidx.compose.ui.text.font.Font\nimport androidx.compose.ui.text.font.FontFamily\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.text.input.TextFieldValue\nimport androidx.compose.ui.text.style.TextAlign\nimport androidx.compose.ui.tooling.preview.Preview\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport androidx.navigation.NavController\nimport androidx.navigation.compose.rememberNavController\nimport dev.chrisbanes.haze.HazeEffectScope\nimport dev.chrisbanes.haze.HazeState\nimport dev.chrisbanes.haze.hazeEffect\nimport dev.chrisbanes.haze.hazeSource\nimport dev.chrisbanes.haze.materials.CupertinoMaterials\nimport dev.chrisbanes.haze.materials.ExperimentalHazeMaterialsApi\nimport kotlinx.coroutines.launch\nimport me.kavishdevar.librepods.R\nimport me.kavishdevar.librepods.composables.AccessibilitySettings\nimport me.kavishdevar.librepods.composables.AudioSettings\nimport me.kavishdevar.librepods.composables.BatteryView\nimport me.kavishdevar.librepods.composables.IndependentToggle\nimport me.kavishdevar.librepods.composables.NameField\nimport me.kavishdevar.librepods.composables.NavigationButton\nimport me.kavishdevar.librepods.composables.NoiseControlSettings\nimport me.kavishdevar.librepods.composables.PressAndHoldSettings\nimport me.kavishdevar.librepods.constants.AirPodsNotifications\nimport me.kavishdevar.librepods.services.AirPodsService\nimport me.kavishdevar.librepods.ui.theme.LibrePodsTheme\nimport me.kavishdevar.librepods.utils.AACPManager\nimport kotlin.io.encoding.ExperimentalEncodingApi\n\n@OptIn(ExperimentalMaterial3Api::class, ExperimentalHazeMaterialsApi::class)\n@SuppressLint(\"MissingPermission\", \"UnspecifiedRegisterReceiverFlag\")\n@Composable\nfun AirPodsSettingsScreen(dev: BluetoothDevice?, service: AirPodsService,\n                          navController: NavController, isConnected: Boolean, isRemotelyConnected: Boolean) {\n    var isLocallyConnected by remember { mutableStateOf(isConnected) }\n    var isRemotelyConnected by remember { mutableStateOf(isRemotelyConnected) }\n    val sharedPreferences = LocalContext.current.getSharedPreferences(\"settings\", MODE_PRIVATE)\n    val bleOnlyMode = sharedPreferences.getBoolean(\"ble_only_mode\", false)\n    var device by remember { mutableStateOf(dev) }\n    var deviceName by remember {\n        mutableStateOf(\n            TextFieldValue(\n                sharedPreferences.getString(\"name\", device?.name ?: \"AirPods Pro\").toString()\n            )\n        )\n    }\n\n    LaunchedEffect(service) {\n        isLocallyConnected = service.isConnectedLocally\n    }\n\n    val nameChangeListener = remember {\n        SharedPreferences.OnSharedPreferenceChangeListener { _, key ->\n            if (key == \"name\") {\n                deviceName = TextFieldValue(sharedPreferences.getString(\"name\", \"AirPods Pro\").toString())\n            }\n        }\n    }\n\n    DisposableEffect(Unit) {\n        sharedPreferences.registerOnSharedPreferenceChangeListener(nameChangeListener)\n        onDispose {\n            sharedPreferences.unregisterOnSharedPreferenceChangeListener(nameChangeListener)\n        }\n    }\n\n    val verticalScrollState  = rememberScrollState()\n    val hazeState = remember { HazeState() }\n    val snackbarHostState = remember { SnackbarHostState() }\n    val coroutineScope = rememberCoroutineScope()\n\n    fun handleRemoteConnection(connected: Boolean) {\n        isRemotelyConnected = connected\n    }\n\n    fun showSnackbar(message: String) {\n        coroutineScope.launch {\n            snackbarHostState.showSnackbar(message)\n        }\n    }\n\n    val context = LocalContext.current\n\n    val connectionReceiver = remember {\n        object : BroadcastReceiver() {\n            override fun onReceive(context: Context?, intent: Intent?) {\n                when (intent?.action) {\n                    \"me.kavishdevar.librepods.AIRPODS_CONNECTED_REMOTELY\" -> {\n                        coroutineScope.launch {\n                            handleRemoteConnection(true)\n                        }\n                    }\n                    \"me.kavishdevar.librepods.AIRPODS_DISCONNECTED_REMOTELY\" -> {\n                        coroutineScope.launch {\n                            handleRemoteConnection(false)\n                        }\n                    }\n                    AirPodsNotifications.AIRPODS_CONNECTED -> {\n                        coroutineScope.launch {\n                            isLocallyConnected = true\n                        }\n                    }\n                    AirPodsNotifications.AIRPODS_DISCONNECTED -> {\n                        coroutineScope.launch {\n                            isLocallyConnected = false\n                        }\n                    }\n                    AirPodsNotifications.DISCONNECT_RECEIVERS -> {\n                        try {\n                            context?.unregisterReceiver(this)\n                        } catch (e: IllegalArgumentException) {\n                            e.printStackTrace()\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    DisposableEffect(Unit) {\n        val filter = IntentFilter().apply {\n            addAction(\"me.kavishdevar.librepods.AIRPODS_CONNECTED_REMOTELY\")\n            addAction(\"me.kavishdevar.librepods.AIRPODS_DISCONNECTED_REMOTELY\")\n            addAction(AirPodsNotifications.AIRPODS_CONNECTED)\n            addAction(AirPodsNotifications.AIRPODS_DISCONNECTED)\n            addAction(AirPodsNotifications.DISCONNECT_RECEIVERS)\n        }\n\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\n            context.registerReceiver(connectionReceiver, filter, RECEIVER_EXPORTED)\n        } else {\n            context.registerReceiver(connectionReceiver, filter)\n        }\n        onDispose {\n            try {\n                context.unregisterReceiver(connectionReceiver)\n            } catch (e: Exception) {\n                e.printStackTrace()\n            }\n        }\n    }\n\n    @SuppressLint(\"UnusedMaterial3ScaffoldPaddingParameter\")\n    Scaffold(\n        containerColor = if (isSystemInDarkTheme()) Color(\n            0xFF000000\n        ) else Color(\n            0xFFF2F2F7\n        ),\n        topBar = {\n            val darkMode = isSystemInDarkTheme()\n            val mDensity = remember { mutableFloatStateOf(1f) }\n            CenterAlignedTopAppBar(\n                title = {\n                    Text(\n                        text = deviceName.text,\n                        style = TextStyle(\n                            fontSize = 20.sp,\n                            fontWeight = FontWeight.Medium,\n                            color = if (darkMode) Color.White else Color.Black,\n                            fontFamily = FontFamily(Font(R.font.sf_pro))\n                        )\n                    )\n                },\n                modifier = Modifier\n                    .hazeEffect(\n                        state = hazeState,\n                        style = CupertinoMaterials.thick(),\n                        block = fun HazeEffectScope.() {\n                            alpha =\n                                if (verticalScrollState.value > 60.dp.value * mDensity.floatValue) 1f else 0f\n                        })\n                    .drawBehind {\n                        mDensity.floatValue = density\n                        val strokeWidth = 0.7.dp.value * density\n                        val y = size.height - strokeWidth / 2\n                        if (verticalScrollState.value > 60.dp.value * density) {\n                            drawLine(\n                                if (darkMode) Color.DarkGray else Color.LightGray,\n                                Offset(0f, y),\n                                Offset(size.width, y),\n                                strokeWidth\n                            )\n                        }\n                    },\n                colors = TopAppBarDefaults.centerAlignedTopAppBarColors(\n                    containerColor = Color.Transparent\n                ),\n                actions = {\n                    if (isRemotelyConnected) {\n                        IconButton(\n                            onClick = {\n                                showSnackbar(\"Connected remotely to AirPods via Linux.\")\n                            },\n                            colors = IconButtonDefaults.iconButtonColors(\n                                containerColor = Color.Transparent,\n                                contentColor = if (isSystemInDarkTheme()) Color.White else Color.Black\n                            )\n                        ) {\n                            Icon(\n                                imageVector = Icons.Default.Info,\n                                contentDescription = \"Info\",\n                            )\n                        }\n                    }\n                    IconButton(\n                        onClick = {\n                            navController.navigate(\"app_settings\")\n                        },\n                        colors = IconButtonDefaults.iconButtonColors(\n                            containerColor = Color.Transparent,\n                            contentColor = if (isSystemInDarkTheme()) Color.White else Color.Black\n                        )\n                    ) {\n                        Icon(\n                            imageVector = Icons.Default.Settings,\n                            contentDescription = \"Settings\",\n                        )\n                    }\n                }\n            )\n        },\n        snackbarHost = { SnackbarHost(snackbarHostState) }\n    ) { paddingValues ->\n        if (isLocallyConnected || isRemotelyConnected) {\n            Column(\n                modifier = Modifier\n                    .hazeSource(hazeState)\n                    .fillMaxSize()\n                    .padding(horizontal = 16.dp)\n                    .verticalScroll(\n        Spacer(Modifier.height(12.dp))\n        BluetoothAdvancedSection(ctx = LocalContext.current)\n                        state = verticalScrollState,\n                        enabled = true,\n                    )\n            ) {\n                Spacer(Modifier.height(75.dp))\n                LaunchedEffect(service) {\n                    service.let {\n                        it.sendBroadcast(Intent(AirPodsNotifications.Companion.BATTERY_DATA).apply {\n                            putParcelableArrayListExtra(\"data\", ArrayList(it.getBattery()))\n                        })\n                        it.sendBroadcast(Intent(AirPodsNotifications.Companion.ANC_DATA).apply {\n                            putExtra(\"data\", it.getANC())\n                        })\n                    }\n                }\n                val sharedPreferences = LocalContext.current.getSharedPreferences(\"settings\", MODE_PRIVATE)\n\n                Spacer(modifier = Modifier.height(64.dp))\n\n                BatteryView(service = service)\n\n                Spacer(modifier = Modifier.height(32.dp))\n\n                // Show BLE-only mode indicator\n                if (bleOnlyMode) {\n                    Text(\n                        text = \"BLE-only mode - advanced features disabled\",\n                        style = TextStyle(\n                            fontSize = 14.sp,\n                            fontWeight = FontWeight.Medium,\n                            color = (if (isSystemInDarkTheme()) Color.White else Color.Black).copy(alpha = 0.6f),\n                            fontFamily = FontFamily(Font(R.font.sf_pro))\n                        ),\n                        modifier = Modifier.padding(8.dp, bottom = 16.dp)\n                    )\n                }\n\n                // Only show name field when not in BLE-only mode\n                if (!bleOnlyMode) {\n                    NameField(\n                        name = stringResource(R.string.name),\n                        value = deviceName.text,\n                        navController = navController\n                    )\n                }\n\n                // Only show L2CAP-dependent features when not in BLE-only mode\n                if (!bleOnlyMode) {\n                    Spacer(modifier = Modifier.height(32.dp))\n                    NoiseControlSettings(service = service)\n\n                    Spacer(modifier = Modifier.height(16.dp))\n                    Text(\n                        text = stringResource(R.string.head_gestures).uppercase(),\n                        style = TextStyle(\n                            fontSize = 14.sp,\n                            fontWeight = FontWeight.Light,\n                            color = (if (isSystemInDarkTheme()) Color.White else Color.Black).copy(alpha = 0.6f),\n                            fontFamily = FontFamily(Font(R.font.sf_pro))\n                        ),\n                        modifier = Modifier.padding(8.dp, bottom = 2.dp)\n                    )\n\n                    Spacer(modifier = Modifier.height(2.dp))\n                    NavigationButton(to = \"head_tracking\", \"Head Tracking\", navController)\n\n                    Spacer(modifier = Modifier.height(16.dp))\n                    PressAndHoldSettings(navController = navController)\n\n                    Spacer(modifier = Modifier.height(16.dp))\n                    AudioSettings()\n\n                    Spacer(modifier = Modifier.height(16.dp))\n                    IndependentToggle(\n                        name = \"Off Listening Mode\",\n                        service = service,\n                        sharedPreferences = sharedPreferences,\n                        default = false,\n                        controlCommandIdentifier = AACPManager.Companion.ControlCommandIdentifiers.ALLOW_OFF_OPTION\n                    )\n\n                    Spacer(modifier = Modifier.height(16.dp))\n                    AccessibilitySettings()\n                }\n\n                Spacer(modifier = Modifier.height(16.dp))\n                IndependentToggle(\n                    name = \"Automatic Ear Detection\",\n                    service = service,\n                    functionName = \"setEarDetection\",\n                    sharedPreferences = sharedPreferences,\n                    default = true,\n                )\n\n                // Only show debug when not in BLE-only mode\n                if (!bleOnlyMode) {\n                    Spacer(modifier = Modifier.height(16.dp))\n                    NavigationButton(\"debug\", \"Debug\", navController)\n                }\n\n                Spacer(Modifier.height(24.dp))\n            }\n        }\n        else {\n            Column(\n                modifier = Modifier\n                    .fillMaxSize()\n                    .padding(horizontal = 8.dp)\n                    .verticalScroll(\n                        state = verticalScrollState,\n                        enabled = true,\n                    ),\n                horizontalAlignment = Alignment.CenterHorizontally,\n                verticalArrangement = Arrangement.Center\n            ) {\n                Text(\n                    text = \"AirPods not connected\",\n                    style = TextStyle(\n                        fontSize = 24.sp,\n                        fontWeight = FontWeight.Medium,\n                        color = if (isSystemInDarkTheme()) Color.White else Color.Black,\n                        fontFamily = FontFamily(Font(R.font.sf_pro))\n                    ),\n                    textAlign = TextAlign.Center,\n                    modifier = Modifier.fillMaxWidth()\n                )\n                Spacer(Modifier.height(24.dp))\n                Text(\n                    text = \"Please connect your AirPods to access settings.\",\n                    style = TextStyle(\n                        fontSize = 16.sp,\n                        fontWeight = FontWeight.Light,\n                        color = if (isSystemInDarkTheme()) Color.White else Color.Black,\n                        fontFamily = FontFamily(Font(R.font.sf_pro))\n                    ),\n                    textAlign = TextAlign.Center,\n                    modifier = Modifier.fillMaxWidth()\n                )\n                Spacer(Modifier.height(32.dp))\n                Button(\n                    onClick = { navController.navigate(\"troubleshooting\") },\n                    shape = RoundedCornerShape(10.dp),\n                    colors = ButtonDefaults.buttonColors(\n                        containerColor = if (isSystemInDarkTheme()) Color(0xFF1C1C1E) else Color(0xFFF2F2F7),\n                        contentColor = if (isSystemInDarkTheme()) Color.White else Color.Black,\n                    )\n                ) {\n                    Text(\n                        text = \"Troubleshoot Connection\",\n                        style = TextStyle(\n                            fontSize = 16.sp,\n                            fontWeight = FontWeight.Medium,\n                            fontFamily = FontFamily(Font(R.font.sf_pro))\n                        )\n                    )\n                }\n            }\n        }\n    }\n}\n\n\n@Preview\n@Composable\nfun AirPodsSettingsScreenPreview() {\n    Column (\n        modifier = Modifier.height(2000.dp)\n    ) {\n        LibrePodsTheme (\n            darkTheme = true\n        ) {\n            AirPodsSettingsScreen(dev = null, service = AirPodsService(), navController = rememberNavController(), isConnected = true, isRemotelyConnected = false)\n        }\n    }\n}\n\n\n@Composable\nfun BluetoothAdvancedSection(ctx: android.content.Context) {\n    Card(shape = RoundedCornerShape(16.dp)) {\n        Column(Modifier.fillMaxWidth().padding(16.dp)) {\n            Text(\"Bluetooth \u2022 Advanced\", style = MaterialTheme.typography.titleMedium)\n            Spacer(Modifier.height(8.dp))\n            var checked by remember { mutableStateOf(me.kavishdevar.librepods.utils.SettingsManager.isUseCoc(ctx)) }\n            Row(Modifier.fillMaxWidth(), verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.SpaceBetween) {\n                Column(Modifier.weight(1f).padding(end = 8.dp)) {\n                    Text(\"Prefer high-throughput (L2CAP) when available\", style = MaterialTheme.typography.bodyLarge)\n                    Spacer(Modifier.height(2.dp))\n                    Text(\"Uses BLE L2CAP CoC on Android 10+; falls back to GATT if unsupported.\", style = MaterialTheme.typography.bodySmall, color = MaterialTheme.colorScheme.onSurfaceVariant)\n                }\n                Switch(checked = checked, onCheckedChange = {\n                    checked = it\n                    me.kavishdevar.librepods.utils.SettingsManager.setUseCoc(ctx, it)\n                })\n            }\n        }\n    }\n}"
        },
        {
          "name": "CocSettingsScreen.kt",
          "ext": ".kt",
          "size": 1006,
          "preview": "package me.kavishdevar.librepods.screens\n\nimport android.content.Context\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.unit.dp\nimport me.kavishdevar.librepods.utils.SettingsManager\n\n@Composable\nfun CocSettingsScreen(context: Context) {\n    var checked by remember { mutableStateOf(SettingsManager.isUseCoc(context)) }\n\n    Column(modifier = Modifier.fillMaxSize().padding(16.dp)) {\n        Text(\"Connection Settings\", style = MaterialTheme.typography.headlineSmall)\n        Spacer(Modifier.height(12.dp))\n        Row(verticalAlignment = androidx.compose.ui.Alignment.CenterVertically) {\n            Checkbox(checked = checked, onCheckedChange = {\n                checked = it\n                SettingsManager.setUseCoc(context, it)\n            })\n            Spacer(Modifier.width(8.dp))\n            Text(\"Prefer high-throughput L2CAP (CoC) when available\")\n        }\n    }\n}\n"
        },
        {
          "name": "RenameScreen.kt",
          "ext": ".kt",
          "size": 8579,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n *\n * Copyright (C) 2025 LibrePods contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\n@file:OptIn(ExperimentalEncodingApi::class)\n\npackage me.kavishdevar.librepods.screens\n\nimport android.content.Context\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.isSystemInDarkTheme\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.foundation.text.BasicTextField\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.automirrored.filled.KeyboardArrowLeft\nimport androidx.compose.material.icons.filled.Clear\nimport androidx.compose.material3.CenterAlignedTopAppBar\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.IconButton\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TextButton\nimport androidx.compose.material3.TopAppBarDefaults\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.scale\nimport androidx.compose.ui.focus.FocusRequester\nimport androidx.compose.ui.focus.focusRequester\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.graphics.SolidColor\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.platform.LocalSoftwareKeyboardController\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.text.TextRange\nimport androidx.compose.ui.text.TextStyle\nimport androidx.compose.ui.text.font.Font\nimport androidx.compose.ui.text.font.FontFamily\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.text.input.TextFieldValue\nimport androidx.compose.ui.tooling.preview.Preview\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport androidx.navigation.NavController\nimport me.kavishdevar.librepods.R\nimport me.kavishdevar.librepods.services.ServiceManager\nimport kotlin.io.encoding.ExperimentalEncodingApi\n\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun RenameScreen(navController: NavController) {\n    val sharedPreferences = LocalContext.current.getSharedPreferences(\"settings\", Context.MODE_PRIVATE)\n    val isDarkTheme = isSystemInDarkTheme()\n    val name = remember { mutableStateOf(TextFieldValue(sharedPreferences.getString(\"name\", \"\") ?: \"\")) }\n    val focusRequester = remember { FocusRequester() }\n    val keyboardController = LocalSoftwareKeyboardController.current\n\n    LaunchedEffect(Unit) {\n        focusRequester.requestFocus()\n        keyboardController?.show()\n        name.value = name.value.copy(selection = TextRange(name.value.text.length))\n    }\n\n    Scaffold(\n        topBar = {\n            CenterAlignedTopAppBar(\n                title = {\n                    Text(\n                        text = stringResource(R.string.name),\n                        fontFamily = FontFamily(Font(R.font.sf_pro)),\n                    )\n                },\n                navigationIcon = {\n                    TextButton(\n                        onClick = {\n                            navController.popBackStack()\n                        },\n                        shape = RoundedCornerShape(8.dp),\n                    ) {\n                        Icon(\n                            Icons.AutoMirrored.Filled.KeyboardArrowLeft,\n                            contentDescription = \"Back\",\n                            tint = if (isDarkTheme)  Color(0xFF007AFF) else Color(0xFF3C6DF5),\n                            modifier = Modifier.scale(1.5f)\n                        )\n                        Text(\n                            text = name.value.text,\n                            style = TextStyle(\n                                fontSize = 18.sp,\n                                fontWeight = FontWeight.Medium,\n                                color = if (isDarkTheme) Color(0xFF007AFF) else Color(0xFF3C6DF5),\n                                fontFamily = FontFamily(Font(R.font.sf_pro))\n                            ),\n                        )\n                    }\n                },\n                colors = TopAppBarDefaults.topAppBarColors(\n                    containerColor = Color.Transparent\n                )\n            )\n        },\n        containerColor = if (isSystemInDarkTheme()) Color(0xFF000000)\n        else Color(0xFFF2F2F7),\n    ) { paddingValues ->\n        Column (\n            modifier = Modifier\n                .fillMaxSize()\n                .padding(paddingValues = paddingValues)\n                .padding(horizontal = 16.dp)\n                .padding(top = 8.dp)\n        ) {\n            val isDarkTheme = isSystemInDarkTheme()\n            val backgroundColor = if (isDarkTheme) Color(0xFF1C1C1E) else Color(0xFFFFFFFF)\n            val textColor = if (isDarkTheme) Color.White else Color.Black\n            val cursorColor =  if (isDarkTheme) Color.White else Color.Black\n            Row(\n                verticalAlignment = Alignment.CenterVertically,\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .height(55.dp)\n                    .background(\n                        backgroundColor,\n                        RoundedCornerShape(14.dp)\n                    )\n                    .padding(horizontal = 16.dp, vertical = 8.dp)\n            ) {\n                BasicTextField(\n                    value = name.value,\n                    onValueChange = {\n                        name.value = it\n                        sharedPreferences.edit().putString(\"name\", it.text).apply()\n                        ServiceManager.getService()?.setName(it.text)\n                    },\n                    textStyle = TextStyle(\n                        color = textColor,\n                        fontSize = 16.sp,\n                    ),\n                    singleLine = true,\n                    cursorBrush = SolidColor(cursorColor),\n                    decorationBox = { innerTextField ->\n                        Row(\n                            verticalAlignment = Alignment.CenterVertically,\n                        ) {\n                            Row(\n                                modifier = Modifier\n                                    .weight(1f)\n                            ) {\n                                innerTextField()\n                            }\n                            IconButton(\n                                onClick = {\n                                    name.value = TextFieldValue(\"\")\n                                    sharedPreferences.edit().putString(\"name\", \"\").apply()\n                                    ServiceManager.getService()?.setName(\"\")\n                                }\n                            ) {\n                                Icon(\n                                    Icons.Default.Clear,\n                                    contentDescription = \"Clear\",\n                                    tint = if (isDarkTheme) Color.White else Color.Black\n                                )\n                            }\n                        }\n                    },\n                    modifier = Modifier\n                        .fillMaxWidth()\n                        .padding(start = 8.dp)\n                        .focusRequester(focusRequester)\n                )\n            }\n        }\n    }\n}\n\n@Preview\n@Composable\nfun RenameScreenPreview() {\n    RenameScreen(navController = NavController(LocalContext.current))\n}\n"
        },
        {
          "name": "PressAndHoldSettingsScreen.kt",
          "ext": ".kt",
          "size": 21697,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n *\n * Copyright (C) 2025 LibrePods contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\n@file:OptIn(ExperimentalStdlibApi::class, ExperimentalEncodingApi::class)\n\npackage me.kavishdevar.librepods.screens\n\nimport android.content.Context\nimport android.util.Log\nimport androidx.compose.animation.animateColorAsState\nimport androidx.compose.animation.core.tween\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.gestures.detectTapGestures\nimport androidx.compose.foundation.isSystemInDarkTheme\nimport androidx.compose.foundation.layout.Arrangement\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.wrapContentWidth\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.automirrored.filled.KeyboardArrowLeft\nimport androidx.compose.material3.CenterAlignedTopAppBar\nimport androidx.compose.material3.Checkbox\nimport androidx.compose.material3.CheckboxDefaults\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.HorizontalDivider\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TextButton\nimport androidx.compose.material3.TopAppBarDefaults\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.scale\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.input.pointer.pointerInput\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.res.painterResource\nimport androidx.compose.ui.text.TextStyle\nimport androidx.compose.ui.text.font.Font\nimport androidx.compose.ui.text.font.FontFamily\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport androidx.navigation.NavController\nimport me.kavishdevar.librepods.R\nimport me.kavishdevar.librepods.constants.StemAction\nimport me.kavishdevar.librepods.services.ServiceManager\nimport me.kavishdevar.librepods.utils.AACPManager\nimport kotlin.experimental.and\nimport kotlin.io.encoding.ExperimentalEncodingApi\n\n@Composable()\nfun RightDivider() {\n    HorizontalDivider(\n        thickness = 1.5.dp,\n        color = Color(0x40888888),\n        modifier = Modifier\n            .padding(start = 72.dp)\n    )\n}\n\n@Composable()\nfun RightDividerNoIcon() {\n    HorizontalDivider(\n        thickness = 1.5.dp,\n        color = Color(0x40888888),\n        modifier = Modifier\n            .padding(start = 20.dp)\n    )\n}\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun LongPress(navController: NavController, name: String) {\n    val isDarkTheme = isSystemInDarkTheme()\n    val textColor = if (isDarkTheme) Color.White else Color.Black\n\n    val modesByte = ServiceManager.getService()!!.aacpManager.controlCommandStatusList.find {\n        it.identifier == AACPManager.Companion.ControlCommandIdentifiers.LISTENING_MODE_CONFIGS\n    }?.value?.takeIf { it.isNotEmpty() }?.get(0)\n\n    if (modesByte != null) {\n        Log.d(\"PressAndHoldSettingsScreen\", \"Current modes state: ${modesByte.toString(2)}\")\n        Log.d(\"PressAndHoldSettingsScreen\", \"Off mode: ${(modesByte and 0x01) != 0.toByte()}\")\n        Log.d(\"PressAndHoldSettingsScreen\", \"Transparency mode: ${(modesByte and 0x02) != 0.toByte()}\")\n        Log.d(\"PressAndHoldSettingsScreen\", \"Noise Cancellation mode: ${(modesByte and 0x04) != 0.toByte()}\")\n        Log.d(\"PressAndHoldSettingsScreen\", \"Adaptive mode: ${(modesByte and 0x08) != 0.toByte()}\")\n    }\n    val context = LocalContext.current\n    val sharedPreferences = context.getSharedPreferences(\"settings\", Context.MODE_PRIVATE)\n    val deviceName = sharedPreferences.getString(\"name\", \"AirPods Pro\")\n    val prefKey = if (name.lowercase() == \"left\") \"left_long_press_action\" else \"right_long_press_action\"\n    val longPressActionPref = sharedPreferences.getString(prefKey, StemAction.CYCLE_NOISE_CONTROL_MODES.name)\n    Log.d(\"PressAndHoldSettingsScreen\", \"Long press action preference ($prefKey): $longPressActionPref\")\n    var longPressAction by remember { mutableStateOf(StemAction.valueOf(longPressActionPref ?: StemAction.CYCLE_NOISE_CONTROL_MODES.name)) }\n    Scaffold(\n        topBar = {\n            CenterAlignedTopAppBar(\n                title = {\n                        Text(\n                            name,\n                            fontFamily = FontFamily(Font(R.font.sf_pro)),\n                        )\n                    },\n                navigationIcon = {\n                    TextButton(\n                        onClick = {\n                            navController.popBackStack()\n                        },\n                        shape = RoundedCornerShape(8.dp),\n                    ) {\n                        Icon(\n                            Icons.AutoMirrored.Filled.KeyboardArrowLeft,\n                            contentDescription = \"Back\",\n                            tint = if (isDarkTheme)  Color(0xFF007AFF) else Color(0xFF3C6DF5),\n                            modifier = Modifier.scale(1.5f)\n                        )\n                        Text(\n                            deviceName?: \"AirPods Pro\",\n                            style = TextStyle(\n                                fontSize = 18.sp,\n                                fontWeight = FontWeight.Medium,\n                                color = if (isDarkTheme) Color(0xFF007AFF) else Color(0xFF3C6DF5),\n                                fontFamily = FontFamily(Font(R.font.sf_pro))\n                            ),\n                        )\n                    }\n                },\n                colors = TopAppBarDefaults.topAppBarColors(\n                    containerColor = Color.Transparent\n                )\n            )\n        },\n        containerColor = if (isSystemInDarkTheme()) Color(0xFF000000)\n        else Color(0xFFF2F2F7),\n    ) { paddingValues ->\n        val backgroundColor = if (isDarkTheme) Color(0xFF1C1C1E) else Color(0xFFFFFFFF)\n        Column (\n          modifier = Modifier\n              .fillMaxSize()\n              .padding(paddingValues = paddingValues)\n              .padding(horizontal = 16.dp)\n              .padding(top = 8.dp)\n        ) {\n            Column(\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .background(backgroundColor, RoundedCornerShape(14.dp)),\n                horizontalAlignment = Alignment.CenterHorizontally\n            ) {\n                LongPressActionElement(\n                    name = \"Noise Control\",\n                    selected = longPressAction == StemAction.CYCLE_NOISE_CONTROL_MODES,\n                    onClick = {\n                        longPressAction = StemAction.CYCLE_NOISE_CONTROL_MODES\n                        sharedPreferences.edit().putString(prefKey, StemAction.CYCLE_NOISE_CONTROL_MODES.name).apply()\n                    },\n                    isFirst = true,\n                    isLast = false\n                )\n                RightDividerNoIcon()\n                LongPressActionElement(\n                    name = \"Digital Assistant\",\n                    selected = longPressAction == StemAction.DIGITAL_ASSISTANT,\n                    onClick = {\n                        longPressAction = StemAction.DIGITAL_ASSISTANT\n                        sharedPreferences.edit().putString(prefKey, StemAction.DIGITAL_ASSISTANT.name).apply()\n                    },\n                    isFirst = false,\n                    isLast = true\n                )\n            }\n\n            if (longPressAction == StemAction.CYCLE_NOISE_CONTROL_MODES) {\n                Text(\n                    text = \"NOISE CONTROL\",\n                    style = TextStyle(\n                        fontSize = 14.sp,\n                        fontWeight = FontWeight.Light,\n                        color = textColor.copy(alpha = 0.6f),\n                    ),\n                    fontFamily = FontFamily(Font(R.font.sf_pro)),\n                    modifier = Modifier\n                        .padding(top = 32.dp, bottom = 4.dp)\n                        .padding(horizontal = 8.dp)\n                )\n\n                Column(\n                    modifier = Modifier\n                        .fillMaxWidth()\n                        .background(backgroundColor, RoundedCornerShape(14.dp)),\n                    horizontalAlignment = Alignment.CenterHorizontally\n                ) {\n                    val offListeningModeValue = ServiceManager.getService()!!.aacpManager.controlCommandStatusList.find {\n                        it.identifier == AACPManager.Companion.ControlCommandIdentifiers.ALLOW_OFF_OPTION\n                    }?.value?.takeIf { it.isNotEmpty() }?.get(0)\n                    val offListeningMode = offListeningModeValue == 1.toByte()\n                    LongPressElement(\n                        name = \"Off\",\n                        enabled = offListeningMode,\n                        resourceId =  R.drawable.noise_cancellation,\n                        isFirst = true)\n                    if (offListeningMode) RightDivider()\n                    LongPressElement(\n                        name = \"Transparency\",\n                        resourceId = R.drawable.transparency,\n                        isFirst = !offListeningMode)\n                    RightDivider()\n                    LongPressElement(\n                        name = \"Adaptive\",\n                        resourceId = R.drawable.adaptive)\n                    RightDivider()\n                    LongPressElement(\n                        name = \"Noise Cancellation\",\n                        resourceId = R.drawable.noise_cancellation,\n                        isLast = true)\n                }\n                Text(\n                    \"Press and hold the stem to cycle between the selected noise control modes.\",\n                    fontSize = 16.sp,\n                    fontFamily = FontFamily(Font(R.font.sf_pro)),\n                    color = textColor.copy(alpha = 0.6f),\n                    modifier = Modifier\n                        .padding(start = 16.dp, top = 4.dp)\n                )\n            }\n        }\n    }\n    Log.d(\"PressAndHoldSettingsScreen\", \"Current byte: ${ServiceManager.getService()!!.aacpManager.controlCommandStatusList.find {\n        it.identifier == AACPManager.Companion.ControlCommandIdentifiers.LISTENING_MODE_CONFIGS\n    }?.value?.takeIf { it.isNotEmpty() }?.get(0)?.toString(2)}\")\n}\n\n@Composable\nfun LongPressElement(name: String, enabled: Boolean = true, resourceId: Int, isFirst: Boolean = false, isLast: Boolean = false) {\n    val bit = when (name) {\n        \"Off\" -> 0x01\n        \"Transparency\" -> 0x02\n        \"Noise Cancellation\" -> 0x04\n        \"Adaptive\" -> 0x08\n        else -> -1\n    }\n    val context = LocalContext.current\n\n    val currentByteValue = ServiceManager.getService()!!.aacpManager.controlCommandStatusList.find {\n        it.identifier == AACPManager.Companion.ControlCommandIdentifiers.LISTENING_MODE_CONFIGS\n    }?.value?.takeIf { it.isNotEmpty() }?.get(0)\n\n    val savedByte = context.getSharedPreferences(\"settings\", Context.MODE_PRIVATE).getInt(\"long_press_byte\", 0b0101.toInt())\n    val byteValue = currentByteValue ?: (savedByte and 0xFF).toByte()\n\n    val isChecked = (byteValue.toInt() and bit) != 0\n    val checked = remember { mutableStateOf(isChecked) }\n\n    Log.d(\"PressAndHoldSettingsScreen\", \"LongPressElement: $name, checked: ${checked.value}, byteValue: ${byteValue.toInt()}, in bits: ${byteValue.toInt().toString(2)}\")\n    val darkMode = isSystemInDarkTheme()\n    val textColor = if (darkMode) Color.White else Color.Black\n    val desc = when (name) {\n        \"Off\" -> \"Turns off noise management\"\n        \"Noise Cancellation\" -> \"Blocks out external sounds\"\n        \"Transparency\" -> \"Lets in external sounds\"\n        \"Adaptive\" -> \"Dynamically adjust external noise\"\n        else -> \"\"\n    }\n\n    fun countEnabledModes(byteValue: Int): Int {\n        var count = 0\n        if ((byteValue and 0x01) != 0) count++\n        if ((byteValue and 0x02) != 0) count++\n        if ((byteValue and 0x04) != 0) count++\n        if ((byteValue and 0x08) != 0) count++\n\n        Log.d(\"PressAndHoldSettingsScreen\", \"Byte: ${byteValue.toString(2)} Enabled modes: $count\")\n        return count\n    }\n\n    fun valueChanged(value: Boolean = !checked.value) {\n        val latestByteValue = ServiceManager.getService()!!.aacpManager.controlCommandStatusList.find {\n            it.identifier == AACPManager.Companion.ControlCommandIdentifiers.LISTENING_MODE_CONFIGS\n        }?.value?.takeIf { it.isNotEmpty() }?.get(0)\n\n        val currentValue = (latestByteValue?.toInt() ?: byteValue.toInt()) and 0xFF\n\n        Log.d(\"PressAndHoldSettingsScreen\", \"Current value: $currentValue (binary: ${Integer.toBinaryString(currentValue)}), bit: $bit, value: $value\")\n\n        if (!value) {\n            val newValue = currentValue and bit.inv()\n\n            Log.d(\"PressAndHoldSettingsScreen\", \"Bit to disable: $bit, inverted: ${bit.inv()}, after AND: ${Integer.toBinaryString(newValue)}\")\n\n            val modeCount = countEnabledModes(newValue)\n\n            Log.d(\"PressAndHoldSettingsScreen\", \"After disabling, enabled modes count: $modeCount\")\n\n            if (modeCount < 2) {\n                Log.d(\"PressAndHoldSettingsScreen\", \"Cannot disable $name mode - need at least 2 modes enabled\")\n                return\n            }\n\n            val updatedByte = newValue.toByte()\n\n            Log.d(\"PressAndHoldSettingsScreen\", \"Sending updated byte: ${updatedByte.toInt() and 0xFF} (binary: ${Integer.toBinaryString(updatedByte.toInt() and 0xFF)})\")\n\n            ServiceManager.getService()!!.aacpManager.sendControlCommand(\n                AACPManager.Companion.ControlCommandIdentifiers.LISTENING_MODE_CONFIGS.value,\n                updatedByte\n            )\n\n            context.getSharedPreferences(\"settings\", Context.MODE_PRIVATE).edit()\n                .putInt(\"long_press_byte\", newValue).apply()\n\n            checked.value = false\n            Log.d(\"PressAndHoldSettingsScreen\", \"Updated: $name, enabled: false, byte: ${updatedByte.toInt() and 0xFF}, bits: ${Integer.toBinaryString(updatedByte.toInt() and 0xFF)}\")\n        } else {\n            val newValue = currentValue or bit\n            val updatedByte = newValue.toByte()\n\n            ServiceManager.getService()!!.aacpManager.sendControlCommand(\n                AACPManager.Companion.ControlCommandIdentifiers.LISTENING_MODE_CONFIGS.value,\n                updatedByte\n            )\n\n            context.getSharedPreferences(\"settings\", Context.MODE_PRIVATE).edit()\n                .putInt(\"long_press_byte\", newValue).apply()\n\n            checked.value = true\n            Log.d(\"PressAndHoldSettingsScreen\", \"Updated: $name, enabled: true, byte: ${updatedByte.toInt() and 0xFF}, bits: ${newValue.toString(2)}\")\n        }\n    }\n\n    val shape = when {\n        isFirst -> RoundedCornerShape(topStart = 14.dp, topEnd = 14.dp)\n        isLast -> RoundedCornerShape(bottomStart = 14.dp, bottomEnd = 14.dp)\n        else -> RoundedCornerShape(0.dp)\n    }\n    var backgroundColor by remember { mutableStateOf(if (darkMode) Color(0xFF1C1C1E) else Color(0xFFFFFFFF)) }\n    val animatedBackgroundColor by animateColorAsState(targetValue = backgroundColor, animationSpec = tween(durationMillis = 500))\n    if (!enabled) {\n        valueChanged(false)\n    } else {\n        Row(\n            modifier = Modifier\n                .height(72.dp)\n                .background(animatedBackgroundColor, shape)\n                .pointerInput(Unit) {\n                    detectTapGestures(\n                        onPress = {\n                            backgroundColor = if (darkMode) Color(0x40888888) else Color(0x40D9D9D9)\n                            tryAwaitRelease()\n                            backgroundColor = if (darkMode) Color(0xFF1C1C1E) else Color(0xFFFFFFFF)\n                            valueChanged()\n                        },\n                    )\n                }\n                .padding(horizontal = 16.dp, vertical = 0.dp),\n            verticalAlignment = Alignment.CenterVertically,\n            horizontalArrangement = Arrangement.SpaceBetween\n        ) {\n            Icon(\n                painter = painterResource(resourceId),\n                contentDescription = \"Icon\",\n                tint = Color(0xFF007AFF),\n                modifier = Modifier\n                    .height(48.dp)\n                    .wrapContentWidth()\n            )\n            Column (\n                modifier = Modifier\n                    .weight(1f)\n                    .padding(vertical = 2.dp)\n                    .padding(start = 8.dp)\n            )\n            {\n                Text(\n                    name,\n                    fontSize = 16.sp,\n                    fontFamily = FontFamily(Font(R.font.sf_pro)),\n                )\n                Text (\n                    desc,\n                    fontSize = 14.sp,\n                    color = textColor.copy(alpha = 0.6f),\n                    fontFamily = FontFamily(Font(R.font.sf_pro)),\n                )\n            }\n            Checkbox(\n                checked = checked.value,\n                onCheckedChange = { valueChanged() },\n                colors = CheckboxDefaults.colors().copy(\n                    checkedCheckmarkColor = Color(0xFF007AFF),\n                    uncheckedCheckmarkColor = Color.Transparent,\n                    checkedBoxColor = Color.Transparent,\n                    uncheckedBoxColor = Color.Transparent,\n                    checkedBorderColor = Color.Transparent,\n                    uncheckedBorderColor = Color.Transparent,\n                    disabledBorderColor = Color.Transparent,\n                    disabledCheckedBoxColor = Color.Transparent,\n                    disabledUncheckedBoxColor = Color.Transparent,\n                    disabledUncheckedBorderColor = Color.Transparent\n                ),\n                modifier = Modifier\n                    .height(24.dp)\n                    .scale(1.5f),\n            )\n        }\n    }\n}\n\n@Composable\nfun LongPressActionElement(\n    name: String,\n    selected: Boolean,\n    onClick: () -> Unit,\n    isFirst: Boolean = false,\n    isLast: Boolean = false\n) {\n    val darkMode = isSystemInDarkTheme()\n    val shape = when {\n        isFirst -> RoundedCornerShape(topStart = 14.dp, topEnd = 14.dp)\n        isLast -> RoundedCornerShape(bottomStart = 14.dp, bottomEnd = 14.dp)\n        else -> RoundedCornerShape(0.dp)\n    }\n    var backgroundColor by remember { mutableStateOf(if (darkMode) Color(0xFF1C1C1E) else Color(0xFFFFFFFF)) }\n    val animatedBackgroundColor by animateColorAsState(targetValue = backgroundColor, animationSpec = tween(durationMillis = 500))\n    Row(\n        modifier = Modifier\n            .height(48.dp)\n            .background(animatedBackgroundColor, shape)\n            .pointerInput(Unit) {\n                detectTapGestures(\n                    onPress = {\n                        backgroundColor = if (darkMode) Color(0x40888888) else Color(0x40D9D9D9)\n                        tryAwaitRelease()\n                        backgroundColor = if (darkMode) Color(0xFF1C1C1E) else Color(0xFFFFFFFF)\n                        onClick()\n                    }\n                )\n            }\n            .padding(horizontal = 16.dp, vertical = 0.dp),\n        verticalAlignment = Alignment.CenterVertically,\n        horizontalArrangement = Arrangement.SpaceBetween\n    ) {\n        Text(\n            name,\n            fontSize = 16.sp,\n            fontFamily = FontFamily(Font(R.font.sf_pro)),\n            modifier = Modifier\n                .weight(1f)\n                .padding(start = 4.dp)\n        )\n        Checkbox(\n            checked = selected,\n            onCheckedChange = { onClick() },\n            colors = CheckboxDefaults.colors().copy(\n                checkedCheckmarkColor = Color(0xFF007AFF),\n                uncheckedCheckmarkColor = Color.Transparent,\n                checkedBoxColor = Color.Transparent,\n                uncheckedBoxColor = Color.Transparent,\n                checkedBorderColor = Color.Transparent,\n                uncheckedBorderColor = Color.Transparent,\n                disabledBorderColor = Color.Transparent,\n                disabledCheckedBoxColor = Color.Transparent,\n                disabledUncheckedBoxColor = Color.Transparent,\n                disabledUncheckedBorderColor = Color.Transparent\n            ),\n            modifier = Modifier\n                .height(24.dp)\n                .scale(1.5f),\n        )\n    }\n}\n"
        },
        {
          "name": "Onboarding.kt",
          "ext": ".kt",
          "size": 31200,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n *\n * Copyright (C) 2025 LibrePods contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\npackage me.kavishdevar.librepods.screens\n\nimport android.content.Context\nimport android.util.Log\nimport androidx.compose.animation.AnimatedContent\nimport androidx.compose.animation.core.animateFloatAsState\nimport androidx.compose.animation.fadeIn\nimport androidx.compose.animation.fadeOut\nimport androidx.compose.animation.togetherWith\nimport androidx.compose.foundation.isSystemInDarkTheme\nimport androidx.compose.foundation.layout.Arrangement\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Spacer\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.size\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.Check\nimport androidx.compose.material.icons.filled.Clear\nimport androidx.compose.material.icons.filled.MoreVert\nimport androidx.compose.material.icons.filled.Settings\nimport androidx.compose.material3.AlertDialog\nimport androidx.compose.material3.Button\nimport androidx.compose.material3.ButtonDefaults\nimport androidx.compose.material3.Card\nimport androidx.compose.material3.CardDefaults\nimport androidx.compose.material3.CenterAlignedTopAppBar\nimport androidx.compose.material3.CircularProgressIndicator\nimport androidx.compose.material3.DropdownMenu\nimport androidx.compose.material3.DropdownMenuItem\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.IconButton\nimport androidx.compose.material3.LinearProgressIndicator\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TextButton\nimport androidx.compose.material3.TopAppBarDefaults\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.collectAsState\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.graphics.StrokeCap\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.text.TextStyle\nimport androidx.compose.ui.text.font.Font\nimport androidx.compose.ui.text.font.FontFamily\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.text.style.TextAlign\nimport androidx.compose.ui.tooling.preview.Preview\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport androidx.navigation.NavController\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.withContext\nimport me.kavishdevar.librepods.R\nimport me.kavishdevar.librepods.utils.RadareOffsetFinder\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun Onboarding(navController: NavController, activityContext: Context) {\n    val isDarkTheme = isSystemInDarkTheme()\n    val backgroundColor = if (isDarkTheme) Color(0xFF1C1C1E) else Color.White\n    val textColor = if (isDarkTheme) Color.White else Color.Black\n    val accentColor = if (isDarkTheme) Color(0xFF007AFF) else Color(0xFF3C6DF5)\n\n    val radareOffsetFinder = remember { RadareOffsetFinder(activityContext) }\n    val progressState by radareOffsetFinder.progressState.collectAsState()\n    var isComplete by remember { mutableStateOf(false) }\n    var hasStarted by remember { mutableStateOf(false) }\n    var rootCheckPassed by remember { mutableStateOf(false) }\n    var checkingRoot by remember { mutableStateOf(false) }\n    var rootCheckFailed by remember { mutableStateOf(false) }\n    var moduleEnabled by remember { mutableStateOf(false) }\n    var bluetoothToggled by remember { mutableStateOf(false) }\n\n    var showMenu by remember { mutableStateOf(false) }\n    var showSkipDialog by remember { mutableStateOf(false) }\n\n    fun checkRootAccess() {\n        checkingRoot = true\n        rootCheckFailed = false\n        kotlinx.coroutines.MainScope().launch {\n            withContext(Dispatchers.IO) {\n                try {\n                    val process = Runtime.getRuntime().exec(\"su -c id\")\n                    val exitValue = process.waitFor()\n                    withContext(Dispatchers.Main) {\n                        rootCheckPassed = (exitValue == 0)\n                        rootCheckFailed = (exitValue != 0)\n                        checkingRoot = false\n                    }\n                } catch (e: Exception) {\n                    Log.e(\"Onboarding\", \"Root check failed\", e)\n                    withContext(Dispatchers.Main) {\n                        rootCheckPassed = false\n                        rootCheckFailed = true\n                        checkingRoot = false\n                    }\n                }\n            }\n        }\n    }\n\n    LaunchedEffect(hasStarted) {\n        if (hasStarted && rootCheckPassed) {\n            Log.d(\"Onboarding\", \"Checking if hook offset is available...\")\n            val isHookReady = radareOffsetFinder.isHookOffsetAvailable()\n            Log.d(\"Onboarding\", \"Hook offset ready: $isHookReady\")\n\n            if (isHookReady) {\n                Log.d(\"Onboarding\", \"Hook is ready\")\n                isComplete = true\n            } else {\n                Log.d(\"Onboarding\", \"Hook not ready, starting setup process...\")\n                withContext(Dispatchers.IO) {\n                    radareOffsetFinder.setupAndFindOffset()\n                }\n            }\n        }\n    }\n\n    LaunchedEffect(progressState) {\n        if (progressState is RadareOffsetFinder.ProgressState.Success) {\n            isComplete = true\n        }\n    }\n\n    Scaffold(\n        topBar = {\n            CenterAlignedTopAppBar(\n                title = {\n                    Text(\n                        \"Setting Up\",\n                        fontFamily = FontFamily(Font(R.font.sf_pro)),\n                        fontWeight = FontWeight.Medium\n                    )\n                },\n                colors = TopAppBarDefaults.topAppBarColors(\n                    containerColor = Color.Transparent\n                ),\n                actions = {\n                    Box {\n                        IconButton(onClick = { showMenu = true }) {\n                            Icon(\n                                imageVector = Icons.Default.MoreVert,\n                                contentDescription = \"More Options\"\n                            )\n                        }\n                        DropdownMenu(\n                            expanded = showMenu,\n                            onDismissRequest = { showMenu = false }\n                        ) {\n                            DropdownMenuItem(\n                                text = { Text(\"Skip Setup\") },\n                                onClick = {\n                                    showMenu = false\n                                    showSkipDialog = true\n                                }\n                            )\n                        }\n                    }\n                }\n            )\n        },\n        containerColor = if (isDarkTheme) Color(0xFF000000) else Color(0xFFF2F2F7)\n    ) { paddingValues ->\n        Column(\n            modifier = Modifier\n                .fillMaxSize()\n                .padding(paddingValues)\n                .padding(16.dp),\n            horizontalAlignment = Alignment.CenterHorizontally,\n            verticalArrangement = Arrangement.spacedBy(16.dp)\n        ) {\n            Spacer(modifier = Modifier.height(16.dp))\n\n            Card(\n                modifier = Modifier.fillMaxWidth(),\n                colors = CardDefaults.cardColors(containerColor = backgroundColor),\n                shape = RoundedCornerShape(12.dp)\n            ) {\n                Column(\n                    modifier = Modifier\n                        .fillMaxWidth()\n                        .padding(24.dp),\n                    horizontalAlignment = Alignment.CenterHorizontally\n                ) {\n                    if (!rootCheckPassed && !hasStarted) {\n                        Icon(\n                            imageVector = Icons.Default.Settings,\n                            contentDescription = \"Root Access\",\n                            tint = accentColor,\n                            modifier = Modifier.size(50.dp)\n                        )\n\n                        Spacer(modifier = Modifier.height(24.dp))\n\n                        Text(\n                            text = \"Root Access Required\",\n                            style = TextStyle(\n                                fontSize = 22.sp,\n                                fontWeight = FontWeight.Bold,\n                                textAlign = TextAlign.Center,\n                                fontFamily = FontFamily(Font(R.font.sf_pro)),\n                                color = textColor\n                            )\n                        )\n\n                        Spacer(modifier = Modifier.height(8.dp))\n\n                        Text(\n                            text = \"This app needs root access to hook onto the Bluetooth library\",\n                            style = TextStyle(\n                                fontSize = 16.sp,\n                                fontWeight = FontWeight.Normal,\n                                textAlign = TextAlign.Center,\n                                fontFamily = FontFamily(Font(R.font.sf_pro)),\n                                color = textColor.copy(alpha = 0.7f)\n                            )\n                        )\n\n                        if (rootCheckFailed) {\n                            Spacer(modifier = Modifier.height(8.dp))\n                            Text(\n                                text = \"Root access was denied. Please grant root permissions.\",\n                                style = TextStyle(\n                                    fontSize = 14.sp,\n                                    fontWeight = FontWeight.Normal,\n                                    textAlign = TextAlign.Center,\n                                    fontFamily = FontFamily(Font(R.font.sf_pro)),\n                                    color = Color(0xFFFF453A)\n                                )\n                            )\n                        }\n\n                        Spacer(modifier = Modifier.height(24.dp))\n\n                        Button(\n                            onClick = { checkRootAccess() },\n                            modifier = Modifier\n                                .fillMaxWidth()\n                                .height(50.dp),\n                            colors = ButtonDefaults.buttonColors(\n                                containerColor = accentColor\n                            ),\n                            shape = RoundedCornerShape(8.dp),\n                            enabled = !checkingRoot\n                        ) {\n                            if (checkingRoot) {\n                                CircularProgressIndicator(\n                                    modifier = Modifier.size(24.dp),\n                                    color = Color.White,\n                                    strokeWidth = 2.dp\n                                )\n                            } else {\n                                Text(\n                                    \"Check Root Access\",\n                                    style = TextStyle(\n                                        fontSize = 16.sp,\n                                        fontWeight = FontWeight.Medium,\n                                        fontFamily = FontFamily(Font(R.font.sf_pro))\n                                    ),\n                                )\n                            }\n                        }\n                    } else {\n                        StatusIcon(if (hasStarted) progressState else RadareOffsetFinder.ProgressState.Idle, isDarkTheme)\n\n                        Spacer(modifier = Modifier.height(24.dp))\n\n                        AnimatedContent(\n                            targetState = if (hasStarted) getStatusTitle(progressState, isComplete, moduleEnabled, bluetoothToggled) else \"Setup Required\",\n                            transitionSpec = { fadeIn() togetherWith fadeOut() }\n                        ) { text ->\n                            Text(\n                                text = text,\n                                style = TextStyle(\n                                    fontSize = 22.sp,\n                                    fontWeight = FontWeight.Bold,\n                                    textAlign = TextAlign.Center,\n                                    fontFamily = FontFamily(Font(R.font.sf_pro)),\n                                    color = textColor\n                                )\n                            )\n                        }\n\n                        Spacer(modifier = Modifier.height(8.dp))\n\n                        AnimatedContent(\n                            targetState = if (hasStarted)\n                                getStatusDescription(progressState, isComplete, moduleEnabled, bluetoothToggled)\n                            else\n                                \"AirPods functionality requires one-time setup for hooking into Bluetooth library\",\n                            transitionSpec = { fadeIn() togetherWith fadeOut() }\n                        ) { text ->\n                            Text(\n                                text = text,\n                                style = TextStyle(\n                                    fontSize = 16.sp,\n                                    fontWeight = FontWeight.Normal,\n                                    textAlign = TextAlign.Center,\n                                    fontFamily = FontFamily(Font(R.font.sf_pro)),\n                                    color = textColor.copy(alpha = 0.7f)\n                                )\n                            )\n                        }\n\n                        Spacer(modifier = Modifier.height(24.dp))\n\n                        if (!hasStarted) {\n                            Button(\n                                onClick = { hasStarted = true },\n                                modifier = Modifier\n                                    .fillMaxWidth()\n                                    .height(50.dp),\n                                colors = ButtonDefaults.buttonColors(\n                                    containerColor = accentColor\n                                ),\n                                shape = RoundedCornerShape(8.dp)\n                            ) {\n                                Text(\n                                    \"Start Setup\",\n                                    style = TextStyle(\n                                        fontSize = 16.sp,\n                                        fontWeight = FontWeight.Medium,\n                                        fontFamily = FontFamily(Font(R.font.sf_pro))\n                                    ),\n                                )\n                            }\n                        } else {\n                            when (progressState) {\n                                is RadareOffsetFinder.ProgressState.DownloadProgress -> {\n                                    val progress = (progressState as RadareOffsetFinder.ProgressState.DownloadProgress).progress\n                                    val animatedProgress by animateFloatAsState(\n                                        targetValue = progress,\n                                        label = \"Download Progress\"\n                                    )\n                                    Column(\n                                        modifier = Modifier.fillMaxWidth(),\n                                        horizontalAlignment = Alignment.CenterHorizontally\n                                    ) {\n                                        LinearProgressIndicator(\n                                            progress = { animatedProgress },\n                                            modifier = Modifier\n                                                .fillMaxWidth()\n                                                .height(8.dp),\n                                            strokeCap = StrokeCap.Round,\n                                            color = accentColor\n                                        )\n\n                                        Spacer(modifier = Modifier.height(8.dp))\n\n                                        Text(\n                                            text = \"${(progress * 100).toInt()}%\",\n                                            style = TextStyle(\n                                                fontSize = 14.sp,\n                                                fontWeight = FontWeight.Medium,\n                                                fontFamily = FontFamily(Font(R.font.sf_pro)),\n                                                color = textColor.copy(alpha = 0.6f)\n                                            )\n                                        )\n                                    }\n                                }\n                                is RadareOffsetFinder.ProgressState.Success -> {\n                                    if (!moduleEnabled) {\n                                        Button(\n                                            onClick = { moduleEnabled = true },\n                                            modifier = Modifier\n                                                .fillMaxWidth()\n                                                .height(50.dp),\n                                            colors = ButtonDefaults.buttonColors(\n                                                containerColor = accentColor\n                                            ),\n                                            shape = RoundedCornerShape(8.dp)\n                                        ) {\n                                            Text(\n                                                \"I've Enabled/Reactivated the Module\",\n                                                style = TextStyle(\n                                                    fontSize = 16.sp,\n                                                    fontWeight = FontWeight.Medium,\n                                                    fontFamily = FontFamily(Font(R.font.sf_pro))\n                                                ),\n                                            )\n                                        }\n                                    } else if (!bluetoothToggled) {\n                                        Button(\n                                            onClick = { bluetoothToggled = true },\n                                            modifier = Modifier\n                                                .fillMaxWidth()\n                                                .height(50.dp),\n                                            colors = ButtonDefaults.buttonColors(\n                                                containerColor = accentColor\n                                            ),\n                                            shape = RoundedCornerShape(8.dp)\n                                        ) {\n                                            Text(\n                                                \"I've Toggled Bluetooth\",\n                                                style = TextStyle(\n                                                    fontSize = 16.sp,\n                                                    fontWeight = FontWeight.Medium,\n                                                    fontFamily = FontFamily(Font(R.font.sf_pro))\n                                                ),\n                                            )\n                                        }\n                                    } else {\n                                        Button(\n                                            onClick = {\n                                                navController.navigate(\"settings\") {\n                                                    popUpTo(\"onboarding\") { inclusive = true }\n                                                }\n                                            },\n                                            modifier = Modifier\n                                                .fillMaxWidth()\n                                                .height(50.dp),\n                                            colors = ButtonDefaults.buttonColors(\n                                                containerColor = accentColor\n                                            ),\n                                            shape = RoundedCornerShape(8.dp)\n                                        ) {\n                                            Text(\n                                                \"Continue to Settings\",\n                                                style = TextStyle(\n                                                    fontSize = 16.sp,\n                                                    fontWeight = FontWeight.Medium,\n                                                    fontFamily = FontFamily(Font(R.font.sf_pro))\n                                                ),\n                                            )\n                                        }\n                                    }\n                                }\n                                is RadareOffsetFinder.ProgressState.Idle,\n                                is RadareOffsetFinder.ProgressState.Error -> {\n                                    // No specific UI for these states\n                                }\n                                else -> {\n                                    LinearProgressIndicator(\n                                        modifier = Modifier\n                                            .fillMaxWidth()\n                                            .height(8.dp),\n                                        strokeCap = StrokeCap.Round,\n                                        color = accentColor\n                                    )\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            Spacer(modifier = Modifier.weight(1f))\n\n            if (progressState is RadareOffsetFinder.ProgressState.Error && !isComplete && hasStarted) {\n                Button(\n                    onClick = {\n                        Log.d(\"Onboarding\", \"Trying to find offset again...\")\n                        kotlinx.coroutines.MainScope().launch {\n                            withContext(Dispatchers.IO) {\n                                radareOffsetFinder.setupAndFindOffset()\n                            }\n                        }\n                    },\n                    modifier = Modifier\n                        .fillMaxWidth()\n                        .height(55.dp),\n                    colors = ButtonDefaults.buttonColors(\n                        containerColor = accentColor\n                    ),\n                    shape = RoundedCornerShape(8.dp)\n                ) {\n                    Text(\n                        \"Try Again\",\n                        style = TextStyle(\n                            fontSize = 16.sp,\n                            fontWeight = FontWeight.Medium,\n                            fontFamily = FontFamily(Font(R.font.sf_pro))\n                        ),\n                    )\n                }\n            }\n        }\n\n        if (showSkipDialog) {\n            AlertDialog(\n                onDismissRequest = { showSkipDialog = false },\n                title = { Text(\"Skip Setup\") },\n                text = {\n                    Text(\n                        \"Have you installed the root module that patches the Bluetooth library directly? This option is for users who have manually patched their system instead of using the dynamic hook.\",\n                        style = TextStyle(\n                            fontSize = 16.sp,\n                            fontFamily = FontFamily(Font(R.font.sf_pro))\n                        )\n                    )\n                },\n                confirmButton = {\n                    val sharedPreferences = activityContext.getSharedPreferences(\"settings\", Context.MODE_PRIVATE)\n                    TextButton(\n                        onClick = {\n                            showSkipDialog = false\n                            RadareOffsetFinder.clearHookOffsets()\n                            sharedPreferences.edit().putBoolean(\"skip_setup\", true).apply()\n                            navController.navigate(\"settings\") {\n                                popUpTo(\"onboarding\") { inclusive = true }\n                            }\n                        }\n                    ) {\n                        Text(\n                            \"Yes, Skip Setup\",\n                            color = accentColor,\n                            fontWeight = FontWeight.Bold\n                        )\n                    }\n                },\n                dismissButton = {\n                    TextButton(\n                        onClick = { showSkipDialog = false }\n                    ) {\n                        Text(\"Cancel\")\n                    }\n                },\n                containerColor = backgroundColor,\n                textContentColor = textColor,\n                titleContentColor = textColor\n            )\n        }\n    }\n}\n\n@Composable\nprivate fun StatusIcon(\n    progressState: RadareOffsetFinder.ProgressState,\n    isDarkTheme: Boolean\n) {\n    val accentColor = if (isDarkTheme) Color(0xFF007AFF) else Color(0xFF3C6DF5)\n    val errorColor = if (isDarkTheme) Color(0xFFFF453A) else Color(0xFFFF3B30)\n    val successColor = if (isDarkTheme) Color(0xFF30D158) else Color(0xFF34C759)\n\n    Box(\n        modifier = Modifier.size(80.dp),\n        contentAlignment = Alignment.Center\n    ) {\n        when (progressState) {\n            is RadareOffsetFinder.ProgressState.Error -> {\n                Icon(\n                    imageVector = Icons.Default.Clear,\n                    contentDescription = \"Error\",\n                    tint = errorColor,\n                    modifier = Modifier.size(50.dp)\n                )\n            }\n            is RadareOffsetFinder.ProgressState.Success -> {\n                Icon(\n                    imageVector = Icons.Default.Check,\n                    contentDescription = \"Success\",\n                    tint = successColor,\n                    modifier = Modifier.size(50.dp)\n                )\n            }\n            is RadareOffsetFinder.ProgressState.Idle -> {\n                Icon(\n                    imageVector = Icons.Default.Settings,\n                    contentDescription = \"Settings\",\n                    tint = accentColor,\n                    modifier = Modifier.size(50.dp)\n                )\n            }\n            else -> {\n                CircularProgressIndicator(\n                    modifier = Modifier.size(50.dp),\n                    color = accentColor,\n                    strokeWidth = 4.dp\n                )\n            }\n        }\n    }\n}\n\nprivate fun getStatusTitle(\n    state: RadareOffsetFinder.ProgressState,\n    isComplete: Boolean,\n    moduleEnabled: Boolean,\n    bluetoothToggled: Boolean\n): String {\n    return when (state) {\n        is RadareOffsetFinder.ProgressState.Success -> {\n            when {\n                !moduleEnabled -> \"Enable Xposed Module\"\n                !bluetoothToggled -> \"Toggle Bluetooth\"\n                else -> \"Setup Complete\"\n            }\n        }\n        is RadareOffsetFinder.ProgressState.Idle -> \"Getting Ready\"\n        is RadareOffsetFinder.ProgressState.CheckingExisting -> \"Checking if radare2 already downloaded\"\n        is RadareOffsetFinder.ProgressState.Downloading -> \"Downloading radare2\"\n        is RadareOffsetFinder.ProgressState.DownloadProgress -> \"Downloading radare2\"\n        is RadareOffsetFinder.ProgressState.Extracting -> \"Extracting radare2\"\n        is RadareOffsetFinder.ProgressState.MakingExecutable -> \"Setting executable permissions\"\n        is RadareOffsetFinder.ProgressState.FindingOffset -> \"Finding function offset\"\n        is RadareOffsetFinder.ProgressState.SavingOffset -> \"Saving offset\"\n        is RadareOffsetFinder.ProgressState.Cleaning -> \"Cleaning Up\"\n        is RadareOffsetFinder.ProgressState.Error -> \"Setup Failed\"\n    }\n}\n\nprivate fun getStatusDescription(\n    state: RadareOffsetFinder.ProgressState,\n    isComplete: Boolean,\n    moduleEnabled: Boolean,\n    bluetoothToggled: Boolean\n): String {\n    return when (state) {\n        is RadareOffsetFinder.ProgressState.Success -> {\n            when {\n                !moduleEnabled -> \"Please enable the LibrePods Xposed module in your Xposed manager (e.g. LSPosed). If already enabled, disable and re-enable it.\"\n                !bluetoothToggled -> \"Please turn off and then turn on Bluetooth to apply the changes.\"\n                else -> \"All set! You can now use your AirPods with enhanced functionality.\"\n            }\n        }\n        is RadareOffsetFinder.ProgressState.Idle -> \"Preparing\"\n        is RadareOffsetFinder.ProgressState.CheckingExisting -> \"Checking if radare2 are already installed\"\n        is RadareOffsetFinder.ProgressState.Downloading -> \"Starting radare2 download\"\n        is RadareOffsetFinder.ProgressState.DownloadProgress -> \"Downloading radare2\"\n        is RadareOffsetFinder.ProgressState.Extracting -> \"Extracting radare2\"\n        is RadareOffsetFinder.ProgressState.MakingExecutable -> \"Setting executable permissions on radare2 binaries\"\n        is RadareOffsetFinder.ProgressState.FindingOffset -> \"Looking for the required Bluetooth function in system libraries\"\n        is RadareOffsetFinder.ProgressState.SavingOffset -> \"Saving the function offset\"\n        is RadareOffsetFinder.ProgressState.Cleaning -> \"Removing temporary extracted files\"\n        is RadareOffsetFinder.ProgressState.Error -> state.message\n    }\n}\n\n@Preview\n@Composable\nfun OnboardingPreview() {\n    Onboarding(navController = NavController(LocalContext.current), activityContext = LocalContext.current)\n}\n\nprivate suspend fun delay(timeMillis: Long) {\n    kotlinx.coroutines.delay(timeMillis)\n}\n"
        },
        {
          "name": "AppSettingsScreen.kt",
          "ext": ".kt",
          "size": 65599,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n *\n * Copyright (C) 2025 LibrePods contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\nimport androidx.compose.foundation.layout.*\npackage me.kavishdevar.librepods.screens\nimport androidx.compose.material3.*\nimport android.content.Context\nimport android.widget.Toast\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.clickable\nimport androidx.compose.foundation.interaction.MutableInteractionSource\nimport androidx.compose.foundation.isSystemInDarkTheme\nimport androidx.compose.foundation.layout.Arrangement\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.Spacer\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.size\nimport androidx.compose.foundation.layout.width\nimport androidx.compose.foundation.rememberScrollState\nimport androidx.compose.foundation.shape.CircleShape\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.foundation.text.KeyboardOptions\nimport androidx.compose.foundation.verticalScroll\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.automirrored.filled.KeyboardArrowLeft\nimport androidx.compose.material.icons.filled.Refresh\nimport androidx.compose.material3.AlertDialog\nimport androidx.compose.material3.Button\nimport androidx.compose.material3.ButtonDefaults\nimport androidx.compose.material3.CenterAlignedTopAppBar\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.OutlinedTextField\nimport androidx.compose.material3.OutlinedTextFieldDefaults\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Slider\nimport androidx.compose.material3.SliderDefaults\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TextButton\nimport androidx.compose.material3.TextField\nimport androidx.compose.material3.TextFieldDefaults\nimport androidx.compose.material3.TopAppBarDefaults\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableFloatStateOf\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.drawBehind\nimport androidx.compose.ui.draw.scale\nimport androidx.compose.ui.draw.shadow\nimport androidx.compose.ui.geometry.Offset\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.input.nestedscroll.nestedScroll\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.text.TextStyle\nimport androidx.compose.ui.text.font.Font\nimport androidx.compose.ui.text.font.FontFamily\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.text.input.KeyboardCapitalization\nimport androidx.compose.ui.text.input.KeyboardType\nimport androidx.compose.ui.text.style.TextOverflow\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport androidx.navigation.NavController\nimport dev.chrisbanes.haze.HazeEffectScope\nimport dev.chrisbanes.haze.HazeState\nimport dev.chrisbanes.haze.hazeEffect\nimport dev.chrisbanes.haze.hazeSource\nimport dev.chrisbanes.haze.materials.CupertinoMaterials\nimport dev.chrisbanes.haze.materials.ExperimentalHazeMaterialsApi\nimport me.kavishdevar.librepods.R\nimport me.kavishdevar.librepods.composables.StyledSwitch\nimport me.kavishdevar.librepods.utils.AACPManager\nimport me.kavishdevar.librepods.utils.RadareOffsetFinder\nimport kotlin.io.encoding.Base64\nimport kotlin.io.encoding.ExperimentalEncodingApi\nimport kotlin.math.roundToInt\nimport androidx.compose.runtime.*\n@OptIn(ExperimentalMaterial3Api::class, ExperimentalHazeMaterialsApi::class, ExperimentalEncodingApi::class)\n@Composable\nfun AppSettingsScreen(navController: NavController) {\n    val sharedPreferences = LocalContext.current.getSharedPreferences(\"settings\", Context.MODE_PRIVATE)\n    val name = remember { mutableStateOf(sharedPreferences.getString(\"name\", \"\") ?: \"\") }\n    val isDarkTheme = isSystemInDarkTheme()\n    val context = LocalContext.current\n    val scrollState = rememberScrollState()\n    val scrollBehavior = TopAppBarDefaults.pinnedScrollBehavior()\n    val hazeState = remember { HazeState() }\nimport androidx.compose.material3.Switch\n    var showResetDialog by remember { mutableStateOf(false) }\n    var showIrkDialog by remember { mutableStateOf(false) }\n    var showEncKeyDialog by remember { mutableStateOf(false) }\n    var irkValue by remember { mutableStateOf(\"\") }\n    var encKeyValue by remember { mutableStateOf(\"\") }\n    var irkError by remember { mutableStateOf<String?>(null) }\n    var encKeyError by remember { mutableStateOf<String?>(null) }\n\n    LaunchedEffect(Unit) {\n        val savedIrk = sharedPreferences.getString(AACPManager.Companion.ProximityKeyType.IRK.name, null)\n        val savedEncKey = sharedPreferences.getString(AACPManager.Companion.ProximityKeyType.ENC_KEY.name, null)\n\n        if (savedIrk != null) {\n            try {\n                val decoded = Base64.decode(savedIrk)\n                irkValue = decoded.joinToString(\"\") { \"%02x\".format(it) }\n            } catch (e: Exception) {\n                irkValue = \"\"\n            }\n        }\n\n        if (savedEncKey != null) {\n            try {\n                val decoded = Base64.decode(savedEncKey)\n                encKeyValue = decoded.joinToString(\"\") { \"%02x\".format(it) }\n            } catch (e: Exception) {\n                encKeyValue = \"\"\n            }\n        }\n    }\n\n    var showPhoneBatteryInWidget by remember {\n        mutableStateOf(sharedPreferences.getBoolean(\"show_phone_battery_in_widget\", true))\n    }\n    var conversationalAwarenessPauseMusicEnabled by remember {\n        mutableStateOf(sharedPreferences.getBoolean(\"conversational_awareness_pause_music\", false))\n    }\n    var relativeConversationalAwarenessVolumeEnabled by remember {\n        mutableStateOf(sharedPreferences.getBoolean(\"relative_conversational_awareness_volume\", true))\n    }\n    var openDialogForControlling by remember {\n        mutableStateOf(sharedPreferences.getString(\"qs_click_behavior\", \"dialog\") == \"dialog\")\n    }\n    var disconnectWhenNotWearing by remember {\n        mutableStateOf(sharedPreferences.getBoolean(\"disconnect_when_not_wearing\", false))\n    }\n\n    var takeoverWhenDisconnected by remember {\n        mutableStateOf(sharedPreferences.getBoolean(\"takeover_when_disconnected\", true))\n    }\n    var takeoverWhenIdle by remember {\n        mutableStateOf(sharedPreferences.getBoolean(\"takeover_when_idle\", true))\n    }\n    var takeoverWhenMusic by remember {\n        mutableStateOf(sharedPreferences.getBoolean(\"takeover_when_music\", false))\n    }\n    var takeoverWhenCall by remember {\n        mutableStateOf(sharedPreferences.getBoolean(\"takeover_when_call\", true))\n    }\n\n    var takeoverWhenRingingCall by remember {\n        mutableStateOf(sharedPreferences.getBoolean(\"takeover_when_ringing_call\", true))\n    }\n    var takeoverWhenMediaStart by remember {\n        mutableStateOf(sharedPreferences.getBoolean(\"takeover_when_media_start\", true))\n    }\n\n    var useAlternateHeadTrackingPackets by remember {\n        mutableStateOf(sharedPreferences.getBoolean(\"use_alternate_head_tracking_packets\", false))\n    }\n\n    var bleOnlyMode by remember {\n        mutableStateOf(sharedPreferences.getBoolean(\"ble_only_mode\", false))\n    }\n    \n    // Ensure the default value is properly set if not exists\n    LaunchedEffect(Unit) {\n        if (!sharedPreferences.contains(\"ble_only_mode\")) {\n            sharedPreferences.edit().putBoolean(\"ble_only_mode\", false).apply()\n        }\n    }\n\n    var mDensity by remember { mutableFloatStateOf(0f) }\n\n    fun validateHexInput(input: String): Boolean {\n        val hexPattern = Regex(\"^[0-9a-fA-F]{32}$\")\n        return hexPattern.matches(input)\n    }\n\n    Scaffold(\n        modifier = Modifier.nestedScroll(scrollBehavior.nestedScrollConnection),\n        topBar = {\n            CenterAlignedTopAppBar(\n                modifier = Modifier.hazeEffect(\n                    state = hazeState,\n                    style = CupertinoMaterials.thick(),\n                    block = fun HazeEffectScope.() {\n                        alpha =\n                            if (scrollState.value > 60.dp.value * mDensity) 1f else 0f\n                    })\n                    .drawBehind {\n                        mDensity = density\n                        val strokeWidth = 0.7.dp.value * density\n                        val y = size.height - strokeWidth / 2\n                        if (scrollState.value > 60.dp.value * density) {\n                            drawLine(\n                                if (isDarkTheme) Color.DarkGray else Color.LightGray,\n                                Offset(0f, y),\n                                Offset(size.width, y),\n                                strokeWidth\n                            )\n                        }\n                    },\n                title = {\n                    Text(\n                        text = stringResource(R.string.app_settings),\n                        fontFamily = FontFamily(Font(R.font.sf_pro)),\n                    )\n                },\n                navigationIcon = {\n                    TextButton(\n                        onClick = {\n                            navController.popBackStack()\n                        },\n                        shape = RoundedCornerShape(8.dp),\n                        modifier = Modifier.width(180.dp)\n                    ) {\n                        Icon(\n                            Icons.AutoMirrored.Filled.KeyboardArrowLeft,\n                            contentDescription = \"Back\",\n                            tint = if (isDarkTheme)  Color(0xFF007AFF) else Color(0xFF3C6DF5),\n                            modifier = Modifier.scale(1.5f)\n                        )\n                        Text(\n                            text = name.value,\n                            style = TextStyle(\n                                fontSize = 18.sp,\n                                fontWeight = FontWeight.Medium,\n                                color = if (isDarkTheme) Color(0xFF007AFF) else Color(0xFF3C6DF5),\n                                fontFamily = FontFamily(Font(R.font.sf_pro))\n                            ),\n                            maxLines = 1,\n                            overflow = TextOverflow.Ellipsis,\n                            modifier = Modifier.weight(1f)\n                        )\n                    }\n                },\n                colors = TopAppBarDefaults.centerAlignedTopAppBarColors(\n                    containerColor = Color.Transparent\n                ),\n                scrollBehavior = scrollBehavior\n            )\n        },\n        containerColor = if (isSystemInDarkTheme()) Color(0xFF000000)\n        else Color(0xFFF2F2F7),\n    ) { paddingValues ->\n        Column (\n            modifier = Modifier\n                .fillMaxSize()\n                .padding(paddingValues)\n                .padding(horizontal = 16.dp)\n                .verticalScroll(scrollState)\n                .hazeSource(state = hazeState)\n        ) {\n            val isDarkTheme = isSystemInDarkTheme()\n            val backgroundColor = if (isDarkTheme) Color(0xFF1C1C1E) else Color(0xFFFFFFFF)\n            val textColor = if (isDarkTheme) Color.White else Color.Black\n\n            Spacer(modifier = Modifier.height(8.dp))\n\n            Text(\n                text = \"Widget\".uppercase(),\n                style = TextStyle(\n                    fontSize = 14.sp,\n                    fontWeight = FontWeight.Light,\n                    color = textColor.copy(alpha = 0.6f),\n                    fontFamily = FontFamily(Font(R.font.sf_pro))\n                ),\n                modifier = Modifier.padding(8.dp, bottom = 2.dp, top = 8.dp)\n            )\n\n            Spacer(modifier = Modifier.height(2.dp))\n\n            Column (\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .background(\n                        backgroundColor,\n                        RoundedCornerShape(14.dp)\n                    )\n                    .padding(horizontal = 16.dp, vertical = 4.dp)\n            ) {\n                Row(\n                    modifier = Modifier\n                        .fillMaxWidth()\n                        .clickable(\n                            indication = null,\n                            interactionSource = remember { MutableInteractionSource() }\n                        ) {\n                            showPhoneBatteryInWidget = !showPhoneBatteryInWidget\n                            sharedPreferences.edit().putBoolean(\"show_phone_battery_in_widget\", showPhoneBatteryInWidget).apply()\n                        },\n                    verticalAlignment = Alignment.CenterVertically\n                ) {\n                    Column(\n                        modifier = Modifier\n                            .weight(1f)\n                            .padding(vertical = 8.dp)\n                            .padding(end = 4.dp)\n                    ) {\n                        Text(\n                            text = \"Show phone battery in widget\",\n                            fontSize = 16.sp,\n                            color = textColor\n                        )\n                        Spacer(modifier = Modifier.height(4.dp))\n                        Text(\n                            text = \"Display your phone's battery level in the widget alongside AirPods battery\",\n                            fontSize = 14.sp,\n                            color = textColor.copy(0.6f),\n                            lineHeight = 16.sp,\n                        )\n                    }\n\n                    StyledSwitch(\n                        checked = showPhoneBatteryInWidget,\n                        onCheckedChange = {\n                            showPhoneBatteryInWidget = it\n                            sharedPreferences.edit().putBoolean(\"show_phone_battery_in_widget\", it).apply()\n                        }\n                    )\n                }\n            }\n\n            Text(\n                text = \"Connection Mode\".uppercase(),\n                style = TextStyle(\n                    fontSize = 14.sp,\n                    fontWeight = FontWeight.Light,\n                    color = textColor.copy(alpha = 0.6f),\n                    fontFamily = FontFamily(Font(R.font.sf_pro))\n                ),\n                modifier = Modifier.padding(8.dp, bottom = 2.dp, top = 24.dp)\n            )\n\n            Spacer(modifier = Modifier.height(2.dp))\n\n            Column (\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .background(\n                        backgroundColor,\n                        RoundedCornerShape(14.dp)\n                    )\n                    .padding(horizontal = 16.dp, vertical = 4.dp)\n            ) {\n                Row(\n                    modifier = Modifier\n                        .fillMaxWidth()\n                        .clickable(\n                            indication = null,\n                            interactionSource = remember { MutableInteractionSource() }\n                        ) {\n                            bleOnlyMode = !bleOnlyMode\n                            sharedPreferences.edit().putBoolean(\"ble_only_mode\", bleOnlyMode).apply()\n                        },\n                    verticalAlignment = Alignment.CenterVertically\n                ) {\n                    Column(\n                        modifier = Modifier\n                            .weight(1f)\n                            .padding(vertical = 8.dp)\n                            .padding(end = 4.dp)\n                    ) {\n                        Text(\n                            text = \"BLE Only Mode\",\n                            fontSize = 16.sp,\n                            color = textColor\n                        )\n                        Text(\n                            text = \"Only use Bluetooth Low Energy for battery data and ear detection. Disables advanced features requiring L2CAP connection.\",\n                            fontSize = 13.sp,\n                            color = textColor.copy(0.6f),\n                            lineHeight = 16.sp,\n                        )\n                    }\n\n                    StyledSwitch(\n                        checked = bleOnlyMode,\n                        onCheckedChange = {\n                            bleOnlyMode = it\n                            sharedPreferences.edit().putBoolean(\"ble_only_mode\", it).apply()\n                        }\n                    )\n                }\n            }\n\n            Text(\n                text = \"Conversational Awareness\".uppercase(),\n                style = TextStyle(\n                    fontSize = 14.sp,\n                    fontWeight = FontWeight.Light,\n                    color = textColor.copy(alpha = 0.6f),\n                    fontFamily = FontFamily(Font(R.font.sf_pro))\n                ),\n                modifier = Modifier.padding(8.dp, bottom = 2.dp, top = 24.dp)\n            )\n\n            Spacer(modifier = Modifier.height(2.dp))\n\n            Column (\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .background(\n                        backgroundColor,\n                        RoundedCornerShape(14.dp)\n                    )\n                    .padding(horizontal = 16.dp, vertical = 4.dp)\n            ) {\n                val sliderValue = remember { mutableFloatStateOf(0f) }\n                LaunchedEffect(sliderValue) {\n                    if (sharedPreferences.contains(\"conversational_awareness_volume\")) {\n                        sliderValue.floatValue = sharedPreferences.getInt(\"conversational_awareness_volume\", 43).toFloat()\n                    }\n                }\n\n                fun updateConversationalAwarenessPauseMusic(enabled: Boolean) {\n                    conversationalAwarenessPauseMusicEnabled = enabled\n                    sharedPreferences.edit().putBoolean(\"conversational_awareness_pause_music\", enabled).apply()\n                }\n\n                fun updateRelativeConversationalAwarenessVolume(enabled: Boolean) {\n                    relativeConversationalAwarenessVolumeEnabled = enabled\n                    sharedPreferences.edit().putBoolean(\"relative_conversational_awareness_volume\", enabled).apply()\n                }\n\n                Row(\n                    modifier = Modifier\n                        .fillMaxWidth()\n                        .clickable(\n                            indication = null,\n                            interactionSource = remember { MutableInteractionSource() }\n                        ) {\n                            updateConversationalAwarenessPauseMusic(!conversationalAwarenessPauseMusicEnabled)\n                        },\n                    verticalAlignment = Alignment.CenterVertically\n                ) {\n                    Column(\n                        modifier = Modifier\n                            .weight(1f)\n                            .padding(vertical = 8.dp)\n                            .padding(end = 4.dp)\n                    ) {\n                        Text(\n                            text = stringResource(R.string.conversational_awareness_pause_music),\n                            fontSize = 16.sp,\n                            color = textColor\n                        )\n                        Spacer(modifier = Modifier.height(4.dp))\n                        Text(\n                            text = stringResource(R.string.conversational_awareness_pause_music_description),\n                            fontSize = 14.sp,\n                            color = textColor.copy(0.6f),\n                            lineHeight = 16.sp,\n                        )\n                    }\n\n                    StyledSwitch(\n                        checked = conversationalAwarenessPauseMusicEnabled,\n                        onCheckedChange = {\n                            updateConversationalAwarenessPauseMusic(it)\n                        },\n                    )\n                }\n\n                Row(\n                    modifier = Modifier\n                        .fillMaxWidth()\n                        .clickable(\n                            indication = null,\n                            interactionSource = remember { MutableInteractionSource() }\n                        ) {\n                            updateRelativeConversationalAwarenessVolume(!relativeConversationalAwarenessVolumeEnabled)\n                        },\n                    verticalAlignment = Alignment.CenterVertically\n                ) {\n                    Column(\n                        modifier = Modifier\n                            .weight(1f)\n                            .padding(vertical = 8.dp)\n                            .padding(end = 4.dp)\n                    ) {\n                        Text(\n                            text = stringResource(R.string.relative_conversational_awareness_volume),\n                            fontSize = 16.sp,\n                            color = textColor\n                        )\n                        Spacer(modifier = Modifier.height(4.dp))\n                        Text(\n                            text = stringResource(R.string.relative_conversational_awareness_volume_description),\n                            fontSize = 14.sp,\n                            color = textColor.copy(0.6f),\n                            lineHeight = 16.sp,\n                        )\n                    }\n\n                    StyledSwitch(\n                        checked = relativeConversationalAwarenessVolumeEnabled,\n                        onCheckedChange = {\n                            updateRelativeConversationalAwarenessVolume(it)\n                        }\n                    )\n                }\n\n                Text(\n                    text = \"Conversational Awareness Volume\",\n                    fontSize = 16.sp,\n                    color = textColor,\n                    modifier = Modifier.padding(top = 8.dp, bottom = 4.dp)\n                )\n\n                val trackColor = if (isDarkTheme) Color(0xFFB3B3B3) else Color(0xFFD9D9D9)\n                val activeTrackColor = if (isDarkTheme) Color(0xFF007AFF) else Color(0xFF3C6DF5)\n                val thumbColor = if (isDarkTheme) Color(0xFFFFFFFF) else Color(0xFFFFFFFF)\n\n                Slider(\n                    value = sliderValue.floatValue,\n                    onValueChange = {\n                        sliderValue.floatValue = it\n                        sharedPreferences.edit().putInt(\"conversational_awareness_volume\", it.toInt()).apply()\n                    },\n                    valueRange = 10f..85f,\n                    onValueChangeFinished = {\n                        sliderValue.floatValue = sliderValue.floatValue.roundToInt().toFloat()\n                    },\n                    modifier = Modifier\n                        .fillMaxWidth()\n                        .height(36.dp)\n                        .padding(vertical = 4.dp),\n                    colors = SliderDefaults.colors(\n                        thumbColor = thumbColor,\n                        activeTrackColor = activeTrackColor,\n                        inactiveTrackColor = trackColor,\n                    ),\n                    thumb = {\n                        Box(\n                            modifier = Modifier\n                                .size(24.dp)\n                                .shadow(4.dp, CircleShape)\n                                .background(thumbColor, CircleShape)\n                        )\n                    },\n                    track = {\n                        Box (\n                            modifier = Modifier\n                                .fillMaxWidth()\n                                .height(12.dp),\n                            contentAlignment = Alignment.CenterStart\n                        )\n                        {\n                            Box(\n                                modifier = Modifier\n                                    .fillMaxWidth()\n                                    .height(4.dp)\n                                    .background(trackColor, RoundedCornerShape(4.dp))\n                            )\n                            Box(\n                                modifier = Modifier\n                                    .fillMaxWidth(((sliderValue.floatValue - 10) * 100) /7500)\n                                    .height(4.dp)\n                                    .background(if (conversationalAwarenessPauseMusicEnabled) trackColor else activeTrackColor, RoundedCornerShape(4.dp))\n                            )\n                        }\n                    }\n                )\n\n                Row(\n                    modifier = Modifier\n                        .fillMaxWidth()\n                        .padding(bottom = 8.dp),\n                    horizontalArrangement = Arrangement.SpaceBetween\n                ) {\n                    Text(\n                        text = \"10%\",\n                        style = TextStyle(\n                            fontSize = 14.sp,\n                            fontWeight = FontWeight.Light,\n                            color = textColor.copy(alpha = 0.7f)\n                        ),\n                        modifier = Modifier.padding(start = 4.dp)\n                    )\n                    Text(\n                        text = \"85%\",\n                        style = TextStyle(\n                            fontSize = 14.sp,\n                            fontWeight = FontWeight.Light,\n                            color = textColor.copy(alpha = 0.7f)\n                        ),\n                        modifier = Modifier.padding(end = 4.dp)\n                    )\n                }\n            }\n\n            Text(\n                text = \"Quick Settings Tile\".uppercase(),\n                style = TextStyle(\n                    fontSize = 14.sp,\n                    fontWeight = FontWeight.Light,\n                    color = textColor.copy(alpha = 0.6f),\n                    fontFamily = FontFamily(Font(R.font.sf_pro))\n                ),\n                modifier = Modifier.padding(8.dp, bottom = 2.dp, top = 24.dp)\n            )\n\n            Spacer(modifier = Modifier.height(2.dp))\n\n            Column(\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .background(\n                        backgroundColor,\n                        RoundedCornerShape(14.dp)\n                    )\n                    .padding(horizontal = 16.dp, vertical = 4.dp)\n            ) {\n                fun updateQsClickBehavior(enabled: Boolean) {\n                    openDialogForControlling = enabled\n                    sharedPreferences.edit().putString(\"qs_click_behavior\", if (enabled) \"dialog\" else \"cycle\").apply()\n                }\n\n                Row(\n                    modifier = Modifier\n                        .fillMaxWidth()\n                        .clickable(\n                            indication = null,\n                            interactionSource = remember { MutableInteractionSource() }\n                        ) {\n                            updateQsClickBehavior(!openDialogForControlling)\n                        },\n                    verticalAlignment = Alignment.CenterVertically\n                ) {\n                    Column(\n                        modifier = Modifier\n                            .weight(1f)\n                            .padding(vertical = 8.dp)\n                            .padding(end = 4.dp)\n                    ) {\n                        Text(\n                            text = \"Open dialog for controlling\",\n                            fontSize = 16.sp,\n                            color = textColor\n                        )\n                        Spacer(modifier = Modifier.height(4.dp))\n                        Text(\n                            text = if (openDialogForControlling)\n                                   \"If disabled, clicking on the QS will cycle through modes\"\n                                   else \"If enabled, it will show a dialog for controlling noise control mode and conversational awareness\",\n                            fontSize = 14.sp,\n                            color = textColor.copy(0.6f),\n                            lineHeight = 16.sp,\n                        )\n                    }\n\n                    StyledSwitch(\n                        checked = openDialogForControlling,\n                        onCheckedChange = {\n                            updateQsClickBehavior(it)\n                        }\n                    )\n                }\n            }\n\n            Text(\n                text = \"Ear Detection\".uppercase(),\n                style = TextStyle(\n                    fontSize = 14.sp,\n                    fontWeight = FontWeight.Light,\n                    color = textColor.copy(alpha = 0.6f),\n                    fontFamily = FontFamily(Font(R.font.sf_pro))\n                ),\n                modifier = Modifier.padding(8.dp, bottom = 2.dp, top = 24.dp)\n            )\n\n            Spacer(modifier = Modifier.height(2.dp))\n\n            Column(\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .background(\n                        backgroundColor,\n                        RoundedCornerShape(14.dp)\n                    )\n                    .padding(horizontal = 16.dp, vertical = 4.dp)\n            ) {\n                fun updateDisconnectWhenNotWearing(enabled: Boolean) {\n                    disconnectWhenNotWearing = enabled\n                    sharedPreferences.edit().putBoolean(\"disconnect_when_not_wearing\", enabled).apply()\n                }\n\n                Row(\n                    modifier = Modifier\n                        .fillMaxWidth()\n                        .clickable(\n                            indication = null,\n                            interactionSource = remember { MutableInteractionSource() }\n                        ) {\n                            updateDisconnectWhenNotWearing(!disconnectWhenNotWearing)\n                        },\n                    verticalAlignment = Alignment.CenterVertically\n                ) {\n                    Column(\n                        modifier = Modifier\n                            .weight(1f)\n                            .padding(vertical = 8.dp)\n                            .padding(end = 4.dp)\n                    ) {\n                        Text(\n                            text = \"Disconnect AirPods when not wearing\",\n                            fontSize = 16.sp,\n                            color = textColor\n                        )\n                        Spacer(modifier = Modifier.height(4.dp))\n                        Text(\n                            text = \"You will still be able to control them with the app - this just disconnects the audio.\",\n                            fontSize = 14.sp,\n                            color = textColor.copy(0.6f),\n                            lineHeight = 16.sp,\n                        )\n                    }\n\n                    StyledSwitch(\n                        checked = disconnectWhenNotWearing,\n                        onCheckedChange = {\n                            updateDisconnectWhenNotWearing(it)\n                        }\n                    )\n                }\n            }\n\n            Text(\n                text = stringResource(R.string.takeover_header).uppercase(),\n                style = TextStyle(\n                    fontSize = 14.sp,\n                    fontWeight = FontWeight.Light,\n                    color = textColor.copy(alpha = 0.6f),\n                    fontFamily = FontFamily(Font(R.font.sf_pro))\n                ),\n                modifier = Modifier.padding(8.dp, bottom = 2.dp, top = 24.dp)\n            )\n\n            Spacer(modifier = Modifier.height(2.dp))\n\n            Column(\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .background(\n                        backgroundColor,\n                        RoundedCornerShape(14.dp)\n                    )\n                    .padding(horizontal = 16.dp, vertical = 4.dp)\n            ) {\n                Text(\n                    text = stringResource(R.string.takeover_airpods_state),\n                    fontSize = 16.sp,\n                    fontWeight = FontWeight.Medium,\n                    color = textColor,\n                    modifier = Modifier.padding(top = 12.dp, bottom = 4.dp)\n                )\n\n                Row(\n                    modifier = Modifier\n                        .fillMaxWidth()\n                        .clickable(\n                            indication = null,\n                            interactionSource = remember { MutableInteractionSource() }\n                        ) {\n                            takeoverWhenDisconnected = !takeoverWhenDisconnected\n                            sharedPreferences.edit().putBoolean(\"takeover_when_disconnected\", takeoverWhenDisconnected).apply()\n                        },\n                    verticalAlignment = Alignment.CenterVertically\n                ) {\n                    Column(\n                        modifier = Modifier\n                            .weight(1f)\n                            .padding(vertical = 8.dp)\n                            .padding(end = 4.dp)\n                    ) {\n                        Text(\n                            text = stringResource(R.string.takeover_disconnected),\n                            fontSize = 16.sp,\n                            color = textColor\n                        )\n                        Spacer(modifier = Modifier.height(4.dp))\n                        Text(\n                            text = stringResource(R.string.takeover_disconnected_desc),\n                            fontSize = 14.sp,\n                            color = textColor.copy(0.6f),\n                            lineHeight = 16.sp,\n                        )\n                    }\n\n                    StyledSwitch(\n                        checked = takeoverWhenDisconnected,\n                        onCheckedChange = {\n                            takeoverWhenDisconnected = it\n                            sharedPreferences.edit().putBoolean(\"takeover_when_disconnected\", it).apply()\n                        }\n                    )\n                }\n\n                Row(\n                    modifier = Modifier\n                        .fillMaxWidth()\n                        .clickable(\n                            indication = null,\n                            interactionSource = remember { MutableInteractionSource() }\n                        ) {\n                            takeoverWhenIdle = !takeoverWhenIdle\n                            sharedPreferences.edit().putBoolean(\"takeover_when_idle\", takeoverWhenIdle).apply()\n                        },\n                    verticalAlignment = Alignment.CenterVertically\n                ) {\n                    Column(\n                        modifier = Modifier\n                            .weight(1f)\n                            .padding(vertical = 8.dp)\n                            .padding(end = 4.dp)\n                    ) {\n                        Text(\n                            text = stringResource(R.string.takeover_idle),\n                            fontSize = 16.sp,\n                            color = textColor\n                        )\n                        Spacer(modifier = Modifier.height(4.dp))\n                        Text(\n                            text = stringResource(R.string.takeover_idle_desc),\n                            fontSize = 14.sp,\n                            color = textColor.copy(0.6f),\n                            lineHeight = 16.sp,\n                        )\n                    }\n\n                    StyledSwitch(\n                        checked = takeoverWhenIdle,\n                        onCheckedChange = {\n                            takeoverWhenIdle = it\n                            sharedPreferences.edit().putBoolean(\"takeover_when_idle\", it).apply()\n                        }\n                    )\n                }\n\n                Row(\n                    modifier = Modifier\n                        .fillMaxWidth()\n                        .clickable(\n                            indication = null,\n                            interactionSource = remember { MutableInteractionSource() }\n                        ) {\n                            takeoverWhenMusic = !takeoverWhenMusic\n                            sharedPreferences.edit().putBoolean(\"takeover_when_music\", takeoverWhenMusic).apply()\n                        },\n                    verticalAlignment = Alignment.CenterVertically\n                ) {\n                    Column(\n                        modifier = Modifier\n                            .weight(1f)\n                            .padding(vertical = 8.dp)\n                            .padding(end = 4.dp)\n                    ) {\n                        Text(\n                            text = stringResource(R.string.takeover_music),\n                            fontSize = 16.sp,\n                            color = textColor\n                        )\n                        Spacer(modifier = Modifier.height(4.dp))\n                        Text(\n                            text = stringResource(R.string.takeover_music_desc),\n                            fontSize = 14.sp,\n                            color = textColor.copy(0.6f),\n                            lineHeight = 16.sp,\n                        )\n                    }\n\n                    StyledSwitch(\n                        checked = takeoverWhenMusic,\n                        onCheckedChange = {\n                            takeoverWhenMusic = it\n                            sharedPreferences.edit().putBoolean(\"takeover_when_music\", it).apply()\n                        }\n                    )\n                }\n\n                Row(\n                    modifier = Modifier\n                        .fillMaxWidth()\n                        .clickable(\n                            indication = null,\n                            interactionSource = remember { MutableInteractionSource() }\n                        ) {\n                            takeoverWhenCall = !takeoverWhenCall\n                            sharedPreferences.edit().putBoolean(\"takeover_when_call\", takeoverWhenCall).apply()\n                        },\n                    verticalAlignment = Alignment.CenterVertically\n                ) {\n                    Column(\n                        modifier = Modifier\n                            .weight(1f)\n                            .padding(vertical = 8.dp)\n                            .padding(end = 4.dp)\n                    ) {\n                        Text(\n                            text = stringResource(R.string.takeover_cal"
        }
      ]
    },
    {
      "dir": "android/app/src/main/java/me/kavishdevar/librepods/widgets",
      "files": [
        {
          "name": "BatteryWidget.kt",
          "ext": ".kt",
          "size": 1293,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n *\n * Copyright (C) 2025 LibrePods contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\n@file:OptIn(ExperimentalEncodingApi::class)\n\npackage me.kavishdevar.librepods.widgets\n\nimport android.appwidget.AppWidgetManager\nimport android.appwidget.AppWidgetProvider\nimport android.content.Context\nimport me.kavishdevar.librepods.services.ServiceManager\nimport kotlin.io.encoding.ExperimentalEncodingApi\n\nclass BatteryWidget : AppWidgetProvider() {\n    override fun onUpdate(\n        context: Context,\n        appWidgetManager: AppWidgetManager,\n        appWidgetIds: IntArray\n    ) {\n        ServiceManager.getService()?.updateBattery()\n    }\n}\n"
        },
        {
          "name": "NoiseControlWidget.kt",
          "ext": ".kt",
          "size": 3787,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n *\n * Copyright (C) 2025 LibrePods contributors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\n@file:OptIn(ExperimentalEncodingApi::class)\n\npackage me.kavishdevar.librepods.widgets\n\nimport android.app.PendingIntent\nimport android.appwidget.AppWidgetManager\nimport android.appwidget.AppWidgetProvider\nimport android.content.Context\nimport android.content.Intent\nimport android.util.Log\nimport android.widget.RemoteViews\nimport me.kavishdevar.librepods.R\nimport me.kavishdevar.librepods.services.ServiceManager\nimport me.kavishdevar.librepods.utils.AACPManager\nimport kotlin.io.encoding.ExperimentalEncodingApi\n\nclass NoiseControlWidget : AppWidgetProvider() {\n    override fun onUpdate(\n        context: Context,\n        appWidgetManager: AppWidgetManager,\n        appWidgetIds: IntArray\n    ) {\n        val views = RemoteViews(context.packageName, R.layout.noise_control_widget)\n\n        val offIntent = Intent(context, NoiseControlWidget::class.java).apply {\n            action = \"ACTION_SET_ANC_MODE\"\n            putExtra(\"ANC_MODE\", 1)\n        }\n        val transparencyIntent = Intent(context, NoiseControlWidget::class.java).apply {\n            action = \"ACTION_SET_ANC_MODE\"\n            putExtra(\"ANC_MODE\", 3)\n        }\n        val adaptiveIntent = Intent(context, NoiseControlWidget::class.java).apply {\n            action = \"ACTION_SET_ANC_MODE\"\n            putExtra(\"ANC_MODE\", 4)\n        }\n        val ancIntent = Intent(context, NoiseControlWidget::class.java).apply {\n            action = \"ACTION_SET_ANC_MODE\"\n            putExtra(\"ANC_MODE\", 2)\n        }\n\n        views.setOnClickPendingIntent(\n            R.id.widget_off_button,\n            PendingIntent.getBroadcast(context, 0, offIntent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)\n        )\n        views.setOnClickPendingIntent(\n            R.id.widget_transparency_button,\n            PendingIntent.getBroadcast(context, 1, transparencyIntent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)\n        )\n        views.setOnClickPendingIntent(\n            R.id.widget_adaptive_button,\n            PendingIntent.getBroadcast(context, 2, adaptiveIntent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)\n        )\n        views.setOnClickPendingIntent(\n            R.id.widget_anc_button,\n            PendingIntent.getBroadcast(context, 3, ancIntent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)\n        )\n        ServiceManager.getService()?.updateNoiseControlWidget()\n        appWidgetManager.updateAppWidget(appWidgetIds, views)\n    }\n\n    override fun onReceive(context: Context, intent: Intent) {\n        super.onReceive(context, intent)\n        if (intent.action == \"ACTION_SET_ANC_MODE\") {\n            val mode = intent.getIntExtra(\"ANC_MODE\", 1)\n            Log.d(\"NoiseControlWidget\", \"Setting ANC mode to $mode\")\n            ServiceManager.getService()!!\n                .aacpManager\n                .sendControlCommand(\n                    AACPManager.Companion.ControlCommandIdentifiers.LISTENING_MODE.value,\n                    mode.toByte()\n                )\n        }\n    }\n}\n"
        }
      ]
    },
    {
      "dir": "android/app/src/main/java/me/kavishdevar/librepods/receivers",
      "files": [
        {
          "name": "BootReceiver.kt",
          "ext": ".kt",
          "size": 1729,
          "preview": "/*\n * LibrePods - AirPods liberated from Apple\u2019s ecosystem\n * \n * Copyright (C) 2025 LibrePods contributors\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n * \n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\n@file:OptIn(ExperimentalEncodingApi::class)\n\npackage me.kavishdevar.librepods.receivers\n\nimport android.content.BroadcastReceiver\nimport android.content.Context\nimport android.content.Intent\nimport kotlin.io.encoding.ExperimentalEncodingApi\nimport me.kavishdevar.librepods.services.AirPodsService\n\nclass BootReceiver: BroadcastReceiver() {\n    override fun onReceive(context: Context?, intent: Intent?) {\n        when (intent?.action) {\n            Intent.ACTION_MY_PACKAGE_REPLACED -> try { context?.startForegroundService(\n                Intent(\n                    context,\n                    AirPodsService::class.java\n                )\n            ) } catch (e: Exception) { e.printStackTrace() }\n            Intent.ACTION_BOOT_COMPLETED -> try { context?.startForegroundService(\n                Intent(\n                    context,\n                    AirPodsService::class.java\n                )\n            ) } catch (e: Exception) { e.printStackTrace() }\n        }\n    }\n}"
        }
      ]
    },
    {
      "dir": "android/app/libs",
      "files": [
        {
          "name": "libxposed-api-100.aar",
          "ext": ".aar",
          "size": 16996
        }
      ]
    },
    {
      "dir": "head-tracking",
      "files": [
        {
          "name": "README.md",
          "ext": ".md",
          "size": 4209,
          "preview": "# AirPods Head Tracking Visualizer\n\nThis implements head tracking with AirPods by gathering sensor data over l2cap, processing orientation and acceleration values, and detecting head gestures. The codebase is split into the following components:\n\n# How to use\n\nConnect your airpods and change the mac address in `plot.py` to your airpods mac address. Then run the following command to start the program.\n\n```bash\npython plot.py\n```\n\nAlternatively, you can directly run the `gestures.py` to just detect gestures.\n\n```bash\npython gestures.py\n```\n\n- **Connection and Data Collection**  \n  The project uses a custom ConnectionManager (imported in multiple files) to connect via Bluetooth to AirPods. Once connected, sensor packets are received in raw hex format. An AirPodsTracker class (in `plot.py`) handles the start/stop of tracking, logging of raw data, and parsing of packets into useful fields.\n\n- **Orientation Calculation and Visualization**  \n  The `HeadOrientation` class (in `head_orientation.py`) is responsible for:\n  - **Calibration:**  \n    A set number of samples (default 10) are collected to calculate the neutral (baseline) values for the sensors. For example:  \n    `o1_neutral = np.mean(samples[:, 0])`\n  - **Calculating Angles:**  \n    For each new packet, the raw orientation values are normalized by subtracting the neutral baseline. Then:\n    - **Pitch** is computed as:\n      ```\n      pitch = (o2_norm + o3_norm) / 2 / 32000 * 180\n      ```\n      This averages the deviations from neutral, scales the result to degrees (assuming a sensor range around 32000), thus giving a smooth estimation of up/down tilt.\n    - **Yaw** is computed as:\n      ```\n      yaw = (o2_norm - o3_norm) / 2 / 32000 * 180\n      ```\n      Here, the difference between the two sensor axes is used to detect left/right rotation.\n  - **ASCII Visualization:**  \n    Based on the calculated pitch and yaw, an ASCII art \"face\" is generated. The algorithm rotates points on a circle using simple trigonometric formulas (with scaling factors based on sensor depth) to build an approximate visual representation of head orientation.\n\n- **Live Plotting and Interactive Commands**  \n  The code offers both terminal-based plotting and graphical plotting via matplotlib. The AirPodsTracker manages live plotting by maintaining a buffer of recent packets. When in terminal mode, the code uses libraries like `asciichartpy` and `drawille` to render charts; in graphical mode, it creates live-updating plots.\n\n- **Gesture Detection**  \n  The `GestureDetector` class (in `gestures.py`) processes the head tracking data to detect nodding (\"Yes\") or head shaking (\"No\"):\n  - **Smoothing:**  \n    Raw horizontal and vertical sensor data undergo moving-average smoothing using small fixed-size buffers. This reduces noise and provides a steadier signal.\n  - **Peak and Trough Detection:**  \n    The code monitors small sections (e.g. the last 4 values) to compute variance and dynamically determine thresholds for direction changes. When a significant reversal (e.g. from increasing to decreasing) is detected that surpasses the dynamic threshold value (derived partly from a fixed threshold and variance), a peak or trough is recorded.\n  - **Rhythm Consistency:**  \n    Time intervals between detected peaks are captured. The consistency of these intervals (by comparing them to their mean and computing relative variance) is used to evaluate whether the movement is rhythmic\u2014a trait of intentional gestures.\n  - **Confidence Calculation:**  \n    Multiple factors are considered:\n    - **Amplitude Factor:** Compares the average detected peak amplitude with a constant (like 600) to provide a normalized measure.\n    - **Rhythm Factor:** Derived from the consistency of the time intervals of the peaks.\n    - **Alternation Factor:** Verifies that the signal alternates (for instance, switching between positive and negative values).\n    - **Isolation Factor:** Checks that movement on the target axis (vertical for nodding, horizontal for shaking) dominates over the non-target axis.\n  \n    A weighted sum of these factors forms a confidence score which, if above a predefined threshold (e.g. 0.7), confirms a detected gesture.\n"
        },
        {
          "name": "requirements.txt",
          "ext": ".txt",
          "size": 51,
          "preview": "drawille\nnumpy\npybluez\nmatplotlib\nasciichartpy\nrich"
        },
        {
          "name": "head_orientation.py",
          "ext": ".py",
          "size": 5275,
          "preview": "import math\nimport drawille\nimport numpy as np\nimport logging\nimport os\n\nclass Colors:\n    RESET = \"\\033[0m\"\n    BOLD = \"\\033[1m\"\n    RED = \"\\033[91m\"\n    GREEN = \"\\033[92m\"\n    YELLOW = \"\\033[93m\"\n    BLUE = \"\\033[94m\"\n    MAGENTA = \"\\033[95m\"\n    CYAN = \"\\033[96m\"\n    WHITE = \"\\033[97m\"\n    BG_BLACK = \"\\033[40m\"\n\nclass ColorFormatter(logging.Formatter):\n    FORMATS = {\n        logging.DEBUG: Colors.BLUE + \"[%(levelname)s] %(message)s\" + Colors.RESET,\n        logging.INFO: Colors.GREEN + \"%(message)s\" + Colors.RESET,\n        logging.WARNING: Colors.YELLOW + \"%(message)s\" + Colors.RESET,\n        logging.ERROR: Colors.RED + \"[%(levelname)s] %(message)s\" + Colors.RESET,\n        logging.CRITICAL: Colors.RED + Colors.BOLD + \"[%(levelname)s] %(message)s\" + Colors.RESET\n    }\n\n    def format(self, record):\n        log_fmt = self.FORMATS.get(record.levelno)\n        formatter = logging.Formatter(log_fmt, datefmt=\"%H:%M:%S\")\n        return formatter.format(record)\n\nhandler = logging.StreamHandler()\nhandler.setFormatter(ColorFormatter())\nlog = logging.getLogger(__name__)\nlog.setLevel(logging.INFO)\nlog.addHandler(handler)\nlog.propagate = False\n\n\nclass HeadOrientation:\n    def __init__(self, use_terminal=False):\n        self.orientation_offset = 5500\n        self.o1_neutral = 19000\n        self.o2_neutral = 0\n        self.o3_neutral = 0\n        self.calibration_samples = []\n        self.calibration_complete = False\n        self.calibration_sample_count = 10\n        self.fig = None\n        self.ax = None\n        self.arrow = None\n        self.animation = None\n        self.use_terminal = use_terminal\n\n    def reset_calibration(self):\n        self.calibration_samples = []\n        self.calibration_complete = False\n\n    def add_calibration_sample(self, orientation_values):\n        if len(self.calibration_samples) < self.calibration_sample_count:\n            self.calibration_samples.append(orientation_values)\n            return False\n        if not self.calibration_complete:\n            self._calculate_calibration()\n            return True\n        return True\n\n    def _calculate_calibration(self):\n        if len(self.calibration_samples) < 3:\n            log.warning(\"Not enough calibration samples\")\n            return\n        samples = np.array(self.calibration_samples)\n        self.o1_neutral = np.mean(samples[:, 0])\n        avg_o2 = np.mean(samples[:, 1])\n        avg_o3 = np.mean(samples[:, 2])\n        self.o2_neutral = avg_o2\n        self.o3_neutral = avg_o3\n        log.info(\"Calibration complete: o1_neutral=%.2f, o2_neutral=%.2f, o3_neutral=%.2f\", \n                    self.o1_neutral, self.o2_neutral, self.o3_neutral)\n        self.calibration_complete = True\n\n    def calculate_orientation(self, o1, o2, o3):\n        if not self.calibration_complete:\n            return {'pitch': 0, 'yaw': 0}\n        o1_norm = o1 - self.o1_neutral\n        o2_norm = o2 - self.o2_neutral\n        o3_norm = o3 - self.o3_neutral\n        pitch = (o2_norm + o3_norm) / 2 / 32000 * 180\n        yaw = (o2_norm - o3_norm) / 2 / 32000 * 180\n        return {'pitch': pitch, 'yaw': yaw}\n\n    def create_face_art(self, pitch, yaw):\n        if self.use_terminal:\n            try:\n                ts = os.get_terminal_size()\n                width, height = ts.columns, ts.lines * 2\n            except Exception:\n                width, height = 80, 40\n        else:\n            width, height = 80, 40\n        center_x, center_y = width // 2, height // 2\n        radius = (min(width, height) // 2 - 2) // 2\n        pitch_rad = math.radians(pitch)\n        yaw_rad = math.radians(yaw)\n        canvas = drawille.Canvas()\n        def rotate_point(x, y, z, pitch_r, yaw_r):\n            cos_y, sin_y = math.cos(yaw_r), math.sin(yaw_r)\n            cos_p, sin_p = math.cos(pitch_r), math.sin(pitch_r)\n            x1 = x * cos_y - z * sin_y\n            z1 = x * sin_y + z * cos_y\n            y1 = y * cos_p - z1 * sin_p\n            z2 = y * sin_p + z1 * cos_p\n            scale = 1 + (z2 / width)\n            return int(center_x + x1 * scale), int(center_y + y1 * scale)\n        for angle in range(0, 360, 2):\n            rad = math.radians(angle)\n            x = radius * math.cos(rad)\n            y = radius * math.sin(rad)\n            x1, y1 = rotate_point(x, y, 0, pitch_rad, yaw_rad)\n            canvas.set(x1, y1)\n        for eye in [(-radius//2, -radius//3, 2), (radius//2, -radius//3, 2)]:\n            ex, ey, ez = eye\n            x1, y1 = rotate_point(ex, ey, ez, pitch_rad, yaw_rad)\n            for dx in [-1, 0, 1]:\n                for dy in [-1, 0, 1]:\n                    canvas.set(x1 + dx, y1 + dy)\n        nx, ny = rotate_point(0, 0, 1, pitch_rad, yaw_rad)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                canvas.set(nx + dx, ny + dy)\n        smile_depth = radius // 8\n        mouth_local_y = radius // 4\n        mouth_length = radius\n        for x_offset in range(-mouth_length // 2, mouth_length // 2 + 1):\n            norm = abs(x_offset) / (mouth_length / 2)\n            y_offset = int((1 - norm ** 2) * smile_depth)\n            local_x = x_offset\n            local_y = mouth_local_y + y_offset\n            mx, my = rotate_point(local_x, local_y, 0, pitch_rad, yaw_rad)\n            canvas.set(mx, my)\n        return canvas.frame()\n"
        },
        {
          "name": "plot.py",
          "ext": ".py",
          "size": 38666,
          "preview": "import struct\nimport bluetooth\nimport threading\nimport time\nfrom datetime import datetime\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport os\nimport asciichartpy as acp\nfrom rich.live import Live\nfrom rich.layout import Layout\nfrom rich.panel import Panel\nfrom rich.console import Console\nimport drawille\nfrom head_orientation import HeadOrientation\nimport logging\nfrom connection_manager import ConnectionManager\n\nclass Colors:\n    RESET = \"\\033[0m\"\n    BOLD = \"\\033[1m\"\n    RED = \"\\033[91m\"\n    GREEN = \"\\033[92m\"\n    YELLOW = \"\\033[93m\"\n    BLUE = \"\\033[94m\"\n    MAGENTA = \"\\033[95m\"\n    CYAN = \"\\033[96m\"\n    WHITE = \"\\033[97m\"\n    BG_BLACK = \"\\033[40m\"\n\nclass ColorFormatter(logging.Formatter):\n    FORMATS = {\n        logging.DEBUG: Colors.BLUE + \"[%(levelname)s] %(message)s\" + Colors.RESET,\n        logging.INFO: Colors.GREEN + \"%(message)s\" + Colors.RESET,\n        logging.WARNING: Colors.YELLOW + \"%(message)s\" + Colors.RESET,\n        logging.ERROR: Colors.RED + \"[%(levelname)s] %(message)s\" + Colors.RESET,\n        logging.CRITICAL: Colors.RED + Colors.BOLD + \"[%(levelname)s] %(message)s\" + Colors.RESET\n    }\n\n    def format(self, record):\n        log_fmt = self.FORMATS.get(record.levelno)\n        formatter = logging.Formatter(log_fmt, datefmt=\"%H:%M:%S\")\n        return formatter.format(record)\n    \nhandler = logging.StreamHandler()\nhandler.setFormatter(ColorFormatter())\nlogger = logging.getLogger(\"airpods-head-tracking\")\nlogger.setLevel(logging.INFO)\nlogger.addHandler(handler)\nlogger.propagate = True\n\nINIT_CMD  = \"00 00 04 00 01 00 02 00 00 00 00 00 00 00 00 00\"\nNOTIF_CMD = \"04 00 04 00 0F 00 FF FF FE FF\"\nSTART_CMD = \"04 00 04 00 17 00 00 00 10 00 10 00 08 A1 02 42 0B 08 0E 10 02 1A 05 01 40 9C 00 00\"\nSTOP_CMD  = \"04 00 04 00 17 00 00 00 10 00 11 00 08 7E 10 02 42 0B 08 4E 10 02 1A 05 01 00 00 00 00\"\n\nKEY_FIELDS = {\n    \"orientation 1\": (43, 2),\n    \"orientation 2\": (45, 2),\n    \"orientation 3\": (47, 2),\n\n    \"Horizontal Acceleration\": (51, 2),\n    \"Vertical Acceleration\": (53, 2),\n\n    \"unkown 1\": (61, 2),\n    \"unkown 2 \": (49, 2),\n}\n\nclass AirPodsTracker:\n    def __init__(self):\n        self.sock = None\n        self.recording = False\n        self.log_file = None\n        self.listener_thread = None\n        self.bt_addr = \"28:2D:7F:C2:05:5B\"\n        self.psm = 0x1001\n        self.raw_packets = []\n        self.parsed_packets = []\n        self.live_data = []\n        self.live_plotting = False\n        self.animation = None\n        self.fig = None\n        self.axes = None\n        self.lines = {}\n        self.selected_fields = []\n        self.data_lock = threading.Lock()\n        self.orientation_offset = 5500\n        self.use_terminal = True # '--terminal' in sys.argv\n        self.orientation_visualizer = HeadOrientation(use_terminal=self.use_terminal)\n\n        self.conn = None\n\n    def connect(self):\n        try:\n            logger.info(\"Trying to connect to %s on PSM 0x%04X...\", self.bt_addr, self.psm)\n            self.conn = ConnectionManager(self.bt_addr, self.psm, logger=logger)\n            if not self.conn.connect():\n                logger.error(\"Connection failed via ConnectionManager.\")\n                return False\n            self.sock = self.conn.sock\n            self.sock.send(bytes.fromhex(NOTIF_CMD))\n            logger.info(\"Sent initialization command.\")\n\n            self.listener_thread = threading.Thread(target=self.listen, daemon=True)\n            self.listener_thread.start()\n            return True\n        except Exception as e:\n            logger.error(\"Connection error: %s\", e)\n            return False\n\n    def start_tracking(self, duration=None):\n        if not self.recording:\n            self.conn.send_start()\n            filename = \"head_tracking_\" + datetime.now().strftime(\"%Y%m%d_%H%M%S\") + \".log\"\n            self.log_file = open(filename, \"w\")\n            self.recording = True\n            logger.info(\"Recording started. Saving data to %s\", filename)\n\n            if duration is not None and duration > 0:\n                def auto_stop():\n                    time.sleep(duration)\n                    if self.recording:\n                        self.stop_tracking()\n                        logger.info(\"Recording automatically stopped after %s seconds.\", duration)\n\n                timer_thread = threading.Thread(target=auto_stop, daemon=True)\n                timer_thread.start()\n                logger.info(\"Will automatically stop recording after %s seconds.\", duration)\n        else:\n            logger.info(\"Already recording.\")\n\n    def stop_tracking(self):\n        if self.recording:\n            self.conn.send_stop()\n            self.recording = False\n            if self.log_file is not None:\n                self.log_file.close()\n                self.log_file = None\n            logger.info(\"Recording stopped.\")\n        else:\n            logger.info(\"Not currently recording.\")\n\n    def format_hex(self, data):\n        hex_str = data.hex()\n        return ' '.join(hex_str[i:i + 2] for i in range(0, len(hex_str), 2))\n\n    def parse_raw_packet(self, hex_string):\n        return bytes.fromhex(hex_string.replace(\" \", \"\"))\n\n    def interpret_bytes(self, raw_bytes, start, length, data_type=\"signed_short\"):\n        if start + length > len(raw_bytes):\n            return None\n\n        if data_type == \"signed_short\":\n            return int.from_bytes(raw_bytes[start:start + 2], byteorder='little', signed=True)\n        elif data_type == \"unsigned_short\":\n            return int.from_bytes(raw_bytes[start:start + 2], byteorder='little', signed=False)\n        elif data_type == \"signed_short_be\":\n            return int.from_bytes(raw_bytes[start:start + 2], byteorder='big', signed=True)\n        elif data_type == \"float_le\":\n            if start + 4 <= len(raw_bytes):\n                return struct.unpack('<f', raw_bytes[start:start + 4])[0]\n        elif data_type == \"float_be\":\n            if start + 4 <= len(raw_bytes):\n                return struct.unpack('>f', raw_bytes[start:start + 4])[0]\n        return None\n\n    def normalize_orientation(self, value, field_name):\n        if 'orientation' in field_name.lower():\n            return value + self.orientation_offset\n\n        return value\n\n    def parse_packet_all_fields(self, raw_bytes):\n        packet = {}\n\n        packet[\"seq_num\"] = int.from_bytes(raw_bytes[12:14], byteorder='little')\n\n        for field_name, (start, length) in KEY_FIELDS.items():\n            if field_name == \"float_val\" and start + 4 <= len(raw_bytes):\n                packet[field_name] = self.interpret_bytes(raw_bytes, start, 4, \"float_le\")\n            else:\n                raw_value = self.interpret_bytes(raw_bytes, start, length, \"signed_short\")\n                if raw_value is not None:\n                    packet[field_name] = self.normalize_orientation(raw_value, field_name)\n\n        for i in range(30, min(90, len(raw_bytes) - 1), 2):\n            field_name = f\"byte_{i:02d}\"\n            raw_value = self.interpret_bytes(raw_bytes, i, 2, \"signed_short\")\n            if raw_value is not None:\n                packet[field_name] = self.normalize_orientation(raw_value, field_name)\n\n        return packet\n\n    def apply_dark_theme(self, fig, axes):\n        fig.patch.set_facecolor('#1e1e1e')\n        for ax in axes:\n            ax.set_facecolor('#2d2d2d')\n\n            ax.title.set_color('white')\n            ax.xaxis.label.set_color('white')\n            ax.yaxis.label.set_color('white')\n            ax.tick_params(colors='white')\n            ax.tick_params(axis='x', colors='white')\n            ax.tick_params(axis='y', colors='white')\n\n            ax.grid(True, color='#555555', alpha=0.3, linestyle='--')\n\n            for spine in ax.spines.values():\n                spine.set_color('#555555')\n\n            legend = ax.get_legend()\n            if (legend):\n                legend.get_frame().set_facecolor('#2d2d2d')\n                legend.get_frame().set_alpha(0.7)\n                for text in legend.get_texts():\n                    text.set_color('white')\n\n    def listen(self):\n        while True:\n            try:\n                data = self.sock.recv(1024)\n                formatted = self.format_hex(data)\n                timestamp = datetime.now().isoformat()\n\n                is_valid = self.is_valid_tracking_packet(formatted)\n\n                if not self.live_plotting:\n                    if is_valid:\n                        logger.info(\"%s - Response: %s...\", timestamp, formatted[:60])\n                    else:\n                        logger.info(\"%s - Skipped non-tracking packet.\", timestamp)\n\n                if is_valid:\n                    if self.recording and self.log_file is not None:\n                        self.log_file.write(formatted + \"\\n\")\n                        self.log_file.flush()\n\n                    try:\n                        raw_bytes = self.parse_raw_packet(formatted)\n                        packet = self.parse_packet_all_fields(raw_bytes)\n\n                        with self.data_lock:\n                            self.live_data.append(packet)\n                            if len(self.live_data) > 300:\n                                self.live_data.pop(0)\n\n                    except Exception as e:\n                        logger.error(f\"Error parsing packet: {e}\")\n\n            except Exception as e:\n                logger.error(\"Error receiving data: %s\", e)\n                break\n\n    def load_log_file(self, filepath):\n        self.raw_packets = []\n        self.parsed_packets = []\n        try:\n            with open(filepath, 'r') as f:\n                for line in f:\n                    line = line.strip()\n                    if line:\n                        try:\n                            raw_bytes = self.parse_raw_packet(line)\n                            self.raw_packets.append(raw_bytes)\n                            packet = self.parse_packet_all_fields(raw_bytes)\n\n                            min_seq_num = min(\n                                [parsed_packet[\"seq_num\"] for parsed_packet in self.parsed_packets], default=0\n                            )\n\n                            if packet[\"seq_num\"] > min_seq_num:\n                                self.parsed_packets.append(packet)\n\n                        except Exception as e:\n                            logger.error(f\"Error parsing line: {e}\")\n\n            logger.info(f\"Loaded {len(self.parsed_packets)} packets from {filepath}\")\n            return True\n        except Exception as e:\n            logger.error(f\"Error loading log file: {e}\")\n            return False\n\n    def extract_field_values(self, field_name, data_source='loaded'):\n        if data_source == 'loaded':\n            data = self.parsed_packets\n        else:\n            with self.data_lock:\n                data = self.live_data.copy()\n\n        values = [packet.get(field_name, 0) for packet in data if field_name in packet]\n\n        if data_source == 'live' and len(values) > 5:\n            try:\n                values = np.array(values, dtype=float)\n                values = np.convolve(values, np.ones(5) / 5, mode='valid')\n            except Exception as e:\n                logger.warning(f\"Smoothing error (non-critical): {e}\")\n\n        return values\n\n    def is_valid_tracking_packet(self, hex_string):\n        standard_header = \"04 00 04 00 17 00 00 00 10 00\"\n        \n        if not hex_string.startswith(standard_header):\n            if self.live_plotting:\n                logger.warning(\"Invalid packet header: %s\", hex_string[:30])\n            return False\n\n        if len(hex_string.split()) < 80:\n            if self.live_plotting:\n                logger.warning(\"Invalid packet length: %s\", hex_string[:30])\n            return False\n\n        return True\n    \n\n    def plot_fields(self, field_names=None):\n        if not self.parsed_packets:\n            logger.error(\"No data to plot. Load a log file first.\")\n            return\n\n        if field_names is None:\n            field_names = list(KEY_FIELDS.keys())\n\n        if not self.orientation_visualizer.calibration_complete:\n            if len(self.parsed_packets) < self.orientation_visualizer.calibration_sample_count:\n                logger.error(\"Not enough packets for calibration. Need at least 10 packets.\")\n                return\n            for packet in self.parsed_packets[:self.orientation_visualizer.calibration_sample_count]:\n                self.orientation_visualizer.add_calibration_sample([\n                    packet.get('orientation 1', 0),\n                    packet.get('orientation 2', 0),\n                    packet.get('orientation 3', 0)\n                ])\n\n        if self.use_terminal:\n            self._plot_fields_terminal(field_names)\n\n        else:\n            acceleration_fields = [f for f in field_names if 'acceleration' in f.lower()]\n            orientation_fields = [f for f in field_names if 'orientation' in f.lower()]\n            other_fields = [f for f in field_names if f not in acceleration_fields + orientation_fields]\n\n            fig, axes = plt.subplots(3, 1, figsize=(14, 12), sharex=True)\n            self.apply_dark_theme(fig, axes)\n\n            acceleration_colors = ['#FFFF00', '#00FFFF']\n            orientation_colors = ['#FF00FF', '#00FF00', '#FFA500']\n            other_colors = ['#52b788', '#f4a261', '#e76f51', '#2a9d8f']\n\n            if acceleration_fields:\n                for i, field in enumerate(acceleration_fields):\n                    values = self.extract_field_values(field)\n                    axes[0].plot(values, label=field, color=acceleration_colors[i % len(acceleration_colors)], linewidth=2)\n                axes[0].set_title(\"Acceleration Data\", fontsize=14)\n                axes[0].legend()\n\n            if orientation_fields:\n                for i, field in enumerate(orientation_fields):\n                    values = self.extract_field_values(field)\n                    axes[1].plot(values, label=field, color=orientation_colors[i % len(orientation_colors)], linewidth=2)\n                axes[1].set_title(\"Orientation Data\", fontsize=14)\n                axes[1].legend()\n\n            if other_fields:\n                for i, field in enumerate(other_fields):\n                    values = self.extract_field_values(field)\n                    axes[2].plot(values, label=field, color=other_colors[i % len(other_colors)], linewidth=2)\n                axes[2].set_title(\"Other Fields\", fontsize=14)\n                axes[2].legend()\n\n            plt.xlabel(\"Packet Index\", fontsize=12)\n            plt.tight_layout()\n            plt.show()\n\n    def _plot_fields_terminal(self, field_names):\n        \"\"\"Internal method for terminal-based plotting\"\"\"\n        terminal_width = os.get_terminal_size().columns\n        plot_width = min(terminal_width - 10, 120)\n        plot_height = 15\n\n        acceleration_fields = [f for f in field_names if 'acceleration' in f.lower()]\n        orientation_fields = [f for f in field_names if 'orientation' in f.lower()]\n        other_fields = [f for f in field_names if f not in acceleration_fields + orientation_fields]\n\n        def plot_group(fields, title):\n            if not fields:\n                return\n\n            print(f\"\\n{title}\")\n            print(\"=\" * len(title))\n\n            for field in fields:\n                values = self.extract_field_values(field)\n                if len(values) > plot_width:\n                    values = values[-plot_width:]\n\n                if title == \"Acceleration Data\":\n                    chart = acp.plot(values, {'height': plot_height})\n                    print(chart)\n                else:\n                    chart = acp.plot(values, {'height': plot_height})\n                    print(chart)\n\n                print(f\"Min: {min(values):.2f}, Max: {max(values):.2f}, \" +\n                      f\"Mean: {np.mean(values):.2f}\")\n                print()\n\n        plot_group(acceleration_fields, \"Acceleration Data\")\n        plot_group(orientation_fields, \"Orientation Data\")\n        plot_group(other_fields, \"Other Fields\")\n\n    def create_braille_plot(self, values, width=80, height=20, y_label=True, fixed_y_min=None, fixed_y_max=None):\n        canvas = drawille.Canvas()\n        if fixed_y_min is None or fixed_y_max is None:\n            local_min, local_max = min(values), max(values)\n        else:\n            local_min, local_max = fixed_y_min, fixed_y_max\n        y_range = local_max - local_min or 1\n        x_step = max(1, len(values) // width)\n        for i, v in enumerate(values[::x_step]):\n            y = int(((v - local_min) / y_range) * (height * 2 - 1))\n            canvas.set(i, y)\n        frame = canvas.frame()\n        if y_label:\n            lines = frame.split('\\n')\n            labeled_lines = []\n            for idx, line in enumerate(lines):\n                if idx == 0:\n                    labeled_lines.append(f\"{local_max:6.0f} {line}\")\n                elif idx == len(lines)-1:\n                    labeled_lines.append(f\"{local_min:6.0f} {line}\")\n                else:\n                    labeled_lines.append(\"       \" + line)\n            frame = \"\\n\".join(labeled_lines)\n        return frame\n\n    def _start_live_plotting_terminal(self, record_data=False, duration=None):\n        import sys, select, tty, termios\n        old_settings = termios.tcgetattr(sys.stdin)\n        tty.setcbreak(sys.stdin.fileno()) \n        console = Console()\n        term_width = console.width\n        plot_width = round(min(term_width / 2 - 15, 120))\n        ori_height = 10\n        \n        def make_compact_layout():\n            layout = Layout()\n            layout.split_column(\n                Layout(name=\"header\", size=3),\n                Layout(name=\"main\", ratio=1),\n            )\n            layout[\"main\"].split_row(\n                Layout(name=\"accelerations\", ratio=1),\n                Layout(name=\"orientations\", ratio=1)\n            )\n            layout[\"accelerations\"].split_column(\n                Layout(name=\"vertical\", ratio=1),\n                Layout(name=\"horizontal\", ratio=1)\n            )\n            layout[\"orientations\"].split_column(\n                Layout(name=\"face\", ratio=1),\n                Layout(name=\"raw\", ratio=1)\n            )\n            return layout\n        \n        layout = make_compact_layout()\n        \n        try:\n            import time\n            with Live(layout, refresh_per_second=20, screen=True) as live:\n                while True:\n                    if sys.stdin in select.select([sys.stdin], [], [], 0)[0]:\n                        ch = sys.stdin.read(1)\n                        if ch == 'p':\n                            self.paused = not self.paused\n                            logger.info(\"Paused\" if self.paused else \"Resumed\")\n                    if self.paused:\n                        time.sleep(0.1)\n                        rec_str = \" [red][REC][/red]\" if record_data else \"\"\n                        left = \"AirPods Head Tracking - v1.0.0\"\n                        right = \"Ctrl+C - Close | p - Pause\" + rec_str\n                        status = \"[bold red]Paused[/bold red]\"\n                        header = list(\" \" * term_width)\n                        header[0:len(left)] = list(left)\n                        header[term_width - len(right):] = list(right)\n                        start = (term_width - len(status)) // 2\n                        header[start:start+len(status)] = list(status)\n                        header_text = \"\".join(header)\n                        layout[\"header\"].update(Panel(header_text, style=\"bold white on black\"))\n                        continue\n                    \n                    with self.data_lock:\n                        if len(self.live_data) < 1:\n                            continue\n                        latest = self.live_data[-1]\n                        data = self.live_data[-plot_width:]\n                    \n                    if not self.orientation_visualizer.calibration_complete:\n                        sample = [\n                            latest.get('orientation 1', 0),\n                            latest.get('orientation 2', 0),\n                            latest.get('orientation 3', 0)\n                        ]\n                        self.orientation_visualizer.add_calibration_sample(sample)\n                        time.sleep(0.05)\n                        rec_str = \" [red][REC][/red]\" if record_data else \"\"\n                        \n                        left = \"AirPods Head Tracking - v1.0.0\"\n                        status = \"[bold yellow]Calibrating...[/bold yellow]\"\n                        right = \"Ctrl+C - Close | p - Pause\"\n                        remaining = max(term_width - len(left) - len(right), 0)\n                        header_text = f\"{left}{status.center(remaining)}{right}{rec_str}\"\n                        layout[\"header\"].update(Panel(header_text, style=\"bold white on black\"))\n                        live.refresh()\n                        continue\n                    \n                    o1 = latest.get('orientation 1', 0)\n                    o2 = latest.get('orientation 2', 0)\n                    o3 = latest.get('orientation 3', 0)\n                    orientation = self.orientation_visualizer.calculate_orientation(o1, o2, o3)\n                    pitch = orientation['pitch']\n                    yaw = orientation['yaw']\n                    \n                    h_accel = [p.get('Horizontal Acceleration', 0) for p in data]\n                    v_accel = [p.get('Vertical Acceleration', 0) for p in data]\n                    if len(h_accel) > plot_width:\n                        h_accel = h_accel[-plot_width:]\n                    if len(v_accel) > plot_width:\n                        v_accel = v_accel[-plot_width:]\n                    global_min = min(min(v_accel), min(h_accel))\n                    global_max = max(max(v_accel), max(h_accel))\n                    config_acc = {'height': 20, 'min': global_min, 'max': global_max}\n                    vert_plot = acp.plot(v_accel, config_acc)\n                    horiz_plot = acp.plot(h_accel, config_acc)\n                    \n                    rec_str = \" [red][REC][/red]\" if record_data else \"\"\n                    left = \"AirPods Head Tracking - v1.0.0\"\n                    right = \"Ctrl+C - Close | p - Pause\" + rec_str\n                    status = \"[bold green]Live[/bold green]\"\n                    header = list(\" \" * term_width)\n                    header[0:len(left)] = list(left)\n                    header[term_width - len(right):] = list(right)\n                    start = (term_width - len(status)) // 2\n                    header[start:start+len(status)] = list(status)\n                    header_text = \"\".join(header)\n                    layout[\"header\"].update(Panel(header_text, style=\"bold white on black\"))\n                    \n                    face_art = self.orientation_visualizer.create_face_art(pitch, yaw)\n                    layout[\"accelerations\"][\"vertical\"].update(Panel(\n                        \"[bold yellow]Vertical Acceleration[/]\\n\" +\n                        vert_plot + \"\\n\" +\n                        f\"Cur: {v_accel[-1]:6.1f} | Min: {min(v_accel):6.1f} | Max: {max(v_accel):6.1f}\",\n                        style=\"yellow\"\n                    ))\n                    layout[\"accelerations\"][\"horizontal\"].update(Panel(\n                        \"[bold cyan]Horizontal Acceleration[/]\\n\" +\n                        horiz_plot + \"\\n\" +\n                        f\"Cur: {h_accel[-1]:6.1f} | Min: {min(h_accel):6.1f} | Max: {max(h_accel):6.1f}\",\n                        style=\"cyan\"\n                    ))\n                    layout[\"orientations\"][\"face\"].update(Panel(face_art, title=\"[green]Orientation - Visualization[/]\", style=\"green\"))\n                    \n                    o2_values = [p.get('orientation 2', 0) for p in data[-plot_width:]]\n                    o3_values = [p.get('orientation 3', 0) for p in data[-plot_width:]]\n                    o2_values = o2_values[:plot_width]\n                    o3_values = o3_values[:plot_width]\n                    common_min = min(min(o2_values), min(o3_values))\n                    common_max = max(max(o2_values), max(o3_values))\n                    config_ori = {'height': ori_height, 'min': common_min, 'max': common_max, 'format': \"{:6.0f}\"}\n                    chart_o2 = acp.plot(o2_values, config_ori)\n                    chart_o3 = acp.plot(o3_values, config_ori)\n                    layout[\"orientations\"][\"raw\"].update(Panel(\n                        \"[bold yellow]Orientation 1:[/]\\n\" + chart_o2 + \"\\n\" +\n                        f\"Cur: {o2_values[-1]:6.1f} | Min: {min(o2_values):6.1f} | Max: {max(o2_values):6.1f}\\n\\n\" +\n                        \"[bold green]Orientation 2:[/]\\n\" + chart_o3 + \"\\n\" +\n                        f\"Cur: {o3_values[-1]:6.1f} | Min: {min(o3_values):6.1f} | Max: {max(o3_values):6.1f}\",\n                        title=\"[cyan]Orientation Raw[/]\", style=\"yellow\"\n                    ))\n                    live.refresh()\n                    time.sleep(0.05)\n        except KeyboardInterrupt:\n            logger.info(\"\\nStopped.\")\n            if record_data:\n                self.stop_tracking()\n            else:\n                if self.sock:\n                    self.sock.send(bytes.fromhex(STOP_CMD))\n        finally:\n            termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)\n\n    def _start_live_plotting(self, record_data=False, duration=None):\n        terminal_width = os.get_terminal_size().columns\n        plot_width = min(terminal_width - 10, 80)\n        plot_height = 10\n\n        try:\n            while True:\n                os.system('clear' if os.name == 'posix' else 'cls')\n                with self.data_lock:\n                    if len(self.live_data) == 0:\n                        print(\"\\nWaiting for data...\")\n                        time.sleep(0.1)\n                        continue\n\n                    data = self.live_data[-plot_width:]\n\n                acceleration_fields = [f for f in KEY_FIELDS.keys() if 'acceleration' in f.lower()]\n                orientation_fields = [f for f in KEY_FIELDS.keys() if 'orientation' in f.lower()]\n                other_fields = [f for f in KEY_FIELDS.keys() if f not in acceleration_fields + orientation_fields]\n\n                def plot_group(fields, title):\n                    if not fields:\n                        return\n\n                    print(f\"\\n{title}\")\n                    print(\"=\" * len(title))\n\n                    for field in fields:\n                        values = [packet.get(field, 0) for packet in data if field in packet]\n                        if len(values) > 0:\n                            chart = acp.plot(values, {'height': plot_height})\n                            print(chart)\n                            print(f\"Current: {values[-1]:.2f}, \" +\n                                  f\"Min: {min(values):.2f}, Max: {max(values):.2f}\")\n                        print()\n\n                plot_group(acceleration_fields, \"Acceleration Data\")\n                plot_group(orientation_fields, \"Orientation Data\")\n                plot_group(other_fields, \"Other Fields\")\n\n                print(\"\\nPress Ctrl+C to stop plotting\")\n                time.sleep(0.1)\n\n        except KeyboardInterrupt:\n            logger.info(\"\\nLive plotting stopped.\")\n            self.sock.send(bytes.fromhex(STOP_CMD))\n            if record_data:\n                self.stop_tracking()\n            self.live_plotting = False\n\n    def start_live_plotting(self, record_data=False, duration=None):\n        if self.sock is None:\n            if not self.connect():\n                logger.error(\"Could not connect to AirPods. Live plotting aborted.\")\n                return\n        if not self.recording and record_data:\n            self.start_tracking(duration)\n            logger.info(\"Recording enabled during live plotting\")\n        elif not self.recording:\n            self.sock.send(bytes.fromhex(START_CMD))\n            logger.info(\"Head tracking started (not recording to file)\")\n        with self.data_lock:\n            self.live_data = []\n        self.live_plotting = True\n        self.paused = False\n        if self.use_terminal:\n            self._start_live_plotting_terminal(record_data, duration)\n        else:\n            from matplotlib.gridspec import GridSpec, GridSpecFromSubplotSpec\n            fig = plt.figure(figsize=(14, 6))\n            gs = GridSpec(1, 2, width_ratios=[1, 1])\n            ax_accel = fig.add_subplot(gs[0])\n            subgs = GridSpecFromSubplotSpec(2, 1, subplot_spec=gs[1], height_ratios=[2, 1])\n            ax_head_top = fig.add_subplot(subgs[0], projection='3d')\n            ax_ori = fig.add_subplot(subgs[1])\n            \n            ax_accel.set_title(\"Acceleration Data\")\n            ax_accel.set_xlabel(\"Packet Index\")\n            ax_accel.set_ylabel(\"Acceleration\")\n            ax_accel.legend(loc='upper right', framealpha=0.7)\n            fig.patch.set_facecolor('#1e1e1e')\n            ax_accel.set_facecolor('#2d2d2d')\n            self.apply_dark_theme(fig, [ax_accel, ax_head_top, ax_ori])\n            plt.ion()\n\n            def update_plot(_):\n                with self.data_lock:\n                    data = self.live_data.copy()\n                if len(data) == 0:\n                    return\n                \n                latest = data[-1]\n                \n                if not self.orientation_visualizer.calibration_complete:\n                    sample = [\n                        latest.get('orientation 1', 0),\n                        latest.get('orientation 2', 0),\n                        latest.get('orientation 3', 0)\n                    ]\n                    self.orientation_visualizer.add_calibration_sample(sample)\n                    ax_head_top.cla()\n                    ax_head_top.text(0.5, 0.5, \"Calibrating... please wait\", horizontalalignment='center', verticalalignment='center', transform=ax_head_top.transAxes, color='white')\n                    fig.canvas.draw_idle()\n                    return\n\n                h_accel = [p.get('Horizontal Acceleration', 0) for p in data]\n                v_accel = [p.get('Vertical Acceleration', 0) for p in data]\n                x_vals = list(range(len(h_accel)))\n                ax_accel.cla()\n                ax_accel.plot(x_vals, v_accel, label='Vertical Acceleration', color='#FFFF00', linewidth=2)\n                ax_accel.plot(x_vals, h_accel, label='Horizontal Acceleration', color='#00FFFF', linewidth=2)\n                ax_accel.set_title(\"Acceleration Data\")\n                ax_accel.set_xlabel(\"Packet Index\")\n                ax_accel.set_ylabel(\"Acceleration\")\n                ax_accel.legend(loc='upper right', framealpha=0.7)\n                ax_accel.set_facecolor('#2d2d2d')\n                ax_accel.title.set_color('white')\n                ax_accel.xaxis.label.set_color('white')\n                ax_accel.yaxis.label.set_color('white')\n                \n                latest = data[-1]\n                o1 = latest.get('orientation 1', 0)\n                o2 = latest.get('orientation 2', 0)\n                o3 = latest.get('orientation 3', 0)\n                orientation = self.orientation_visualizer.calculate_orientation(o1, o2, o3)\n                pitch = orientation['pitch']\n                yaw = orientation['yaw']\n        \n                ax_head_top.cla()\n                ax_head_top.set_title(\"Head Orientation\")\n                ax_head_top.set_xlim([-1, 1])\n                ax_head_top.set_ylim([-1, 1])\n                ax_head_top.set_zlim([-1, 1])\n                ax_head_top.set_facecolor('#2d2d2d')\n                pitch_rad = np.radians(pitch)\n                yaw_rad = np.radians(yaw)\n                Rz = np.array([\n                    [np.cos(yaw_rad), np.sin(yaw_rad), 0],\n                    [-np.sin(yaw_rad), np.cos(yaw_rad), 0],\n                    [0, 0, 1]\n                ])\n                Ry = np.array([\n                    [np.cos(pitch_rad), 0, np.sin(pitch_rad)],\n                    [0, 1, 0],\n                    [-np.sin(pitch_rad), 0, np.cos(pitch_rad)]\n                ])\n                R = Rz @ Ry\n                dir_vec = R @ np.array([1, 0, 0])\n                ax_head_top.quiver(0, 0, 0, dir_vec[0], dir_vec[1], dir_vec[2],\n                                   color='r', length=0.8, linewidth=3)\n                \n                ax_ori.cla()\n                o2_values = [p.get('orientation 2', 0) for p in data]\n                o3_values = [p.get('orientation 3', 0) for p in data]\n                x_range = list(range(len(o2_values)))\n                ax_ori.plot(x_range, o2_values, label='Orientation 1', color='red', linewidth=2)\n                ax_ori.plot(x_range, o3_values, label='Orientation 2', color='green', linewidth=2)\n                ax_ori.set_facecolor('#2d2d2d')\n                ax_ori.tick_params(colors='white')\n                ax_ori.set_title(\"Orientation Raw\")\n                ax_ori.legend(facecolor='#2d2d2d', edgecolor='#555555', \n                              labelcolor='white', loc='upper right')\n                ax_ori.text(0.95, 0.9, f\"Pitch: {pitch:.1f}\u00b0\\nYaw: {yaw:.1f}\u00b0\",\n                            transform=ax_ori.transAxes, color='white',\n                            ha='right', va='top', bbox=dict(facecolor='#2d2d2d', alpha=0.5))\n                fig.canvas.draw_idle()\n            self.animation = FuncAnimation(\n                fig, update_plot,\n                interval=20,\n                blit=False,\n                cache_frame_data=False\n            )\n            plt.show(block=True)\n            self.sock.send(bytes.fromhex(STOP_CMD))\n            logger.info(\"Stopping head tracking AirPods.\")\n            if self.recording and record_data:\n                self.stop_tracking()\n                logger.info(\"Recording stopped after sending close command\")\n            else:\n                logger.info(\"Live plotting ended (no recording to stop).\")\n            self.live_plotting = False\n            self.animation = None\n            plt.ioff()\n\n    def interactive_mode(self):\n        from prompt_toolkit import PromptSession\n        session = PromptSession(\"> \")\n        logger.info(\"\\nAirPods Head Tracking Analyzer\")\n        print(\"------------------------------\")\n        logger.info(\"Commands:\")\n        print(\"  connect                 - connect to your AirPods\")\n        print(\"  start [seconds]         - start recording head tracking data, optionally for specified duration\")\n        print(\"  stop                    - stop recording\")\n        print(\"  load <file>             - load and parse a log file\")\n        print(\"  plot                    - plot all sensor data fields\")\n        print(\"  live [seconds]          - start live plotting (without recording), optionally stop recording after seconds\")\n        print(\"  liver [seconds]         - start live plotting with recording, optionally stop recording after seconds\")\n        print(\"  gestures                - start gesture detection\")\n        print(\"  quit                    - exit the program\")\n        \n        while True:\n            try:\n                cmd_input = session.prompt(\"> \")\n                cmd_parts = cmd_input.strip().split()\n                if not cmd_parts:\n                    continue\n                cmd = cmd_parts[0].lower()\n                if cmd == \"connect\":\n                    self.connect()\n                elif cmd == \"start\":\n                    duration = float(cmd_parts[1]) if len(cmd_parts) > 1 else None\n                    self.start_tracking(duration)\n                elif cmd == \"stop\":\n                    self.stop_tracking()\n                elif cmd == \"load\" and len(cmd_parts) > 1:\n                    self.load_log_file(cmd_parts[1])\n                elif cmd == \"plot\":\n                    self.plot_fields()\n                elif cmd == \"live\":\n                    duration = float(cmd_parts[1]) if len(cmd_parts) > 1 else None\n                    logger.info(\"Starting live plotting mode (without recording)%s.\", \n                                f\" for {duration} seconds\" if duration else \"\")\n                    self.start_live_plotting(record_data=False, duration=duration)\n                elif cmd == \"liver\":\n                    duration = float(cmd_parts[1]) if len(cmd_parts) > 1 else None\n                    logger.info(\"Starting live plotting mode WITH recording%s.\", \n                                f\" for {duration} seconds\" if duration else \"\")\n                    self.start_live_plotting(record_data=True, duration=duration)\n                elif cmd == \"gestures\":\n                    from gestures import GestureDetector\n                    if self.conn is not None:\n                        detector = GestureDetector(conn=self.conn)\n                    else:\n                        detector = GestureDetector()\n                    detector.start_detection()\n                elif cmd == \"quit\":\n                    logger.info(\"Exiting.\")\n                    if self.conn != None:\n                        self.conn.disconnect()\n                    break\n                elif cmd == \"help\":\n                    logger.info(\"\\nAirPods Head Tracking Analyzer\")\n                    logger.info(\"------------------------------\")\n                    logger.info(\"Commands:\")\n                    logger.info(\"  connect                 - connect to your AirPods\")\n                    logger.info(\"  start [seconds]         - start recording head tracking data, optionally for specified duration\")\n                    logger.info(\"  stop                    - stop recording\")\n                    logger.info(\"  load <file>             - load and parse a log file\")\n                    logger.info(\"  plot                    - plot all sensor data fields\")\n                    logger.info(\"  live [seconds]          - start live plotting (without recording), optionally stop recording after seconds\")\n                    logger.info(\"  liver [seconds]         - start live plotting with recording, optionally stop recording after seconds\")\n                    logger.info(\"  gestures                - start gesture detection\")\n                    logger.info(\"  quit                    - exit the program\")\n                else:\n                    logger.info(\"Unknown command. Type 'help' to see available commands.\")\n            except KeyboardInterrupt:\n                logger.info(\"Use 'quit' to exit.\")\n            except EOFError:\n                logger.info(\"Exiting.\")\n                if self.conn != None:\n                    self.conn.disconnect()\n                break\n\nif __name__ == \"__main__\":\n    import sys\n    tracker = AirPodsTracker()\n    tracker.interactive_mode()"
        },
        {
          "name": "connection_manager.py",
          "ext": ".py",
          "size": 2415,
          "preview": "import bluetooth\nimport logging\n\nclass ConnectionManager:\n    INIT_CMD  = \"00 00 04 00 01 00 02 00 00 00 00 00 00 00 00 00\"\n    START_CMD = \"04 00 04 00 17 00 00 00 10 00 10 00 08 A1 02 42 0B 08 0E 10 02 1A 05 01 40 9C 00 00\"\n    STOP_CMD  = \"04 00 04 00 17 00 00 00 10 00 11 00 08 7E 10 02 42 0B 08 4E 10 02 1A 05 01 00 00 00 00\"\n\n    def __init__(self, bt_addr=\"28:2D:7F:C2:05:5B\", psm=0x1001, logger=None):\n        self.bt_addr = bt_addr\n        self.psm = psm\n        self.logger = logger if logger else logging.getLogger(__name__)\n        self.sock = None\n        self.connected = False\n        self.started = False\n\n    def connect(self):\n        self.logger.info(f\"Connecting to {self.bt_addr} on PSM {self.psm:#04x}...\")\n        try:\n            self.sock = bluetooth.BluetoothSocket(bluetooth.L2CAP)\n            self.sock.connect((self.bt_addr, self.psm))\n            self.connected = True\n            self.logger.info(\"Connected to AirPods.\")\n            self.sock.send(bytes.fromhex(self.INIT_CMD))\n            self.logger.info(\"Initialization complete.\")\n        except Exception as e:\n            self.logger.error(f\"Connection failed: {e}\")\n            self.connected = False\n        return self.connected\n\n    def send_start(self):\n        if not self.connected:\n            self.logger.error(\"Not connected. Cannot send START command.\")\n            return False\n        if not self.started:\n            self.sock.send(bytes.fromhex(self.START_CMD))\n            self.started = True\n            self.logger.info(\"START command sent.\")\n        else:\n            self.logger.info(\"START command has already been sent.\")\n        return True\n\n    def send_stop(self):\n        if self.connected and self.started:\n            try:\n                self.sock.send(bytes.fromhex(self.STOP_CMD))\n                self.logger.info(\"STOP command sent.\")\n                self.started = False\n            except Exception as e:\n                self.logger.error(f\"Error sending STOP command: {e}\")\n        else:\n            self.logger.info(\"Cannot send STOP; not started or not connected.\")\n\n    def disconnect(self):\n        if self.sock:\n            try:\n                self.sock.close()\n                self.logger.info(\"Disconnected from AirPods.\")\n            except Exception as e:\n                self.logger.error(f\"Error during disconnect: {e}\")\n        self.connected = False\n        self.started = False"
        },
        {
          "name": "gestures.py",
          "ext": ".py",
          "size": 16471,
          "preview": "import bluetooth\nimport threading\nimport time\nimport logging\nimport statistics\nfrom collections import deque\n\nclass Colors:\n    RESET = \"\\033[0m\"\n    BOLD = \"\\033[1m\"\n    RED = \"\\033[91m\"\n    GREEN = \"\\033[92m\"\n    YELLOW = \"\\033[93m\"\n    BLUE = \"\\033[94m\"\n    MAGENTA = \"\\033[95m\"\n    CYAN = \"\\033[96m\"\n    WHITE = \"\\033[97m\"\n    BG_BLACK = \"\\033[40m\"\n\nclass ColorFormatter(logging.Formatter):\n    FORMATS = {\n        logging.DEBUG: Colors.BLUE + \"[%(levelname)s] %(message)s\" + Colors.RESET,\n        logging.INFO: Colors.GREEN + \"%(message)s\" + Colors.RESET,\n        logging.WARNING: Colors.YELLOW + \"%(message)s\" + Colors.RESET,\n        logging.ERROR: Colors.RED + \"[%(levelname)s] %(message)s\" + Colors.RESET,\n        logging.CRITICAL: Colors.RED + Colors.BOLD + \"[%(levelname)s] %(message)s\" + Colors.RESET\n    }\n\n    def format(self, record):\n        log_fmt = self.FORMATS.get(record.levelno)\n        formatter = logging.Formatter(log_fmt, datefmt=\"%H:%M:%S\")\n        return formatter.format(record)\n\nhandler = logging.StreamHandler()\nhandler.setFormatter(ColorFormatter())\nlog = logging.getLogger(__name__)\nlog.setLevel(logging.INFO)\nlog.addHandler(handler)\nlog.propagate = False\n\nclass GestureDetector:\n    INIT_CMD  = \"00 00 04 00 01 00 02 00 00 00 00 00 00 00 00 00\"\n    START_CMD = \"04 00 04 00 17 00 00 00 10 00 10 00 08 A1 02 42 0B 08 0E 10 02 1A 05 01 40 9C 00 00\"\n    STOP_CMD  = \"04 00 04 00 17 00 00 00 10 00 11 00 08 7E 10 02 42 0B 08 4E 10 02 1A 05 01 00 00 00 00\"\n\n    def __init__(self, conn=None):\n        self.sock = None\n        self.bt_addr = \"28:2D:7F:C2:05:5B\"\n        self.psm = 0x1001\n        self.running = False\n        self.data_lock = threading.Lock()\n        \n        self.horiz_buffer = deque(maxlen=100)\n        self.vert_buffer = deque(maxlen=100)\n        \n        self.horiz_avg_buffer = deque(maxlen=5)\n        self.vert_avg_buffer = deque(maxlen=5)\n        \n        self.horiz_peaks = []\n        self.horiz_troughs = []\n        self.vert_peaks = []\n        self.vert_troughs = []\n        \n        self.last_peak_time = 0\n        self.peak_intervals = deque(maxlen=5)\n        \n        self.peak_threshold = 400\n        self.direction_change_threshold = 175\n        self.rhythm_consistency_threshold = 0.5\n        \n        self.horiz_increasing = None\n        self.vert_increasing = None\n        \n        self.required_extremes = 3\n        self.detection_timeout = 15\n        \n        self.min_confidence_threshold = 0.7\n        \n        self.conn = conn\n\n    def connect(self):\n        try:\n            log.info(f\"Connecting to AirPods at {self.bt_addr}...\")\n            if self.conn is None:\n                from connection_manager import ConnectionManager\n                self.conn = ConnectionManager(self.bt_addr, self.psm, logger=log)\n                if not self.conn.connect():\n                    return False\n            else:\n                if not self.conn.connected:\n                    if not self.conn.connect():\n                        return False\n            self.sock = self.conn.sock\n            log.info(f\"{Colors.GREEN}\u2713 Connected to AirPods via ConnectionManager{Colors.RESET}\")\n            return True\n        except Exception as e:\n            log.error(f\"{Colors.RED}Connection failed: {e}{Colors.RESET}\")\n            return False\n    \n    def process_data(self):\n        \"\"\"Process incoming head tracking data.\"\"\"\n        self.conn.send_start()\n        log.info(f\"{Colors.GREEN}\u2713 Head tracking activated{Colors.RESET}\")\n    \n        self.running = True\n        start_time = time.time()\n\n        log.info(f\"{Colors.GREEN}Ready! Make a YES or NO gesture{Colors.RESET}\")\n        log.info(f\"{Colors.YELLOW}Tip: Use natural, moderate speed head movements{Colors.RESET}\")\n        \n        while self.running:\n            if time.time() - start_time > self.detection_timeout:\n                log.warning(f\"{Colors.YELLOW}\u26a0\ufe0f  Detection timeout reached. No gesture detected.{Colors.RESET}\")\n                self.running = False\n                break\n                \n            try:\n                if not self.sock:\n                    log.error(\"Socket not available.\")\n                    break\n                data = self.sock.recv(1024)\n                formatted = self.format_hex(data)\n                if self.is_valid_tracking_packet(formatted):\n                    raw_bytes = bytes.fromhex(formatted.replace(\" \", \"\"))\n                    horizontal, vertical = self.extract_orientation_values(raw_bytes)\n                    \n                    if horizontal is not None and vertical is not None:\n                        smooth_h, smooth_v = self.apply_smoothing(horizontal, vertical)\n                        \n                        with self.data_lock:\n                            self.horiz_buffer.append(smooth_h)\n                            self.vert_buffer.append(smooth_v)\n                            \n                            self.detect_peaks_and_troughs()\n                            gesture = self.detect_gestures()\n                            \n                            if gesture:\n                                self.running = False\n                                break\n        \n            except Exception as e:\n                if self.running:\n                    log.error(f\"Data processing error: {e}\")\n                break\n\n    def disconnect(self):\n        \"\"\"Disconnect from socket.\"\"\"\n        self.conn.disconnect()\n\n    def format_hex(self, data):\n        \"\"\"Format binary data to readable hex string.\"\"\"\n        hex_str = data.hex()\n        return ' '.join(hex_str[i:i+2] for i in range(0, len(hex_str), 2))\n    \n    def is_valid_tracking_packet(self, hex_string):\n        \"\"\"Verify packet is a valid head tracking packet.\"\"\"\n        standard_header = \"04 00 04 00 17 00 00 00 10 00 45 00\"\n        alternate_header = \"04 00 04 00 17 00 00 00 10 00 44 00\"\n        if not hex_string.startswith(standard_header) and not hex_string.startswith(alternate_header):\n            return False\n            \n        if len(hex_string.split()) < 80:\n            return False\n            \n        return True\n    \n    def extract_orientation_values(self, raw_bytes):\n        \"\"\"Extract head orientation data from packet.\"\"\"\n        try:\n            horizontal = int.from_bytes(raw_bytes[51:53], byteorder='little', signed=True)\n            vertical = int.from_bytes(raw_bytes[53:55], byteorder='little', signed=True)\n            \n            return horizontal, vertical\n        except Exception as e:\n            log.debug(f\"Failed to extract orientation: {e}\")\n            return None, None\n    \n    def apply_smoothing(self, horizontal, vertical):\n        \"\"\"Apply moving average smoothing (Apple-like filtering).\"\"\"\n        self.horiz_avg_buffer.append(horizontal)\n        self.vert_avg_buffer.append(vertical)\n        \n        smooth_horiz = sum(self.horiz_avg_buffer) / len(self.horiz_avg_buffer)\n        smooth_vert = sum(self.vert_avg_buffer) / len(self.vert_avg_buffer)\n        \n        return smooth_horiz, smooth_vert\n    \n    def detect_peaks_and_troughs(self):\n        \"\"\"Detect motion direction changes with Apple-like refinements.\"\"\"\n        if len(self.horiz_buffer) < 4 or len(self.vert_buffer) < 4:\n            return\n            \n        h_values = list(self.horiz_buffer)[-4:]\n        v_values = list(self.vert_buffer)[-4:]\n        \n        h_variance = statistics.variance(h_values) if len(h_values) > 1 else 0\n        v_variance = statistics.variance(v_values) if len(v_values) > 1 else 0\n        \n        current = self.horiz_buffer[-1]\n        prev = self.horiz_buffer[-2]\n        \n        if self.horiz_increasing is None:\n            self.horiz_increasing = current > prev\n        \n        dynamic_h_threshold = max(100, min(self.direction_change_threshold, h_variance / 3))\n        \n        if self.horiz_increasing and current < prev - dynamic_h_threshold:\n            if abs(prev) > self.peak_threshold:\n                self.horiz_peaks.append((len(self.horiz_buffer)-1, prev, time.time()))\n                direction = \"\u27a1\ufe0f \" if prev > 0 else \"\u2b05\ufe0f \"\n                log.info(f\"{Colors.CYAN}{direction} Horizontal max: {prev} (threshold: {dynamic_h_threshold:.1f}){Colors.RESET}\")\n                \n                now = time.time()\n                if self.last_peak_time > 0:\n                    interval = now - self.last_peak_time\n                    self.peak_intervals.append(interval)\n                self.last_peak_time = now\n                \n            self.horiz_increasing = False\n            \n        elif not self.horiz_increasing and current > prev + dynamic_h_threshold:\n            if abs(prev) > self.peak_threshold:\n                self.horiz_troughs.append((len(self.horiz_buffer)-1, prev, time.time()))\n                direction = \"\u27a1\ufe0f \" if prev > 0 else \"\u2b05\ufe0f \"\n                log.info(f\"{Colors.CYAN}{direction} Horizontal max: {prev} (threshold: {dynamic_h_threshold:.1f}){Colors.RESET}\")\n                \n                now = time.time()\n                if self.last_peak_time > 0:\n                    interval = now - self.last_peak_time\n                    self.peak_intervals.append(interval)\n                self.last_peak_time = now\n                \n            self.horiz_increasing = True\n        \n        current = self.vert_buffer[-1]\n        prev = self.vert_buffer[-2]\n        \n        if self.vert_increasing is None:\n            self.vert_increasing = current > prev\n        \n        dynamic_v_threshold = max(100, min(self.direction_change_threshold, v_variance / 3))\n        \n        if self.vert_increasing and current < prev - dynamic_v_threshold:\n            if abs(prev) > self.peak_threshold:\n                self.vert_peaks.append((len(self.vert_buffer)-1, prev, time.time()))\n                direction = \"\u2b06\ufe0f \" if prev > 0 else \"\u2b07\ufe0f \"\n                log.info(f\"{Colors.MAGENTA}{direction} Vertical max: {prev} (threshold: {dynamic_v_threshold:.1f}){Colors.RESET}\")\n                \n                now = time.time()\n                if self.last_peak_time > 0:\n                    interval = now - self.last_peak_time\n                    self.peak_intervals.append(interval)\n                self.last_peak_time = now\n                \n            self.vert_increasing = False\n            \n        elif not self.vert_increasing and current > prev + dynamic_v_threshold:\n            if abs(prev) > self.peak_threshold:\n                self.vert_troughs.append((len(self.vert_buffer)-1, prev, time.time()))\n                direction = \"\u2b06\ufe0f \" if prev > 0 else \"\u2b07\ufe0f \"\n                log.info(f\"{Colors.MAGENTA}{direction} Vertical max: {prev} (threshold: {dynamic_v_threshold:.1f}){Colors.RESET}\")\n                \n                now = time.time()\n                if self.last_peak_time > 0:\n                    interval = now - self.last_peak_time\n                    self.peak_intervals.append(interval)\n                self.last_peak_time = now\n                \n            self.vert_increasing = True\n    \n    def calculate_rhythm_consistency(self):\n        \"\"\"Calculate how consistent the timing between peaks is (Apple-like).\"\"\"\n        if len(self.peak_intervals) < 2:\n            return 0\n            \n        mean_interval = statistics.mean(self.peak_intervals)\n        if mean_interval == 0:\n            return 0\n            \n        variances = [(i/mean_interval - 1.0) ** 2 for i in self.peak_intervals]\n        consistency = 1.0 - min(1.0, statistics.mean(variances) / self.rhythm_consistency_threshold)\n        return max(0, consistency)\n    \n    def calculate_confidence_score(self, extremes, is_vertical=True):\n        \"\"\"Calculate confidence score for gesture detection (Apple-like).\"\"\"\n        if len(extremes) < self.required_extremes:\n            return 0.0\n            \n        sorted_extremes = sorted(extremes, key=lambda x: x[0])\n        \n        recent = sorted_extremes[-self.required_extremes:]\n        \n        avg_amplitude = sum(abs(val) for _, val, _ in recent) / len(recent)\n        amplitude_factor = min(1.0, avg_amplitude / 600)\n        \n        rhythm_factor = self.calculate_rhythm_consistency()\n        \n        signs = [1 if val > 0 else -1 for _, val, _ in recent]\n        alternating = all(signs[i] != signs[i-1] for i in range(1, len(signs)))\n        alternation_factor = 1.0 if alternating else 0.5\n        \n        if is_vertical:\n            vert_amp = sum(abs(val) for _, val, _ in recent) / len(recent)\n            horiz_vals = list(self.horiz_buffer)[-len(recent)*2:]\n            horiz_amp = sum(abs(val) for val in horiz_vals) / len(horiz_vals) if horiz_vals else 0\n            isolation_factor = min(1.0, vert_amp / (horiz_amp + 0.1) * 1.2)\n        else:\n            horiz_amp = sum(abs(val) for _, val, _ in recent)\n            vert_vals = list(self.vert_buffer)[-len(recent)*2:]\n            vert_amp = sum(abs(val) for val in vert_vals) / len(vert_vals) if vert_vals else 0\n            isolation_factor = min(1.0, horiz_amp / (vert_amp + 0.1) * 1.2)\n        \n        confidence = (\n            amplitude_factor * 0.4 + \n            rhythm_factor * 0.2 +\n            alternation_factor * 0.2 +\n            isolation_factor * 0.2\n        )\n        \n        return confidence\n    \n    def detect_gestures(self):\n        \"\"\"Recognize head gesture patterns with Apple-like intelligence.\"\"\"\n        if len(self.vert_peaks) + len(self.vert_troughs) >= self.required_extremes:\n            all_extremes = sorted(self.vert_peaks + self.vert_troughs, key=lambda x: x[0])\n            \n            confidence = self.calculate_confidence_score(all_extremes, is_vertical=True)\n            \n            log.info(f\"Vertical motion confidence: {confidence:.2f} (need {self.min_confidence_threshold:.2f})\")\n            \n            if confidence >= self.min_confidence_threshold:\n                log.info(f\"{Colors.GREEN}\ud83c\udfaf \\\"Yes\\\" Gesture Detected (confidence: {confidence:.2f}){Colors.RESET}\")\n                return \"YES\"\n        \n        if len(self.horiz_peaks) + len(self.horiz_troughs) >= self.required_extremes:\n            all_extremes = sorted(self.horiz_peaks + self.horiz_troughs, key=lambda x: x[0])\n            \n            confidence = self.calculate_confidence_score(all_extremes, is_vertical=False)\n            \n            log.info(f\"Horizontal motion confidence: {confidence:.2f} (need {self.min_confidence_threshold:.2f})\")\n            \n            if confidence >= self.min_confidence_threshold:\n                log.info(f\"{Colors.GREEN}\ud83c\udfaf \\\"No\\\" gesture detected (confidence: {confidence:.2f}){Colors.RESET}\")\n                return \"NO\"\n        \n        return None\n    \n    def start_detection(self):\n        \"\"\"Begin gesture detection process.\"\"\"\n        log.info(f\"{Colors.BOLD}{Colors.WHITE}Starting gesture detection...{Colors.RESET}\")\n        \n        if not self.connect():\n            log.error(f\"{Colors.RED}Failed to connect to AirPods.{Colors.RESET}\")\n            return\n        \n        data_thread = threading.Thread(target=self.process_data)\n        data_thread.daemon = True\n        data_thread.start()\n        \n        try:\n            data_thread.join(timeout=self.detection_timeout + 2)\n            if data_thread.is_alive():\n                log.warning(f\"{Colors.YELLOW}\u26a0\ufe0f  Timeout reached. Stopping detection.{Colors.RESET}\")\n                self.running = False\n        except KeyboardInterrupt:\n            log.info(f\"{Colors.YELLOW}Detection canceled by user.{Colors.RESET}\")\n            self.running = False\n        if __name__ == \"__main__\":\n            self.disconnect()\n        log.info(f\"{Colors.GREEN}Gesture detection complete.{Colors.RESET}\")\n\nif __name__ == \"__main__\":\n    print(f\"{Colors.BG_BLACK}{Colors.CYAN}\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557{Colors.RESET}\")\n    print(f\"{Colors.BG_BLACK}{Colors.CYAN}\u2551     AirPods Head Gesture Detector      \u2551{Colors.RESET}\")\n    print(f\"{Colors.BG_BLACK}{Colors.CYAN}\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d{Colors.RESET}\")\n    print(f\"\\n{Colors.WHITE}This program detects head gestures using AirPods:{Colors.RESET}\")\n    print(f\"{Colors.GREEN}\u2022 YES: {Colors.WHITE}nodding head up and down{Colors.RESET}\")\n    print(f\"{Colors.RED}\u2022 NO: {Colors.WHITE}shaking head left and right{Colors.RESET}\\n\")\n    \n    detector = GestureDetector()\n    detector.start_detection()"
        }
      ]
    }
  ]
}